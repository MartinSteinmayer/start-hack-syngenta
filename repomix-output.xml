This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  api/
    environmental-data/
      route.ts
    products/
      route.ts
  simulation/
    components/
      CropInfoPanel.tsx
      FarmGameView.tsx
      ProductSelector.tsx
      ResultsPanel.tsx
      SimulationControls.tsx
      ThreeFarmScene.tsx
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  farm/
    CropSelector.tsx
    CropStressAnalysis.tsx
    EnvironmentalDataDisplay.tsx
    FarmSetup.tsx
    FarmSetupWizard.tsx
    LocationPicker.tsx
    MapComponent.tsx
  styles/
    Navbar.css
  ui/
    Button.tsx
    Card.tsx
    HeroSection.tsx
    Navbar.tsx
lib/
  data/
    products.json
  hooks/
    useFarmData.ts
    useProducts.ts
  services/
    farmEnvironmentService.ts
public/
  data/
    mock-environment.json
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
types/
  farm.ts
  products.ts
  simulation.ts
.gitignore
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/simulation/components/CropInfoPanel.tsx">
import React from 'react';
import { Crop } from '@/types/farm';

interface CropInfoPanelProps {
    crop: Crop | null;
    environmentalData: any;
    currentDay: number;
    onApplyProduct: (cropId: string, productId: string) => void;
    onClose: () => void;
}

const CropInfoPanel: React.FC<CropInfoPanelProps> = ({
    crop,
    environmentalData,
    currentDay,
    onApplyProduct,
    onClose
}) => {
    if (!crop) return null;

    // Get crop emoji based on type
    const getCropEmoji = (cropType: string) => {
        const cropEmojis: Record<string, string> = {
            rice: 'üåæ',
            wheat: 'üåæ',
            corn: 'üåΩ',
            soybean: 'üå±',
            cotton: 'üß∂',
            vegetable: 'ü•¶',
            fruit: 'üçé'
        };

        return cropEmojis[cropType] || 'üå±';
    };

    // Calculate growth stage based on current day (0-100)
    const getGrowthStage = (day: number) => {
        const dayPercentage = Math.min(100, (day / 100) * 100);

        if (dayPercentage < 20) return 'Seedling';
        if (dayPercentage < 60) return 'Growing';
        if (dayPercentage < 90) return 'Mature';
        return 'Ready for Harvest';
    };

    // Generate health metrics (simplified)
    const getHealthMetrics = () => {
        // In a real application, these would be calculated based on the simulation
        return {
            water: Math.random() * 100,
            nutrient: Math.random() * 100,
            pest: Math.random() * 100
        };
    };

    // Generate recommendations based on health metrics
    const getRecommendations = () => {
        // This would be more sophisticated in a real application
        const metrics = getHealthMetrics();

        const recommendations = [];

        if (metrics.water < 50) {
            recommendations.push({
                type: 'water',
                product: 'stress-buster',
                icon: 'üíß',
                label: 'Water Stress Relief',
                color: 'bg-blue-100 border-blue-300'
            });
        }

        if (metrics.nutrient < 60) {
            recommendations.push({
                type: 'nutrient',
                product: 'nue-product',
                icon: 'üåø',
                label: 'Nutrient Booster',
                color: 'bg-green-100 border-green-300'
            });
        }

        if (metrics.pest < 70) {
            recommendations.push({
                type: 'pest',
                product: 'biocontrol',
                icon: 'üõ°Ô∏è',
                label: 'Pest Protection',
                color: 'bg-yellow-100 border-yellow-300'
            });
        }

        if (recommendations.length === 0) {
            recommendations.push({
                type: 'good',
                icon: 'üëç',
                label: 'No Action Needed',
                color: 'bg-gray-100 border-gray-300'
            });
        }

        return recommendations;
    };

    const healthMetrics = getHealthMetrics();
    const growthStage = getGrowthStage(currentDay);
    const recommendations = getRecommendations();

    // Calculate estimated yield
    const estimatedYield = (3 + Math.random() * 2).toFixed(1);
    const totalYield = (crop.acreage * parseFloat(estimatedYield)).toFixed(1);

    // Get health indicator color
    const getHealthColor = (value: number) => {
        if (value >= 75) return 'bg-green-500';
        if (value >= 50) return 'bg-yellow-500';
        return 'bg-red-500';
    };

    return (
        <div className="absolute top-0 left-0 w-full h-full flex items-center justify-center z-10 pointer-events-none">
            <div className="max-w-sm w-full bg-white bg-opacity-95 backdrop-blur-md rounded-xl shadow-xl p-4 m-4 pointer-events-auto">
                <div className="flex justify-between items-center mb-4">
                    <div className="flex items-center gap-3">
                        <div className="text-4xl">{getCropEmoji(crop.type)}</div>
                        <div>
                            <h3 className="text-xl font-bold">{crop.name}</h3>
                            <p className="text-sm text-gray-600 capitalize">{crop.type} ({crop.acreage} acres)</p>
                        </div>
                    </div>
                    <button
                        onClick={onClose}
                        className="w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 hover:bg-gray-300"
                        aria-label="Close details"
                    >
                        ‚úï
                    </button>
                </div>

                {/* Growth Stage Visualization */}
                <div className="bg-gray-100 rounded-lg p-3 mb-4">
                    <div className="flex justify-between items-center mb-2">
                        <div className="text-sm font-medium">Growth Stage</div>
                        <div className="text-sm font-bold">{growthStage}</div>
                    </div>

                    <div className="relative h-8 mb-1">
                        <div className="absolute inset-0 flex">
                            <div className="flex-1 flex items-center justify-center text-xs text-gray-500 border-r border-gray-300">Planting</div>
                            <div className="flex-1 flex items-center justify-center text-xs text-gray-500 border-r border-gray-300">Growing</div>
                            <div className="flex-1 flex items-center justify-center text-xs text-gray-500 border-r border-gray-300">Mature</div>
                            <div className="flex-1 flex items-center justify-center text-xs text-gray-500">Harvest</div>
                        </div>
                    </div>

                    <div className="w-full bg-gray-200 rounded-full h-2 mb-1">
                        <div
                            className="bg-green-500 h-2 rounded-full"
                            style={{ width: `${Math.min(100, (currentDay / 100) * 100)}%` }}
                        ></div>
                    </div>

                    <div className="text-center text-xs text-gray-500">Day {currentDay}</div>
                </div>

                {/* Health Visualizations */}
                <div className="grid grid-cols-3 gap-2 mb-4">
                    <div className="bg-gray-100 rounded-lg p-2 text-center">
                        <div className="text-lg">üíß</div>
                        <div className="w-full bg-gray-200 rounded-full h-1.5 my-1">
                            <div
                                className={`${getHealthColor(healthMetrics.water)} h-1.5 rounded-full`}
                                style={{ width: `${healthMetrics.water}%` }}
                            ></div>
                        </div>
                        <div className="text-xs">Water</div>
                    </div>

                    <div className="bg-gray-100 rounded-lg p-2 text-center">
                        <div className="text-lg">üåø</div>
                        <div className="w-full bg-gray-200 rounded-full h-1.5 my-1">
                            <div
                                className={`${getHealthColor(healthMetrics.nutrient)} h-1.5 rounded-full`}
                                style={{ width: `${healthMetrics.nutrient}%` }}
                            ></div>
                        </div>
                        <div className="text-xs">Nutrients</div>
                    </div>

                    <div className="bg-gray-100 rounded-lg p-2 text-center">
                        <div className="text-lg">üõ°Ô∏è</div>
                        <div className="w-full bg-gray-200 rounded-full h-1.5 my-1">
                            <div
                                className={`${getHealthColor(healthMetrics.pest)} h-1.5 rounded-full`}
                                style={{ width: `${healthMetrics.pest}%` }}
                            ></div>
                        </div>
                        <div className="text-xs">Protection</div>
                    </div>
                </div>

                {/* Yield Prediction */}
                <div className="bg-green-50 rounded-lg p-3 mb-4 flex justify-between items-center">
                    <div>
                        <div className="text-sm font-medium">Expected Yield</div>
                        <div className="text-xs text-gray-600">Per acre</div>
                    </div>
                    <div className="text-right">
                        <div className="text-xl font-bold text-green-700">{estimatedYield} tons</div>
                        <div className="text-xs text-gray-600">Total: {totalYield} tons</div>
                    </div>
                </div>

                {/* Recommended Actions */}
                <div className="mb-2">
                    <div className="text-sm font-medium mb-2">Recommended Actions</div>
                    <div className="space-y-2">
                        {recommendations.map((rec, index) => (
                            <div
                                key={`rec-${index}`}
                                className={`rounded-lg p-3 border flex items-center gap-3 ${rec.color}`}
                            >
                                <div className="text-2xl">{rec.icon}</div>
                                <div className="flex-grow">
                                    <div className="font-medium text-sm">{rec.label}</div>
                                </div>
                                {rec.product && (
                                    <button
                                        onClick={() => onApplyProduct(crop.id, rec.product)}
                                        className="bg-white px-3 py-1 rounded-full text-sm font-medium shadow-sm hover:bg-gray-100"
                                    >
                                        Apply
                                    </button>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default CropInfoPanel;
</file>

<file path="app/simulation/components/FarmGameView.tsx">
import React, { useState, useEffect } from 'react';
import { Crop, FarmData, GeoLocation } from '@/types/farm';

interface FarmGameViewProps {
  farmData: FarmData;
  currentDay: number;
  weatherData: any;
  onCropSelect: (cropId: string) => void;
}

const FarmGameView: React.FC<FarmGameViewProps> = ({ 
  farmData, 
  currentDay, 
  weatherData,
  onCropSelect 
}) => {
  const [gridSize, setGridSize] = useState({ width: 12, height: 10 });
  const [hoveredCrop, setHoveredCrop] = useState<string | null>(null);
  
  // Calculate grid cell size based on container size
  useEffect(() => {
    const calculateGridSize = () => {
      // Adjust grid size based on number of crops
      const cropCount = farmData.crops.length;
      if (cropCount <= 2) {
        setGridSize({ width: 8, height: 6 });
      } else if (cropCount <= 4) {
        setGridSize({ width: 10, height: 8 });
      } else {
        setGridSize({ width: 12, height: 10 });
      }
    };
    
    calculateGridSize();
  }, [farmData.crops]);

  // Position crops on the grid
  const positionCrops = () => {
    const positions: Record<string, { x: number, y: number, width: number, height: number }> = {};
    
    // Simple algorithm to position crops based on their acreage
    let x = 0;
    let y = 0;
    let rowHeight = 0;
    
    farmData.crops.forEach(crop => {
      // Scale crop size based on acreage
      const relativeSize = Math.max(1, Math.round((crop.acreage / farmData.totalAcreage) * 15));
      const width = relativeSize;
      const height = relativeSize;
      
      // Check if we need to move to a new row
      if (x + width > gridSize.width) {
        x = 0;
        y += rowHeight;
        rowHeight = 0;
      }
      
      positions[crop.id] = { x, y, width, height };
      
      // Update coordinates for next crop
      x += width;
      rowHeight = Math.max(rowHeight, height);
    });
    
    return positions;
  };
  
  // Calculate crop positions
  const cropPositions = positionCrops();
  
  // Determine growth stage based on current day (0-100)
  const getGrowthStage = (cropType: string, day: number) => {
    // Simplified growth stages: seedling, growing, mature, harvesting
    const dayPercentage = Math.min(100, (day / 100) * 100);
    
    if (dayPercentage < 20) return 'seedling';
    if (dayPercentage < 60) return 'growing';
    if (dayPercentage < 90) return 'mature';
    return 'harvesting';
  };
  
  // Get crop emoji based on type and growth stage
  const getCropEmoji = (crop: Crop) => {
    const stage = getGrowthStage(crop.type, currentDay);
    
    const cropEmojis: Record<string, Record<string, string>> = {
      rice: {
        seedling: 'üå±',
        growing: 'üåø',
        mature: 'üåæ',
        harvesting: 'üåæ'
      },
      wheat: {
        seedling: 'üå±',
        growing: 'üåø',
        mature: 'üåæ',
        harvesting: 'üåæ'
      },
      corn: {
        seedling: 'üå±',
        growing: 'üåø',
        mature: 'üåΩ',
        harvesting: 'üåΩ'
      },
      soybean: {
        seedling: 'üå±',
        growing: 'üåø',
        mature: 'üå±',
        harvesting: 'üå±'
      },
      cotton: {
        seedling: 'üå±',
        growing: 'üåø',
        mature: 'üå∏',
        harvesting: 'üß∂'
      },
      vegetable: {
        seedling: 'üå±',
        growing: 'üåø',
        mature: 'ü•¶',
        harvesting: 'ü•¶'
      },
      fruit: {
        seedling: 'üå±',
        growing: 'üåø',
        mature: 'üå≥',
        harvesting: 'üçé'
      }
    };
    
    return cropEmojis[crop.type]?.[stage] || 'üå±';
  };
  
  // Calculate crop size scaling based on growth stage
  const getCropSize = (crop: Crop) => {
    const stage = getGrowthStage(crop.type, currentDay);
    
    const scaleFactors = {
      seedling: 0.6,
      growing: 0.8,
      mature: 1,
      harvesting: 1
    };
    
    return scaleFactors[stage as keyof typeof scaleFactors] || 1;
  };
  
  // Get weather effect elements
  const getWeatherEffects = () => {
    if (!weatherData || !weatherData.forecast) return null;
    
    const currentWeather = weatherData.forecast.daily[Math.min(
      weatherData.forecast.daily.length - 1, 
      Math.floor(currentDay / 7)
    )];
    
    const raindrops = [];
    
    if (currentWeather.precipitation > 3) {
      const dropCount = Math.min(50, Math.round(currentWeather.precipitation * 3));
      
      for (let i = 0; i < dropCount; i++) {
        const x = Math.random() * 100;
        const y = Math.random() * 100;
        const delay = Math.random() * 5;
        
        raindrops.push(
          <div 
            key={`drop-${i}`} 
            className="absolute bg-blue-400 rounded-full opacity-70"
            style={{
              width: '2px',
              height: '8px',
              left: `${x}%`,
              top: `${y}%`,
              animation: `fall 1.5s infinite ${delay}s`,
            }}
          />
        );
      }
    }
    
    return (
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        {raindrops}
      </div>
    );
  };
  
  // Determine crop health based on environmental factors
  const getCropHealthStatus = (crop: Crop) => {
    // This would ideally be calculated from the simulation logic
    // For now, we'll return a simple random state
    const states = ['healthy', 'stressed', 'unhealthy'];
    return states[Math.floor(Math.random() * 3)];
  };
  
  // Get crop health color
  const getHealthColor = (status: string) => {
    switch (status) {
      case 'healthy': return 'bg-green-100 border-green-500';
      case 'stressed': return 'bg-yellow-100 border-yellow-500';
      case 'unhealthy': return 'bg-red-100 border-red-500';
      default: return 'bg-green-100 border-green-500';
    }
  };

  return (
    <div className="relative w-full h-96 bg-green-200 rounded-lg overflow-hidden border-2 border-green-600">
      {/* Sky */}
      <div className="absolute inset-0 bg-gradient-to-b from-blue-300 to-blue-100"></div>
      
      {/* Weather effects */}
      {getWeatherEffects()}
      
      {/* Ground */}
      <div className="absolute inset-x-0 bottom-0 h-3/4 bg-green-300 border-t-2 border-green-400">
        {/* Soil texture */}
        <div className="absolute inset-0 opacity-20">
          {Array(20).fill(0).map((_, i) => (
            <div 
              key={`soil-${i}`} 
              className="absolute bg-green-800 rounded-full"
              style={{
                width: `${Math.random() * 5 + 2}px`,
                height: `${Math.random() * 5 + 2}px`,
                left: `${Math.random() * 100}%`,
                top: `${Math.random() * 100}%`,
              }}
            />
          ))}
        </div>
      </div>
      
      {/* Farm grid */}
      <div className="absolute inset-0 flex items-center justify-center">
        <div 
          className="relative"
          style={{ 
            width: `${gridSize.width * 40}px`, 
            height: `${gridSize.height * 40}px` 
          }}
        >
          {/* Render crops */}
          {farmData.crops.map(crop => {
            const position = cropPositions[crop.id];
            const healthStatus = getCropHealthStatus(crop);
            
            if (!position) return null;
            
            return (
              <div
                key={crop.id}
                className={`absolute border-2 rounded-md cursor-pointer transition-all transform ${getHealthColor(healthStatus)}`}
                style={{
                  left: `${position.x * 40}px`,
                  top: `${position.y * 40}px`,
                  width: `${position.width * 40}px`,
                  height: `${position.height * 40}px`,
                  zIndex: hoveredCrop === crop.id ? 10 : 1,
                  transform: hoveredCrop === crop.id ? 'scale(1.05)' : 'scale(1)',
                }}
                onClick={() => onCropSelect(crop.id)}
                onMouseEnter={() => setHoveredCrop(crop.id)}
                onMouseLeave={() => setHoveredCrop(null)}
              >
                <div className="absolute inset-0 flex flex-col items-center justify-center">
                  <div className="text-3xl" style={{ fontSize: `${2 * getCropSize(crop)}rem` }}>
                    {getCropEmoji(crop)}
                  </div>
                  <div className="text-xs font-bold mt-1 bg-white bg-opacity-75 px-1 rounded">
                    {crop.name}
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
      
      {/* Info box for hovered crop */}
      {hoveredCrop && (
        <div className="absolute bottom-2 right-2 bg-white p-2 rounded shadow-md max-w-xs">
          <div className="font-bold">
            {farmData.crops.find(c => c.id === hoveredCrop)?.name}
          </div>
          <div className="text-sm">
            Click to view details and recommendations
          </div>
        </div>
      )}
      
      {/* Farm name overlay */}
      <div className="absolute top-2 left-2 bg-white bg-opacity-75 p-2 rounded shadow">
        <div className="font-bold">{farmData.name}</div>
        <div className="text-xs text-gray-600">Day {currentDay}</div>
      </div>
    </div>
  );
};

export default FarmGameView;
</file>

<file path="app/simulation/components/ProductSelector.tsx">
import React, { useState } from 'react';
import { Crop } from '@/types/farm';

interface Product {
    id: string;
    name: string;
    type: string;
    description: string;
    icon: string;
    color: string;
}

interface ProductSelectorProps {
    crop: Crop;
    onApply: (productId: string) => void;
    onCancel: () => void;
}

const ProductSelector: React.FC<ProductSelectorProps> = ({
    crop,
    onApply,
    onCancel
}) => {
    const [selectedProduct, setSelectedProduct] = useState<string | null>(null);

    // Mock products
    const products: Product[] = [
        {
            id: 'stress-buster',
            name: 'Stress Buster',
            type: 'Biostimulant',
            description: 'Helps plants overcome environmental stress',
            icon: 'üíß',
            color: 'bg-blue-100 border-blue-300'
        },
        {
            id: 'yield-booster',
            name: 'Yield Booster',
            type: 'Biostimulant',
            description: 'Increases plant productivity and yield',
            icon: 'üå±',
            color: 'bg-green-100 border-green-300'
        },
        {
            id: 'nue-product',
            name: 'NUE Product',
            type: 'Biofertilizer',
            description: 'Improves nutrient uptake efficiency',
            icon: 'üåø',
            color: 'bg-green-100 border-green-300'
        }
    ];

    return (
        <div className="absolute top-0 left-0 w-full h-full flex items-center justify-center z-10 pointer-events-none">
            <div className="max-w-sm w-full bg-white bg-opacity-95 backdrop-blur-md rounded-xl shadow-xl p-4 m-4 pointer-events-auto">
                <div className="flex justify-between items-center mb-4">
                    <h3 className="text-xl font-bold">Apply Product to {crop.name}</h3>
                    <button
                        onClick={onCancel}
                        className="w-8 h-8 flex items-center justify-center rounded-full bg-gray-200 hover:bg-gray-300"
                        aria-label="Close selector"
                    >
                        ‚úï
                    </button>
                </div>

                <div className="space-y-3 mb-4">
                    {products.map(product => (
                        <div
                            key={product.id}
                            className={`p-3 rounded-lg border cursor-pointer transition-all ${selectedProduct === product.id
                                    ? `${product.color} ring-2 ring-green-500`
                                    : `${product.color} hover:ring-1 hover:ring-gray-300`
                                }`}
                            onClick={() => setSelectedProduct(product.id)}
                        >
                            <div className="flex items-center gap-3">
                                <div className="text-3xl">{product.icon}</div>
                                <div className="flex-grow">
                                    <div className="font-medium">{product.name}</div>
                                    <div className="text-xs text-gray-600">{product.type}</div>
                                    <div className="text-sm mt-1">{product.description}</div>
                                </div>
                                {selectedProduct === product.id && (
                                    <div className="text-green-500 text-xl">‚úì</div>
                                )}
                            </div>
                        </div>
                    ))}
                </div>

                <div className="flex justify-end gap-2">
                    <button
                        onClick={onCancel}
                        className="px-4 py-2 rounded-lg bg-gray-200 hover:bg-gray-300 font-medium"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={() => selectedProduct && onApply(selectedProduct)}
                        disabled={!selectedProduct}
                        className={`px-4 py-2 rounded-lg font-medium ${selectedProduct
                                ? 'bg-green-500 text-white hover:bg-green-600'
                                : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                            }`}
                    >
                        Apply Product
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ProductSelector;
</file>

<file path="app/simulation/components/ResultsPanel.tsx">
// app/simulation/components/ResultsPanel.tsx

import React from 'react';
import { Card } from '@/components/ui/Card';
import { Crop } from '@/types/farm';
import { CropYieldEstimate } from '@/types/simulation';

interface ResultsPanelProps {
    crops: Crop[];
    yieldEstimates: Record<string, any>;
    selectedProducts: Record<string, string[]>;
    onCropSelect: (cropId: string) => void;
    currentDay: number;
}

const ResultsPanel: React.FC<ResultsPanelProps> = ({
    crops,
    yieldEstimates,
    selectedProducts,
    onCropSelect,
    currentDay
}) => {
    // Calculate total yield across all crops
    const totalYield = Object.values(yieldEstimates).reduce((sum, est) => {
        return sum + (est.totalEstimatedYield || 0);
    }, 0);

    // Calculate total yield improvement from products
    const totalImprovement = Object.values(yieldEstimates).reduce((sum, est: any) => {
        return sum + ((est.productEffect || 0) * est.totalEstimatedYield || 0);
    }, 0);

    // Determine overall farm health
    const determineOverallHealth = () => {
        let totalStress = 0;
        let cropCount = 0;

        crops.forEach(crop => {
            const estimate = yieldEstimates[crop.id];
            if (estimate?.stressFactors) {
                totalStress += (
                    estimate.stressFactors.temperature +
                    estimate.stressFactors.water +
                    estimate.stressFactors.soil
                ) / 3;
                cropCount++;
            }
        });

        const avgStress = cropCount > 0 ? totalStress / cropCount : 0;

        if (avgStress > 0.6) return { status: 'Needs Attention', color: 'text-red-600', icon: '‚ö†Ô∏è' };
        if (avgStress > 0.3) return { status: 'Fair', color: 'text-yellow-600', icon: '‚öñÔ∏è' };
        return { status: 'Healthy', color: 'text-green-600', icon: '‚úÖ' };
    };

    const overallHealth = determineOverallHealth();

    // Calculate growth stage based on current day (0-100%)
    const getGrowthStage = () => {
        const percentage = Math.min(100, (currentDay / 100) * 100);

        if (percentage < 20) return { stage: 'Planting Season', icon: 'üå±' };
        if (percentage < 40) return { stage: 'Growth Stage', icon: 'üåø' };
        if (percentage < 70) return { stage: 'Flowering Stage', icon: 'üå∏' };
        if (percentage < 90) return { stage: 'Development Stage', icon: 'üåæ' };
        return { stage: 'Harvest Season', icon: 'üåΩ' };
    };

    const growthStage = getGrowthStage();

    return (
        <Card className="p-4">
            <h2 className="text-xl font-bold mb-4">Simulation Results</h2>

            <div className="space-y-4">
                {/* Current stage indicator */}
                <div className="bg-blue-50 p-4 rounded-lg flex items-center">
                    <div className="text-2xl mr-3">{growthStage.icon}</div>
                    <div>
                        <h3 className="font-medium">{growthStage.stage}</h3>
                        <div className="text-sm text-gray-600">Day {Math.floor(currentDay)} of 100</div>
                    </div>
                </div>

                {/* Overall farm health */}
                <div className={`bg-opacity-20 p-4 rounded-lg flex items-center ${overallHealth.color === 'text-green-600' ? 'bg-green-100' :
                        overallHealth.color === 'text-yellow-600' ? 'bg-yellow-100' : 'bg-red-100'
                    }`}>
                    <div className="text-2xl mr-3">{overallHealth.icon}</div>
                    <div>
                        <h3 className="font-medium">Farm Health: {overallHealth.status}</h3>
                        <div className="text-sm text-gray-600">
                            {overallHealth.status === 'Healthy' ?
                                'Your crops are thriving!' :
                                overallHealth.status === 'Fair' ?
                                    'Some crops may need attention' :
                                    'Action recommended for optimal yields'}
                        </div>
                    </div>
                </div>

                {/* Yield summary */}
                <div className="bg-green-50 p-4 rounded-lg">
                    <h3 className="font-medium mb-2">Estimated Yield</h3>
                    <div className="text-2xl font-bold text-green-700 mb-1">
                        {totalYield.toFixed(1)} tons
                    </div>

                    {totalImprovement > 0 && (
                        <div className="flex items-center text-green-600">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M12 7a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0V8.414l-4.293 4.293a1 1 0 01-1.414 0L8 10.414l-4.293 4.293a1 1 0 01-1.414-1.414l5-5a1 1 0 011.414 0L11 10.586 14.586 7H12z" clipRule="evenodd" />
                            </svg>
                            <span>+{totalImprovement.toFixed(1)} tons with bio-products</span>
                        </div>
                    )}
                </div>

                {/* Crop-specific results */}
                <div>
                    <h3 className="font-medium mb-2">Crop Performance</h3>
                    <div className="space-y-3 max-h-64 overflow-y-auto">
                        {crops.map(crop => {
                            const estimate = yieldEstimates[crop.id];
                            if (!estimate) return null;

                            // Determine crop health status
                            let healthStatus = "Good";
                            let healthColor = "text-green-600";
                            let healthIcon = "‚úì";

                            if (estimate.stressFactors) {
                                const avgStress = (
                                    estimate.stressFactors.temperature +
                                    estimate.stressFactors.water +
                                    estimate.stressFactors.soil
                                ) / 3;

                                if (avgStress > 0.6) {
                                    healthStatus = "Poor";
                                    healthColor = "text-red-600";
                                    healthIcon = "‚ö†Ô∏è";
                                } else if (avgStress > 0.3) {
                                    healthStatus = "Fair";
                                    healthColor = "text-yellow-600";
                                    healthIcon = "‚öñÔ∏è";
                                }
                            }

                            // Get crop emoji based on type
                            const getCropEmoji = (cropType: string) => {
                                const cropEmojis: Record<string, string> = {
                                    rice: 'üåæ',
                                    wheat: 'üåæ',
                                    corn: 'üåΩ',
                                    soybean: 'üå±',
                                    cotton: 'üß∂',
                                    vegetable: 'ü•¶',
                                    fruit: 'üçé'
                                };

                                return cropEmojis[cropType] || 'üå±';
                            };

                            return (
                                <div
                                    key={crop.id}
                                    className="p-3 border rounded-lg hover:bg-gray-50 cursor-pointer"
                                    onClick={() => onCropSelect(crop.id)}
                                >
                                    <div className="flex justify-between items-center">
                                        <div className="flex items-center font-medium">
                                            <span className="mr-2">{getCropEmoji(crop.type)}</span>
                                            {crop.name}
                                        </div>
                                        <div className={`${healthColor} font-medium`}>
                                            {healthIcon} {healthStatus}
                                        </div>
                                    </div>
                                    <div className="text-sm text-gray-600">
                                        {estimate.estimatedYield.toFixed(1)} tons/acre
                                        {" √ó "}{crop.acreage} acres = {estimate.totalEstimatedYield.toFixed(1)} tons
                                    </div>

                                    {/* Applied products */}
                                    {selectedProducts[crop.id]?.length > 0 && (
                                        <div className="mt-2 flex items-center">
                                            <span className="text-xs bg-green-100 text-green-800 px-2 py-1 rounded-full mr-2">
                                                {selectedProducts[crop.id].length} bio-products applied
                                            </span>
                                            {estimate.productEffect && (
                                                <span className="text-xs text-green-600">
                                                    +{(estimate.productEffect * 100).toFixed(0)}% yield
                                                </span>
                                            )}
                                        </div>
                                    )}

                                    {/* Quick recommendations */}
                                    {healthStatus !== "Good" && (
                                        <div className="mt-2 text-xs">
                                            <span className="font-medium">Tip:</span> Click to view recommendations
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </div>
                </div>
            </div>
        </Card>
    );
};

export default ResultsPanel;
</file>

<file path="app/simulation/components/SimulationControls.tsx">
import React from 'react';

interface SimulationControlsProps {
    currentDay: number;
    totalDays: number;
    isPlaying: boolean;
    playbackSpeed: number;
    onDayChange: (day: number) => void;
    onPlayToggle: () => void;
    onSpeedChange: (speed: number) => void;
    onReset: () => void;
}

const SimulationControls: React.FC<SimulationControlsProps> = ({
    currentDay,
    totalDays,
    isPlaying,
    playbackSpeed,
    onDayChange,
    onPlayToggle,
    onSpeedChange,
    onReset
}) => {
    // Convert day to season text and color
    const getSeasonInfo = (day: number) => {
        const percentage = (day / totalDays) * 100;

        if (percentage < 15) {
            return {
                text: 'Planting Season',
                color: 'bg-green-200',
                icon: 'üå±'
            };
        }
        if (percentage < 40) {
            return {
                text: 'Growth Stage',
                color: 'bg-green-300',
                icon: 'üåø'
            };
        }
        if (percentage < 70) {
            return {
                text: 'Flowering Stage',
                color: 'bg-green-400',
                icon: 'üå∏'
            };
        }
        if (percentage < 90) {
            return {
                text: 'Development Stage',
                color: 'bg-yellow-300',
                icon: 'üåæ'
            };
        }
        return {
            text: 'Harvest Season',
            color: 'bg-yellow-500',
            icon: 'üåΩ'
        };
    };

    const seasonInfo = getSeasonInfo(currentDay);

    return (
        <div className="w-full bg-white bg-opacity-90 backdrop-blur-sm rounded-lg shadow-lg p-4 mt-4">
            <div className="flex items-center justify-between mb-4">
                <div className="flex items-center">
                    <span className="text-2xl mr-2">{seasonInfo.icon}</span>
                    <div>
                        <h3 className="font-bold text-lg">{seasonInfo.text}</h3>
                        <div className="text-sm text-gray-600">Day {currentDay} of {totalDays}</div>
                    </div>
                </div>

                {/* Growing progress */}
                <div className="bg-gray-200 h-4 rounded-full w-32 overflow-hidden">
                    <div
                        className={`h-full ${seasonInfo.color} transition-all duration-300`}
                        style={{ width: `${(currentDay / totalDays) * 100}%` }}
                    ></div>
                </div>
            </div>

            <div className="flex items-center gap-3">
                {/* Timeline slider */}
                <input
                    type="range"
                    min="0"
                    max={totalDays}
                    value={currentDay}
                    onChange={(e) => onDayChange(parseInt(e.target.value))}
                    className="flex-grow h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    aria-label="Growth timeline"
                />

                {/* Play/Pause button */}
                <button
                    onClick={onPlayToggle}
                    className={`w-12 h-12 flex items-center justify-center rounded-full text-white ${isPlaying ? 'bg-green-600' : 'bg-green-500 hover:bg-green-600'}`}
                    aria-label={isPlaying ? "Pause" : "Play"}
                >
                    <span className="text-2xl">{isPlaying ? "‚è∏" : "‚ñ∂"}</span>
                </button>

                {/* Speed buttons */}
                <div className="flex space-x-1">
                    {[1, 2, 5].map((speed) => (
                        <button
                            key={`speed-${speed}`}
                            className={`w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium ${playbackSpeed === speed
                                    ? 'bg-green-500 text-white'
                                    : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                }`}
                            onClick={() => onSpeedChange(speed)}
                            aria-label={`${speed}x speed`}
                        >
                            {speed}x
                        </button>
                    ))}
                </div>

                {/* Reset button */}
                <button
                    onClick={onReset}
                    className="w-8 h-8 rounded-full flex items-center justify-center bg-gray-200 text-gray-700 hover:bg-gray-300"
                    aria-label="Reset simulation"
                >
                    <span className="text-sm">‚Ü∫</span>
                </button>
            </div>
        </div>
    );
};

export default SimulationControls;
</file>

<file path="app/simulation/components/ThreeFarmScene.tsx">
import React, { useRef, useEffect, useState } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { FarmData, Crop } from '@/types/farm';

interface ThreeFarmSceneProps {
  farmData: FarmData;
  currentDay: number;
  weatherData: any;
  onCropSelect: (cropId: string) => void;
}

const ThreeFarmScene: React.FC<ThreeFarmSceneProps> = ({
  farmData,
  currentDay,
  weatherData,
  onCropSelect
}) => {
  const mountRef = useRef<HTMLDivElement>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const controlsRef = useRef<OrbitControls | null>(null);
  const cropObjectsRef = useRef<Map<string, THREE.Object3D>>(new Map());
  const raycasterRef = useRef<THREE.Raycaster>(new THREE.Raycaster());
  const mouseRef = useRef<THREE.Vector2>(new THREE.Vector2());
  const frameIdRef = useRef<number>(0);
  const [hoveredCropId, setHoveredCropId] = useState<string | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  // Setup Three.js scene
  useEffect(() => {
    if (!mountRef.current || isInitialized) return;

    // Initialize three.js
    const width = mountRef.current.clientWidth;
    const height = mountRef.current.clientHeight;

    // Create scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue
    sceneRef.current = scene;

    // Create camera
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, 15, 30);
    cameraRef.current = camera;

    // Create renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    mountRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // Add orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.maxPolarAngle = Math.PI / 2 - 0.1; // Prevent seeing below ground
    controlsRef.current = controls;

    // Create lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(10, 20, 10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Create ground
    const groundGeometry = new THREE.PlaneGeometry(50, 50);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x7cbc30, // Green
      roughness: 0.8, 
      metalness: 0.2 
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    scene.add(ground);

    // Animation loop
    const animate = () => {
      frameIdRef.current = requestAnimationFrame(animate);
      
      // Update controls
      if (controlsRef.current) {
        controlsRef.current.update();
      }
      
      // Update animations based on time
      const time = Date.now() * 0.001;
      cropObjectsRef.current.forEach((object, cropId) => {
        // Simple swaying animation for plants
        if (object.userData.type === 'crop') {
          const crop = object.userData.cropData as Crop;
          const growthStage = getGrowthStage(crop.type, currentDay);
          
          // Apply different animations based on growth stage
          if (growthStage !== 'seedling') {
            // Gentle swaying for plants
            const swayAmount = growthStage === 'harvesting' ? 0.01 : 0.03;
            object.rotation.z = Math.sin(time + object.position.x * 0.5) * swayAmount;
            object.rotation.x = Math.sin(time + object.position.z * 0.5) * swayAmount;
          }
          
          // Scale based on growth
          const baseScale = object.userData.baseScale || { x: 1, y: 1, z: 1 };
          const growthFactor = getGrowthFactor(crop.type, currentDay);
          object.scale.set(
            baseScale.x * growthFactor,
            baseScale.y * growthFactor,
            baseScale.z * growthFactor
          );
          
          // Highlight if hovered
          if (cropId === hoveredCropId) {
            object.scale.multiplyScalar(1.05);
          }
        }
      });
      
      // Render scene
      if (rendererRef.current && sceneRef.current && cameraRef.current) {
        rendererRef.current.render(sceneRef.current, cameraRef.current);
      }
    };

    animate();
    setIsInitialized(true);

    // Cleanup function
    return () => {
      cancelAnimationFrame(frameIdRef.current);
      if (rendererRef.current && mountRef.current) {
        mountRef.current.removeChild(rendererRef.current.domElement);
      }
      scene.clear();
      rendererRef.current?.dispose();
    };
  }, [isInitialized]);

  // Handle window resize
  useEffect(() => {
    const handleResize = () => {
      if (!mountRef.current || !rendererRef.current || !cameraRef.current) return;
      
      const width = mountRef.current.clientWidth;
      const height = mountRef.current.clientHeight;
      
      cameraRef.current.aspect = width / height;
      cameraRef.current.updateProjectionMatrix();
      
      rendererRef.current.setSize(width, height);
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  // Create crops in the scene
  useEffect(() => {
    if (!sceneRef.current || !farmData.crops || farmData.crops.length === 0) return;

    // Clear previous crop objects
    cropObjectsRef.current.forEach((object) => {
      sceneRef.current?.remove(object);
    });
    cropObjectsRef.current.clear();

    // Layout parameters
    const fieldWidth = 40;
    const fieldDepth = 30;
    const layoutCrops = () => {
      const totalAcreage = farmData.totalAcreage;
      const rows = Math.ceil(Math.sqrt(farmData.crops.length));
      const cols = Math.ceil(farmData.crops.length / rows);
      
      let rowWidth = fieldWidth / rows;
      let colDepth = fieldDepth / cols;
      
      farmData.crops.forEach((crop, index) => {
        const row = Math.floor(index / cols);
        const col = index % cols;
        
        // Calculate plot size based on crop acreage
        const plotSize = (crop.acreage / totalAcreage) * (fieldWidth * fieldDepth);
        const plotWidth = Math.sqrt(plotSize);
        const plotDepth = plotSize / plotWidth;
        
        // Calculate position
        const x = -fieldWidth/2 + rowWidth * (row + 0.5);
        const z = -fieldDepth/2 + colDepth * (col + 0.5);
        
        // Create plot
        createCropPlot(crop, x, z, plotWidth, plotDepth);
      });
    };
    
    layoutCrops();
    
  }, [farmData, sceneRef.current]);

  // Create individual crop plots
  const createCropPlot = (crop: Crop, x: number, z: number, width: number, depth: number) => {
    if (!sceneRef.current) return;
    
    // Create plot ground
    const plotGeometry = new THREE.PlaneGeometry(width, depth);
    const plotMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x5d4037, // Brown soil
      roughness: 1.0, 
      metalness: 0.0
    });
    const plot = new THREE.Mesh(plotGeometry, plotMaterial);
    plot.rotation.x = -Math.PI / 2;
    plot.position.set(x, 0.01, z); // Slightly above ground to prevent z-fighting
    plot.receiveShadow = true;
    plot.userData = {
      type: 'plot',
      cropId: crop.id,
      cropData: crop
    };
    sceneRef.current.add(plot);
    
    // Create crop instances
    const plantCount = Math.min(20, Math.max(5, Math.round(crop.acreage * 2))); // Scale plant count with acreage
    const cropGroup = new THREE.Group();
    cropGroup.position.set(x, 0, z);
    cropGroup.userData = {
      type: 'crop',
      cropId: crop.id,
      cropData: crop,
      baseScale: { x: 1, y: 1, z: 1 }
    };
    
    // Create crop plants
    for (let i = 0; i < plantCount; i++) {
      const plant = createCropModel(crop);
      
      // Random position within plot
      const offsetX = (Math.random() - 0.5) * width * 0.8;
      const offsetZ = (Math.random() - 0.5) * depth * 0.8;
      plant.position.set(offsetX, 0, offsetZ);
      
      // Random rotation for variety
      plant.rotation.y = Math.random() * Math.PI * 2;
      
      cropGroup.add(plant);
    }
    
    // Add label
    const labelGeometry = new THREE.PlaneGeometry(1.5, 0.5);
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const context = canvas.getContext('2d');
    if (context) {
      context.fillStyle = 'rgba(255, 255, 255, 0.8)';
      context.fillRect(0, 0, 256, 64);
      context.fillStyle = 'black';
      context.font = 'bold 32px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(crop.name, 128, 32);
    }
    
    const labelTexture = new THREE.CanvasTexture(canvas);
    const labelMaterial = new THREE.MeshBasicMaterial({
      map: labelTexture,
      transparent: true,
      side: THREE.DoubleSide
    });
    
    const label = new THREE.Mesh(labelGeometry, labelMaterial);
    label.position.set(0, 2.5, 0);
    label.rotation.x = -Math.PI / 6; // Tilt for better visibility
    cropGroup.add(label);
    
    sceneRef.current.add(cropGroup);
    cropObjectsRef.current.set(crop.id, cropGroup);
  };

  // Create crop models based on type
  const createCropModel = (crop: Crop) => {
    // Create different geometries based on crop type
    let geometry: THREE.BufferGeometry;
    let material: THREE.Material;
    let cropModel: THREE.Object3D;
    
    switch(crop.type) {
      case 'corn':
        // Corn stalk - cylinder with leaves
        geometry = new THREE.CylinderGeometry(0.05, 0.07, 1.5, 8);
        material = new THREE.MeshStandardMaterial({ color: 0x2e7d32 }); // Dark green
        cropModel = new THREE.Mesh(geometry, material);
        cropModel.position.y = 0.75;
        
        // Corn cob
        const cobGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 8);
        const cobMaterial = new THREE.MeshStandardMaterial({ color: 0xffeb3b }); // Yellow
        const cob = new THREE.Mesh(cobGeometry, cobMaterial);
        cob.position.set(0.15, 0.2, 0);
        cob.rotation.z = Math.PI / 2;
        cropModel.add(cob);
        break;
        
      case 'wheat':
        // Wheat stalk
        geometry = new THREE.CylinderGeometry(0.02, 0.03, 1.2, 8);
        material = new THREE.MeshStandardMaterial({ color: 0xd4c07e }); // Wheat color
        cropModel = new THREE.Mesh(geometry, material);
        cropModel.position.y = 0.6;
        
        // Wheat head
        const headGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.3, 8);
        const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffedb6 }); // Light wheat
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 0.75;
        cropModel.add(head);
        break;
        
      case 'rice':
        // Rice stalks - thin cylinders
        geometry = new THREE.CylinderGeometry(0.02, 0.025, 1.0, 8);
        material = new THREE.MeshStandardMaterial({ color: 0x9ccc65 }); // Light green
        cropModel = new THREE.Mesh(geometry, material);
        cropModel.position.y = 0.5;
        
        // Rice head
        const riceHeadGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const riceHeadMaterial = new THREE.MeshStandardMaterial({ color: 0xf5f5f5 }); // White
        const riceHead = new THREE.Mesh(riceHeadGeometry, riceHeadMaterial);
        riceHead.position.y = 0.58;
        riceHead.scale.set(0.6, 1, 0.6);
        cropModel.add(riceHead);
        break;
        
      case 'soybean':
        // Soybean plant - bushy with small pods
        geometry = new THREE.SphereGeometry(0.3, 8, 8);
        material = new THREE.MeshStandardMaterial({ color: 0x33691e }); // Green
        cropModel = new THREE.Mesh(geometry, material);
        cropModel.position.y = 0.3;
        cropModel.scale.set(1, 0.8, 1);
        
        // Soybean pods
        for (let i = 0; i < 5; i++) {
          const podGeometry = new THREE.SphereGeometry(0.05, 8, 8);
          const podMaterial = new THREE.MeshStandardMaterial({ color: 0x8bc34a }); // Light green
          const pod = new THREE.Mesh(podGeometry, podMaterial);
          const angle = (i / 5) * Math.PI * 2;
          pod.position.set(
            Math.cos(angle) * 0.25,
            0.1 + Math.random() * 0.2,
            Math.sin(angle) * 0.25
          );
          cropModel.add(pod);
        }
        break;
        
      case 'cotton':
        // Cotton plant - bushy base
        geometry = new THREE.SphereGeometry(0.25, 8, 8);
        material = new THREE.MeshStandardMaterial({ color: 0x33691e }); // Green
        cropModel = new THREE.Mesh(geometry, material);
        cropModel.position.y = 0.25;
        cropModel.scale.set(1, 0.7, 1);
        
        // Cotton bolls
        for (let i = 0; i < 4; i++) {
          const bollGeometry = new THREE.SphereGeometry(0.08, 8, 8);
          const bollMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White
          const boll = new THREE.Mesh(bollGeometry, bollMaterial);
          const angle = (i / 4) * Math.PI * 2;
          boll.position.set(
            Math.cos(angle) * 0.2,
            0.2 + Math.random() * 0.1,
            Math.sin(angle) * 0.2
          );
          cropModel.add(boll);
        }
        break;
        
      case 'vegetable':
        // Generic vegetable plant - leafy
        geometry = new THREE.SphereGeometry(0.3, 8, 8);
        material = new THREE.MeshStandardMaterial({ color: 0x66bb6a }); // Mid green
        cropModel = new THREE.Mesh(geometry, material);
        cropModel.position.y = 0.2;
        cropModel.scale.set(1, 0.6, 1);
        break;
        
      case 'fruit':
        // Fruit tree
        const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1.0, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x795548 }); // Brown
        cropModel = new THREE.Mesh(trunkGeometry, trunkMaterial);
        cropModel.position.y = 0.5;
        
        // Tree canopy
        const canopyGeometry = new THREE.SphereGeometry(0.6, 8, 8);
        const canopyMaterial = new THREE.MeshStandardMaterial({ color: 0x2e7d32 }); // Dark green
        const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
        canopy.position.y = 1.2;
        cropModel.add(canopy);
        
        // Add some fruits
        for (let i = 0; i < 6; i++) {
          const fruitGeometry = new THREE.SphereGeometry(0.07, 8, 8);
          const fruitMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red
          const fruit = new THREE.Mesh(fruitGeometry, fruitMaterial);
          
          // Position fruits around the canopy
          const phi = Math.acos(-1 + (2 * i) / 6);
          const theta = Math.sqrt(6 * Math.PI) * phi;
          
          fruit.position.set(
            0.5 * Math.cos(theta) * Math.sin(phi),
            1.2 + 0.5 * Math.cos(phi),
            0.5 * Math.sin(theta) * Math.sin(phi)
          );
          
          cropModel.add(fruit);
        }
        break;
        
      default:
        // Default simple plant
        geometry = new THREE.ConeGeometry(0.2, 1.0, 8);
        material = new THREE.MeshStandardMaterial({ color: 0x4caf50 }); // Green
        cropModel = new THREE.Mesh(geometry, material);
        cropModel.position.y = 0.5;
    }
    
    // Add cast shadow
    cropModel.castShadow = true;
    cropModel.receiveShadow = true;
    
    // Create a group to hold the crop
    const group = new THREE.Group();
    group.add(cropModel);
    
    return group;
  };
  
  // Mouse interaction handlers
  const handleMouseMove = (event: React.MouseEvent) => {
    if (!mountRef.current || !cameraRef.current || !sceneRef.current) return;
    
    // Calculate mouse position in normalized device coordinates
    const rect = mountRef.current.getBoundingClientRect();
    mouseRef.current.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    // Raycast to detect hoverable objects
    raycasterRef.current.setFromCamera(mouseRef.current, cameraRef.current);
    const intersects = raycasterRef.current.intersectObjects(sceneRef.current.children, true);

    // Check if we're hovering over a crop
    let foundCropId: string | null = null;
    for (const intersect of intersects) {
      // Find the crop id by traversing up the object hierarchy
      let current: THREE.Object3D | null = intersect.object;
      while (current) {
        if (current.userData?.cropId) {
          foundCropId = current.userData.cropId;
          break;
        }
        current = current.parent;
      }
      if (foundCropId) break;
    }
    
    // Update hovered crop state
    setHoveredCropId(foundCropId);
    
    // Update cursor style
    if (foundCropId) {
      document.body.style.cursor = 'pointer';
    } else {
      document.body.style.cursor = 'default';
    }
  };

  const handleMouseClick = (event: React.MouseEvent) => {
    if (hoveredCropId) {
      onCropSelect(hoveredCropId);
    }
  };

  // Helper functions
  const getGrowthStage = (cropType: string, day: number) => {
    // Simplified growth stages: seedling, growing, mature, harvesting
    const dayPercentage = Math.min(100, (day / 100) * 100);
    
    if (dayPercentage < 20) return 'seedling';
    if (dayPercentage < 60) return 'growing';
    if (dayPercentage < 90) return 'mature';
    return 'harvesting';
  };
  
  const getGrowthFactor = (cropType: string, day: number) => {
    // Return a scale factor based on growth stage
    const stage = getGrowthStage(cropType, day);
    
    const growthFactors = {
      seedling: 0.3,
      growing: 0.6,
      mature: 0.9,
      harvesting: 1.0
    };
    
    return growthFactors[stage as keyof typeof growthFactors];
  };

  // Update existing crops based on current day
  useEffect(() => {
    // This will be handled by the animation loop
  }, [currentDay]);

  // Add weather effects based on current weather data
  useEffect(() => {
    if (!sceneRef.current || !weatherData || !weatherData.forecast) return;
    
    // Remove existing weather effects
    const existingEffects = sceneRef.current.children.filter(
      child => child.userData?.type === 'weather'
    );
    existingEffects.forEach(effect => sceneRef.current?.remove(effect));
    
    // Get current weather data
    const currentWeatherIndex = Math.min(
      weatherData.forecast.daily.length - 1,
      Math.floor(currentDay / 7)
    );
    const currentWeather = weatherData.forecast.daily[currentWeatherIndex];
    
    // Add weather effects based on conditions
    // Rain particles
    if (currentWeather.precipitation > 3) {
      const rainCount = Math.round(currentWeather.precipitation * 50);
      const rainGeometry = new THREE.BufferGeometry();
      const rainPositions = new Float32Array(rainCount * 3);
      const rainVelocities = new Float32Array(rainCount);
      
      for (let i = 0; i < rainCount; i++) {
        const i3 = i * 3;
        rainPositions[i3] = (Math.random() - 0.5) * 50; // x
        rainPositions[i3 + 1] = Math.random() * 20 + 10; // y
        rainPositions[i3 + 2] = (Math.random() - 0.5) * 50; // z
        rainVelocities[i] = 0.1 + Math.random() * 0.3; // Speed
      }
      
      rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
      
      const rainMaterial = new THREE.PointsMaterial({
        color: 0x99ccff,
        size: 0.1,
        transparent: true,
        opacity: 0.6
      });
      
      const rain = new THREE.Points(rainGeometry, rainMaterial);
      rain.userData = { type: 'weather', effect: 'rain', velocities: rainVelocities };
      sceneRef.current.add(rain);
    }
    
    // Clouds
    const cloudCount = 5 + Math.round(currentWeather.humidity / 10);
    for (let i = 0; i < cloudCount; i++) {
      const cloudGeometry = new THREE.SphereGeometry(2 + Math.random() * 3, 6, 6);
      const cloudMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.5 + Math.random() * 0.3
      });
      
      const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
      cloud.position.set(
        (Math.random() - 0.5) * 40,
        15 + Math.random() * 5,
        (Math.random() - 0.5) * 40
      );
      cloud.scale.set(1, 0.6, 1);
      cloud.userData = { 
        type: 'weather', 
        effect: 'cloud',
        speed: 0.01 + Math.random() * 0.02,
        direction: Math.random() * Math.PI * 2
      };
      
      sceneRef.current.add(cloud);
    }
  }, [weatherData, currentDay, sceneRef.current]);

  return (
    <div 
      ref={mountRef} 
      className="w-full h-[500px] rounded-lg overflow-hidden"
      onMouseMove={handleMouseMove}
      onClick={handleMouseClick}
    >
      {/* This div will be used to mount the Three.js scene */}
      {hoveredCropId && (
        <div className="absolute bottom-4 right-4 bg-white bg-opacity-80 p-2 rounded shadow-md">
          <p className="font-medium">
            {farmData.crops.find(c => c.id === hoveredCropId)?.name}
          </p>
          <p className="text-xs text-gray-600">Click to view details</p>
        </div>
      )}
    </div>
  );
};

export default ThreeFarmScene;
</file>

<file path="types/simulation.ts">
import { Crop } from './farm';
import { Product } from './products';

export interface SimulationState {
    // Timeline
    currentDay: number;
    totalDays: number;
    isPlaying: boolean;
    playbackSpeed: number;

    // Selections
    selectedCropId: string | null;
    selectedProducts: Record<string, string[]>; // Map of cropId -> productIds

    // Results
    yieldEstimates: Record<string, CropYieldEstimate>;
    environmentalData: EnvironmentalData | null;
}

export interface CropYieldEstimate {
    cropId: string;
    cropName: string;
    cropType: string;
    baseYieldPerAcre: number;
    estimatedYield: number;
    totalEstimatedYield: number;
    potentialImprovement: number;
    totalPotentialImprovement: number;
    productEffect?: number;
    stressFactors: {
        temperature: number;
        water: number;
        soil: number;
        overall: number;
    };
}

export interface EnvironmentalData {
    forecast?: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: {
        texture: string;
        properties: {
            bulkDensity: number;
            organicMatter: number;
            ph: number;
            waterHoldingCapacity: number;
            cationExchangeCapacity: number;
        };
    };
    stress_factors?: {
        current: {
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        };
        forecast: Array<{
            date: string;
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        }>;
    };
}

export interface SimulationAction {
    type: string;
    payload?: any;
}

// Simulation event types that can be tracked
export type SimulationEvent =
    | 'CROP_PLANTED'
    | 'PRODUCT_APPLIED'
    | 'STRESS_DETECTED'
    | 'HARVEST_READY'
    | 'WEATHER_CHANGE';

export interface SimulationEventData {
    type: SimulationEvent;
    day: number;
    cropId?: string;
    productId?: string;
    message: string;
    severity?: 'info' | 'warning' | 'success';
}
</file>

<file path="app/api/products/route.ts">
import { NextRequest, NextResponse } from 'next/server';

// Import mock products data
import mockProductsData from '@/lib/data/products.json';

export async function GET(request: NextRequest) {
    try {
        // In a real implementation, we would fetch from a database or external API
        // For this hackathon, we're using our mock data

        // Let's add a small delay to simulate API latency
        await new Promise(resolve => setTimeout(resolve, 300));

        return NextResponse.json(mockProductsData);
    } catch (error) {
        console.error('Error fetching products:', error);
        return NextResponse.json(
            { error: 'Failed to fetch products' },
            { status: 500 }
        );
    }
}
</file>

<file path="app/simulation/page.tsx">
"use client";

import React, { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useFarmData } from '@/lib/hooks/useFarmData';
import { useProducts } from '@/lib/hooks/useProducts';
import { Crop } from '@/types/farm';
import { Card } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import FarmGameView from './components/FarmGameView';
import ThreeFarmScene from './components/ThreeFarmScene';
import SimulationControls from './components/SimulationControls';
import CropInfoPanel from './components/CropInfoPanel';
import ProductSelector from './components/ProductSelector';
import ResultsPanel from './components/ResultsPanel';
import { fetchEnvironmentalData, estimateCropYield } from '@/lib/services/farmEnvironmentService';

export default function SimulationPage() {
    const router = useRouter();
    const { farmData, isLoading: isFarmLoading, error: farmError } = useFarmData();

    // Simulation state
    const [currentDay, setCurrentDay] = useState(0);
    const [totalDays, setTotalDays] = useState(100); // A growing season of 100 days
    const [isPlaying, setIsPlaying] = useState(false);
    const [playbackSpeed, setPlaybackSpeed] = useState(1);
    const [selectedCropId, setSelectedCropId] = useState<string | null>(null);
    const [view3D, setView3D] = useState(false);
    const [environmentalData, setEnvironmentalData] = useState<any>(null);
    const [isEnvironmentLoading, setIsEnvironmentLoading] = useState(true);
    const [selectedProducts, setSelectedProducts] = useState<Record<string, string[]>>({});
    const [yieldEstimates, setYieldEstimates] = useState<Record<string, any>>({});

    // Find the selected crop
    const selectedCrop = selectedCropId
        ? farmData.crops.find(crop => crop.id === selectedCropId) || null
        : null;

    // Load environmental data
    useEffect(() => {
        const loadEnvironmentalData = async () => {
            if (!farmData.location || farmData.location.lat === 0) return;

            setIsEnvironmentLoading(true);
            try {
                const data = await fetchEnvironmentalData(farmData.location);
                setEnvironmentalData(data);

                // Calculate initial yield estimates
                if (data && farmData.crops.length > 0) {
                    const estimates: Record<string, any> = {};
                    farmData.crops.forEach(crop => {
                        estimates[crop.id] = estimateCropYield(crop, data);
                    });
                    setYieldEstimates(estimates);
                }

            } catch (error) {
                console.error('Error loading environmental data:', error);
            } finally {
                setIsEnvironmentLoading(false);
            }
        };

        loadEnvironmentalData();
    }, [farmData.location, farmData.crops]);

    // Simulation loop using requestAnimationFrame
    useEffect(() => {
        let lastUpdateTime = 0;
        let animationFrameId: number;

        const updateSimulation = (timestamp: number) => {
            if (!isPlaying) return;

            // Calculate time delta and update day based on playback speed
            const deltaTime = timestamp - lastUpdateTime;

            // Update every 50ms for smooth animation
            if (deltaTime > 50) {
                // Progress 0.1 days per 50ms at 1x speed
                const dayIncrement = (deltaTime / 500) * playbackSpeed;

                setCurrentDay(prevDay => {
                    const newDay = prevDay + dayIncrement;
                    return newDay >= totalDays ? totalDays : newDay;
                });

                lastUpdateTime = timestamp;
            }

            animationFrameId = requestAnimationFrame(updateSimulation);
        };

        if (isPlaying) {
            lastUpdateTime = performance.now();
            animationFrameId = requestAnimationFrame(updateSimulation);
        }

        return () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        };
    }, [isPlaying, playbackSpeed, totalDays]);

    // Handle manual day change via slider
    const handleDayChange = useCallback((day: number) => {
        setCurrentDay(day);
    }, []);

    // Toggle play/pause
    const handlePlayToggle = useCallback(() => {
        setIsPlaying(prev => !prev);

        // If we're at the end, restart
        setCurrentDay(prev =>
            prev >= totalDays ? 0 : prev
        );
    }, [totalDays]);

    // Handle speed change
    const handleSpeedChange = useCallback((speed: number) => {
        setPlaybackSpeed(speed);
    }, []);

    // Reset simulation
    const handleReset = useCallback(() => {
        setCurrentDay(0);
        setIsPlaying(false);
    }, []);

    // Handle crop selection
    const handleCropSelect = useCallback((cropId: string) => {
        setSelectedCropId(prevId => prevId === cropId ? null : cropId);
    }, []);

    // Handle closing crop info panel
    const handleClosePanel = useCallback(() => {
        setSelectedCropId(null);
    }, []);

    // Handle product selection
    const handleProductsSelected = useCallback((cropId: string, productIds: string[]) => {
        setSelectedProducts(prev => ({
            ...prev,
            [cropId]: productIds
        }));

        // Update yield estimates when products are applied
        if (environmentalData && yieldEstimates[cropId]) {
            setYieldEstimates(prev => {
                const crop = farmData.crops.find(c => c.id === cropId);
                if (!crop) return prev;

                const baseEstimate = estimateCropYield(crop, environmentalData);

                // Calculate improvement based on products
                // Each product can improve yield by 5-15%
                const productEffect = productIds.length * (0.05 + Math.random() * 0.1);

                const improvedEstimate = {
                    ...baseEstimate,
                    estimatedYield: baseEstimate.estimatedYield * (1 + productEffect),
                    totalEstimatedYield: baseEstimate.totalEstimatedYield * (1 + productEffect),
                    productEffect: productEffect
                };

                return {
                    ...prev,
                    [cropId]: improvedEstimate
                };
            });
        }
    }, [environmentalData, farmData.crops, yieldEstimates]);

    // Handle product application
    const handleApplyProduct = useCallback((cropId: string, productId: string) => {
        setSelectedProducts(prev => {
            const currentProducts = prev[cropId] || [];
            if (!currentProducts.includes(productId)) {
                return {
                    ...prev,
                    [cropId]: [...currentProducts, productId]
                };
            }
            return prev;
        });
    }, []);

    // Toggle between 2D and 3D views
    const toggleView = useCallback(() => {
        setView3D(prev => !prev);
    }, []);

    // Return to setup
    const goToSetup = useCallback(() => {
        router.push('/');
    }, [router]);

    // Calculate total yield across all crops
    const totalYield = Object.values(yieldEstimates).reduce((sum, est) => {
        return sum + (est.totalEstimatedYield || 0);
    }, 0);

    // Calculate total yield improvement from products
    const totalImprovement = Object.values(yieldEstimates).reduce((sum, est: any) => {
        return sum + ((est.productEffect || 0) * est.totalEstimatedYield || 0);
    }, 0);

    // Loading state
    if (isFarmLoading || isEnvironmentLoading) {
        return (
            <div className="container mx-auto max-w-5xl py-8 px-4">
                <Card className="p-6">
                    <div className="flex flex-col items-center justify-center h-64">
                        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-green-500 mb-4"></div>
                        <p className="text-lg">Loading simulation...</p>
                    </div>
                </Card>
            </div>
        );
    }

    // Error state
    if (farmError) {
        return (
            <div className="container mx-auto max-w-5xl py-8 px-4">
                <Card className="p-6">
                    <div className="text-center p-8">
                        <h2 className="text-2xl text-red-500 mb-4">Error Loading Simulation</h2>
                        <p className="mb-6">{farmError}</p>
                        <Button onClick={goToSetup}>Return to Setup</Button>
                    </div>
                </Card>
            </div>
        );
    }

    // No farm data
    if (!farmData || !farmData.crops || farmData.crops.length === 0) {
        return (
            <div className="container mx-auto max-w-5xl py-8 px-4">
                <Card className="p-6">
                    <div className="text-center p-8">
                        <h2 className="text-2xl mb-4">No Farm Data Available</h2>
                        <p className="mb-6">Please complete the farm setup first.</p>
                        <Button onClick={goToSetup}>Go to Farm Setup</Button>
                    </div>
                </Card>
            </div>
        );
    }

    return (
        <div className="container mx-auto max-w-5xl py-8 px-4">
            {/* Header section */}
            <div className="mb-6 text-center">
                <h1 className="text-3xl font-bold mb-2">Farm Simulation</h1>
                <p className="text-gray-600">
                    Watch your crops grow through the season and see how biological products can help improve yields
                </p>
            </div>

            {/* Main content area */}
            <div className="flex flex-col gap-6">
                {/* Primary section with farm view and controls */}
                <Card className="relative p-4">
                    {/* View toggle */}
                    <div className="absolute top-4 right-4 z-10">
                        <Button
                            onClick={toggleView}
                            size="sm"
                            variant="outline"
                        >
                            Switch to {view3D ? '2D' : '3D'} View
                        </Button>
                    </div>

                    {/* Farm visualization */}
                    <div className="relative mb-4">
                        {view3D ? (
                            <ThreeFarmScene
                                farmData={farmData}
                                currentDay={currentDay}
                                weatherData={environmentalData}
                                onCropSelect={handleCropSelect}
                            />
                        ) : (
                            <FarmGameView
                                farmData={farmData}
                                currentDay={currentDay}
                                weatherData={environmentalData}
                                onCropSelect={handleCropSelect}
                            />
                        )}

                        {/* Crop Info Panel (shows when a crop is selected) */}
                        {selectedCrop && (
                            <CropInfoPanel
                                crop={selectedCrop}
                                environmentalData={environmentalData}
                                currentDay={currentDay}
                                onApplyProduct={handleApplyProduct}
                                onClose={handleClosePanel}
                            />
                        )}
                    </div>

                    {/* Simulation Controls */}
                    <SimulationControls
                        currentDay={currentDay}
                        totalDays={totalDays}
                        isPlaying={isPlaying}
                        playbackSpeed={playbackSpeed}
                        onDayChange={handleDayChange}
                        onPlayToggle={handlePlayToggle}
                        onSpeedChange={handleSpeedChange}
                        onReset={handleReset}
                    />
                </Card>

                {/* Results and products section */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <ResultsPanel
                        crops={farmData.crops}
                        yieldEstimates={yieldEstimates}
                        selectedProducts={selectedProducts}
                        onCropSelect={handleCropSelect}
                        currentDay={currentDay}
                    />

                    {/* Product Selector */}
                    <Card className="p-4">
                        <h2 className="text-xl font-bold mb-4">Bio-Products</h2>
                        <ProductSelector
                            crops={farmData.crops}
                            onProductsSelected={handleProductsSelected}
                            selectedProducts={selectedProducts}
                        />
                    </Card>
                </div>

                {/* Return to setup button */}
                <div className="text-center mt-4">
                    <Button variant="outline" onClick={goToSetup}>
                        Return to Farm Setup
                    </Button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="components/farm/CropStressAnalysis.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import { Card } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import { Crop, GeoLocation } from '@/types/farm';
import { analyzeCropSuitability } from '@/lib/services/farmEnvironmentService';

interface CropStressAnalysisProps {
    crops: Crop[];
    location: GeoLocation;
    className?: string;
    onSelectProduct?: (cropId: string, stressType: string) => void;
}

interface StressResult {
    cropId: string;
    cropName: string;
    cropType: string;
    temperature: { stress: number };
    water: { stress: number };
    soil: { stress: number };
    overall: { stress: number };
    loading: boolean;
    error: string | null;
}

export default function CropStressAnalysis({
    crops,
    location,
    className = '',
    onSelectProduct
}: CropStressAnalysisProps) {
    const [stressResults, setStressResults] = useState<StressResult[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        async function analyzeStress() {
            if (!crops || crops.length === 0) {
                setIsLoading(false);
                return;
            }

            setIsLoading(true);
            setError(null);

            try {
                // Initialize stress results with loading state
                const initialStressResults = crops.map(crop => ({
                    cropId: crop.id,
                    cropName: crop.name,
                    cropType: crop.type,
                    temperature: { stress: 0 },
                    water: { stress: 0 },
                    soil: { stress: 0 },
                    overall: { stress: 0 },
                    loading: true,
                    error: null
                }));

                setStressResults(initialStressResults);

                // Fetch environmental data
                const forecastResponse = await fetch(
                    `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=forecast`
                );

                if (!forecastResponse.ok) {
                    throw new Error(`Failed to fetch forecast data: ${forecastResponse.status}`);
                }

                const forecastData = await forecastResponse.json();

                // Fetch soil data
                const soilResponse = await fetch(
                    `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=soil`
                );

                if (!soilResponse.ok) {
                    throw new Error(`Failed to fetch soil data: ${soilResponse.status}`);
                }

                const soilData = await soilResponse.json();

                // Combine environmental data
                const environmentalData = {
                    ...forecastData,
                    ...soilData
                };

                // Analyze each crop
                const results = crops.map(crop => {
                    try {
                        const analysis = analyzeCropSuitability(crop, environmentalData);
                        return {
                            cropId: crop.id,
                            cropName: crop.name,
                            cropType: crop.type,
                            ...analysis,
                            loading: false,
                            error: null
                        };
                    } catch (err) {
                        console.error(`Error analyzing crop ${crop.name}:`, err);
                        return {
                            cropId: crop.id,
                            cropName: crop.name,
                            cropType: crop.type,
                            temperature: { stress: 0 },
                            water: { stress: 0 },
                            soil: { stress: 0 },
                            overall: { stress: 0 },
                            loading: false,
                            error: 'Analysis failed'
                        };
                    }
                });

                setStressResults(results);
            } catch (err) {
                console.error('Error in crop stress analysis:', err);
                setError('Failed to analyze crop stress. Please try again later.');
            } finally {
                setIsLoading(false);
            }
        }

        analyzeStress();
    }, [crops, location]);

    // Helper to render stress indicator
    const renderStressIndicator = (stressLevel: number) => {
        let color = 'bg-green-500';
        let label = 'Low';

        if (stressLevel > 0.7) {
            color = 'bg-red-500';
            label = 'High';
        } else if (stressLevel > 0.3) {
            color = 'bg-yellow-500';
            label = 'Medium';
        }

        const percentage = Math.min(100, Math.max(0, Math.round(stressLevel * 100)));

        return (
            <div className="w-full">
                <div className="flex justify-between text-xs mb-1">
                    <span>{label}</span>
                    <span>{percentage}%</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2.5">
                    <div
                        className={`${color} h-2.5 rounded-full transition-all duration-500`}
                        style={{ width: `${percentage}%` }}
                    ></div>
                </div>
            </div>
        );
    };

    // Helper function to get appropriate recommendation based on stress type
    const getRecommendationText = (cropType: string, stressType: string, stressLevel: number) => {
        if (stressLevel < 0.3) return "No intervention needed";

        switch (stressType) {
            case 'temperature':
                return stressLevel > 0.7
                    ? "Consider Stress Buster for heat protection"
                    : "Monitor temperature changes";
            case 'water':
                return stressLevel > 0.7
                    ? "Consider Stress Buster for drought protection"
                    : "Monitor soil moisture";
            case 'soil':
                return stressLevel > 0.7
                    ? "Consider NUE Product to improve soil conditions"
                    : "Consider soil amendments";
            default:
                return "Consider crop-specific treatment";
        }
    };

    if (isLoading) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="flex justify-center items-center h-32">
                    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500"></div>
                    <span className="ml-2">Analyzing crop conditions...</span>
                </div>
            </Card>
        );
    }

    if (error) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="text-red-500 p-2">
                    <p className="font-semibold">Error analyzing crops</p>
                    <p className="text-sm">{error}</p>
                </div>
            </Card>
        );
    }

    if (stressResults.length === 0) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="text-gray-500 p-2">
                    <p>No crops to analyze.</p>
                </div>
            </Card>
        );
    }

    return (
        <Card className={`p-4 ${className}`}>
            <div className="space-y-4">
                <h3 className="text-lg font-semibold">Crop Stress Analysis</h3>

                <div className="space-y-6">
                    {stressResults.map((result) => (
                        <div key={result.cropId} className="border rounded-lg p-4">
                            <div className="flex justify-between items-center mb-4">
                                <h4 className="font-medium">{result.cropName}</h4>
                                <span className="text-sm text-gray-500 capitalize">{result.cropType}</span>
                            </div>

                            {result.loading ? (
                                <div className="flex justify-center py-4">
                                    <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-green-500"></div>
                                </div>
                            ) : result.error ? (
                                <div className="text-red-500 text-sm">{result.error}</div>
                            ) : (
                                <div className="space-y-4">
                                    {/* Overall Stress */}
                                    <div className="mb-4">
                                        <div className="text-sm font-medium mb-1">Overall Stress Level</div>
                                        {renderStressIndicator(result.overall.stress)}
                                    </div>

                                    {/* Detailed Stress Factors */}
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        {/* Temperature Stress */}
                                        <div className="space-y-2">
                                            <div className="text-sm font-medium">Temperature Stress</div>
                                            {renderStressIndicator(result.temperature.stress)}
                                            <div className="text-xs text-gray-600">
                                                {getRecommendationText(result.cropType, 'temperature', result.temperature.stress)}
                                            </div>
                                            {onSelectProduct && result.temperature.stress > 0.3 && (
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    className="w-full mt-2"
                                                    onClick={() => onSelectProduct(result.cropId, 'temperature')}
                                                >
                                                    View Solutions
                                                </Button>
                                            )}
                                        </div>

                                        {/* Water Stress */}
                                        <div className="space-y-2">
                                            <div className="text-sm font-medium">Water Stress</div>
                                            {renderStressIndicator(result.water.stress)}
                                            <div className="text-xs text-gray-600">
                                                {getRecommendationText(result.cropType, 'water', result.water.stress)}
                                            </div>
                                            {onSelectProduct && result.water.stress > 0.3 && (
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    className="w-full mt-2"
                                                    onClick={() => onSelectProduct(result.cropId, 'water')}
                                                >
                                                    View Solutions
                                                </Button>
                                            )}
                                        </div>

                                        {/* Soil Stress */}
                                        <div className="space-y-2">
                                            <div className="text-sm font-medium">Soil Stress</div>
                                            {renderStressIndicator(result.soil.stress)}
                                            <div className="text-xs text-gray-600">
                                                {getRecommendationText(result.cropType, 'soil', result.soil.stress)}
                                            </div>
                                            {onSelectProduct && result.soil.stress > 0.3 && (
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    className="w-full mt-2"
                                                    onClick={() => onSelectProduct(result.cropId, 'soil')}
                                                >
                                                    View Solutions
                                                </Button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    ))}
                </div>
            </div>
        </Card>
    );
}
</file>

<file path="components/farm/EnvironmentalDataDisplay.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import { Card } from '@/components/ui/Card';
import { GeoLocation } from '@/types/farm';

interface EnvironmentalDataDisplayProps {
    location: GeoLocation;
    className?: string;
}

interface WeatherData {
    forecast?: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
    };
    soil?: {
        texture: string;
        properties: {
            bulkDensity: number;
            organicMatter: number;
            ph: number;
            waterHoldingCapacity: number;
            cationExchangeCapacity: number;
        };
    };
}

export default function EnvironmentalDataDisplay({ location, className = '' }: EnvironmentalDataDisplayProps) {
    const [environmentalData, setEnvironmentalData] = useState<WeatherData | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        async function fetchEnvironmentalData() {
            if (!location || !location.lat || !location.lng) {
                setError('Invalid location data');
                setIsLoading(false);
                return;
            }

            try {
                setIsLoading(true);
                setError(null);

                // Fetch forecast data
                const forecastResponse = await fetch(
                    `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=forecast`
                );

                if (!forecastResponse.ok) {
                    throw new Error(`Failed to fetch forecast data: ${forecastResponse.status}`);
                }

                const forecastData = await forecastResponse.json();

                // Fetch soil data
                const soilResponse = await fetch(
                    `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=soil`
                );

                if (!soilResponse.ok) {
                    throw new Error(`Failed to fetch soil data: ${soilResponse.status}`);
                }

                const soilData = await soilResponse.json();

                // Combine data
                setEnvironmentalData({
                    forecast: forecastData.forecast,
                    soil: soilData.soil
                });

            } catch (err) {
                console.error('Error fetching environmental data:', err);
                setError('Failed to fetch environmental data. Please try again later.');
            } finally {
                setIsLoading(false);
            }
        }

        fetchEnvironmentalData();
    }, [location]);

    // Format date string
    const formatDate = (dateStr: string) => {
        const date = new Date(dateStr);
        return new Intl.DateTimeFormat('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric'
        }).format(date);
    };

    if (isLoading) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="flex justify-center items-center h-32">
                    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500"></div>
                    <span className="ml-2">Loading environmental data...</span>
                </div>
            </Card>
        );
    }

    if (error) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="text-red-500 p-2">
                    <p className="font-semibold">Error loading environmental data</p>
                    <p className="text-sm">{error}</p>
                </div>
            </Card>
        );
    }

    if (!environmentalData || !environmentalData.forecast) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="text-gray-500 p-2">
                    <p>No environmental data available for this location.</p>
                </div>
            </Card>
        );
    }

    return (
        <Card className={`p-4 ${className}`}>
            <div className="space-y-4">
                <h3 className="text-lg font-semibold">Environmental Conditions</h3>

                {/* Weather Forecast Section */}
                <div>
                    <h4 className="text-md font-medium mb-2">7-Day Weather Forecast</h4>
                    <div className="overflow-x-auto">
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-50">
                                <tr>
                                    <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Date
                                    </th>
                                    <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Temp (¬∞C)
                                    </th>
                                    <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Precip (mm)
                                    </th>
                                    <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Humidity (%)
                                    </th>
                                    <th scope="col" className="px-3 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Wind (m/s)
                                    </th>
                                </tr>
                            </thead>
                            <tbody className="bg-white divide-y divide-gray-200">
                                {environmentalData.forecast.daily.slice(0, 7).map((day, index) => (
                                    <tr key={day.date} className={index % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                                        <td className="px-3 py-2 whitespace-nowrap text-sm">
                                            {formatDate(day.date)}
                                        </td>
                                        <td className="px-3 py-2 whitespace-nowrap text-sm">
                                            <span className="text-red-500">{day.temperature.max.toFixed(1)}</span> / <span className="text-blue-500">{day.temperature.min.toFixed(1)}</span>
                                        </td>
                                        <td className="px-3 py-2 whitespace-nowrap text-sm">
                                            {day.precipitation.toFixed(1)}
                                        </td>
                                        <td className="px-3 py-2 whitespace-nowrap text-sm">
                                            {day.humidity.toFixed(0)}
                                        </td>
                                        <td className="px-3 py-2 whitespace-nowrap text-sm">
                                            {day.windSpeed.toFixed(1)}
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                </div>

                {/* Soil Data Section */}
                {environmentalData.soil && (
                    <div>
                        <h4 className="text-md font-medium mb-2">Soil Characteristics</h4>
                        <div className="grid grid-cols-2 sm:grid-cols-3 gap-4">
                            <div className="bg-gray-50 p-3 rounded-lg">
                                <div className="text-xs text-gray-500 uppercase">Soil Texture</div>
                                <div className="font-medium">{environmentalData.soil.texture}</div>
                            </div>
                            <div className="bg-gray-50 p-3 rounded-lg">
                                <div className="text-xs text-gray-500 uppercase">Soil pH</div>
                                <div className="font-medium">{environmentalData.soil.properties.ph.toFixed(1)}</div>
                            </div>
                            <div className="bg-gray-50 p-3 rounded-lg">
                                <div className="text-xs text-gray-500 uppercase">Organic Matter</div>
                                <div className="font-medium">{environmentalData.soil.properties.organicMatter !== null 
    ? `${environmentalData.soil.properties.organicMatter.toFixed(1)}%` 
    : 'Not available'}%</div>
                            </div>
                            <div className="bg-gray-50 p-3 rounded-lg">
                                <div className="text-xs text-gray-500 uppercase">Water Holding</div>
                                <div className="font-medium">{environmentalData.soil.properties.waterHoldingCapacity.toFixed(2)} cm¬≥/cm¬≥</div>
                            </div>
                            <div className="bg-gray-50 p-3 rounded-lg">
                                <div className="text-xs text-gray-500 uppercase">Bulk Density</div>
                                <div className="font-medium">{environmentalData.soil.properties.bulkDensity.toFixed(2)} g/cm¬≥</div>
                            </div>
                            <div className="bg-gray-50 p-3 rounded-lg">
                                <div className="text-xs text-gray-500 uppercase">CEC</div>
                                <div className="font-medium">{environmentalData.soil.properties.cationExchangeCapacity.toFixed(1)} meq/100g</div>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        </Card>
    );
}
</file>

<file path="components/farm/FarmSetup.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/Button';
import { Card } from '@/components/ui/Card';
import LocationPicker from '@/components/farm/LocationPicker';
import CropSelector from '@/components/farm/CropSelector';
import EnvironmentalDataDisplay from '@/components/farm/EnvironmentalDataDisplay';
import CropStressAnalysis from '@/components/farm/CropStressAnalysis';
import { useFarmData } from '@/lib/hooks/useFarmData';

export default function FarmSetup() {
    const router = useRouter();
    const {
        farmData,
        isLoading,
        updateFarmName,
        updateFarmLocation,
        updateFarmSize,
        updateFarmCrops,
        saveFarm,
        error
    } = useFarmData();

    // Flag to track save status
    const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'success' | 'error'>('idle');
    // Flag to control environmental data display
    const [showEnvironmentalData, setShowEnvironmentalData] = useState(false);

    // Handle form submission
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();

        setSaveStatus('saving');

        // Save farm data
        saveFarm();

        // Set success status
        setSaveStatus('success');

        // Navigate to simulation after a brief delay
        setTimeout(() => {
            router.push('/simulation');
        }, 500);
    };

    // Reset save status after a delay
    useEffect(() => {
        if (saveStatus === 'success' || saveStatus === 'error') {
            const timer = setTimeout(() => {
                setSaveStatus('idle');
            }, 3000);

            return () => clearTimeout(timer);
        }
    }, [saveStatus]);

    // Show environmental data when location changes
    useEffect(() => {
        if (farmData.location && farmData.location.lat !== 0 && farmData.location.lng !== 0) {
            setShowEnvironmentalData(true);
        }
    }, [farmData.location]);

    if (isLoading) {
        return (
            <Card className="p-6 max-w-2xl mx-auto">
                <div className="text-center py-12">
                    <div className="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500 mb-4"></div>
                    <p>Loading farm data...</p>
                </div>
            </Card>
        );
    }

    return (
        <Card className="p-6 max-w-2xl mx-auto">
            <form onSubmit={handleSubmit}>
                <div className="space-y-6">
                    {/* Farm Name */}
                    <div>
                        <label htmlFor="farmName" className="block text-sm font-medium text-gray-700 mb-1">
                            Farm Name
                        </label>
                        <input
                            type="text"
                            id="farmName"
                            value={farmData.name}
                            onChange={(e) => updateFarmName(e.target.value)}
                            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                            required
                        />
                    </div>

                    {/* Location Picker */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-1">
                            Farm Location
                        </label>
                        <LocationPicker
                            value={farmData.location}
                            onChange={updateFarmLocation}
                            className="w-full"
                        />
                    </div>

                    {/* Environmental Data Display */}
                    {showEnvironmentalData && (
                        <EnvironmentalDataDisplay
                            location={farmData.location}
                            className="mt-4"
                        />
                    )}

                    {/* Farm Size */}
                    <div>
                        <label htmlFor="acreage" className="block text-sm font-medium text-gray-700 mb-1">
                            Total Farm Size (acres)
                        </label>
                        <input
                            type="number"
                            id="acreage"
                            value={farmData.totalAcreage}
                            onChange={(e) => updateFarmSize(parseFloat(e.target.value))}
                            min="1"
                            step="0.1"
                            className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                            required
                        />
                    </div>

                    {/* Crop Selector */}
                    <div>
                        <label className="block text-sm font-medium text-gray-700 mb-3">
                            Farm Crops
                        </label>
                        <CropSelector
                            crops={farmData.crops}
                            onChange={updateFarmCrops}
                            totalFarmSize={farmData.totalAcreage}
                        />
                    </div>

                    {/* Crop Stress Analysis */}
                    {farmData.crops.length > 0 && showEnvironmentalData && (
                        <CropStressAnalysis
                            crops={farmData.crops}
                            location={farmData.location}
                            className="mt-4"
                            onSelectProduct={(cropId, stressType) => {
                                // This will be implemented in Batch 3/4
                                console.log(`Selected product for crop ${cropId} with stress type ${stressType}`);
                            }}
                        />
                    )}

                    {/* Error Display */}
                    {error && (
                        <div className="p-3 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
                            {error}
                        </div>
                    )}

                    {/* Save Status */}
                    {saveStatus === 'success' && (
                        <div className="p-3 bg-green-50 border border-green-200 text-green-600 rounded-md text-sm">
                            Farm setup saved successfully! Redirecting to simulation...
                        </div>
                    )}

                    {/* Submit Button */}
                    <div className="pt-4">
                        <Button
                            type="submit"
                            variant="primary"
                            size="lg"
                            className="w-full"
                            disabled={!!error || saveStatus === 'saving'}
                        >
                            {saveStatus === 'saving' ? 'Saving...' : 'Start Simulation'}
                        </Button>
                    </div>
                </div>
            </form>
        </Card>
    );
}
</file>

<file path="components/farm/LocationPicker.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { GeoLocation } from '@/types/farm';

// Import types but not actual components to avoid SSR issues
import type { MapContainer as MapContainerType } from 'react-leaflet';

interface LocationPickerProps {
    value: GeoLocation;
    onChange: (location: GeoLocation) => void;
    className?: string;
}

// Dynamically import the map component with SSR disabled
// This ensures Leaflet only loads in the browser, not during server rendering
const MapComponentWithNoSSR = dynamic(
    () => import('@/components/farm/MapComponent').then((mod) => mod.default),
    {
        ssr: false,
        loading: () => (
            <div className="h-64 rounded-md overflow-hidden border border-gray-300 bg-gray-100 flex items-center justify-center">
                <div className="text-gray-500">Loading map...</div>
            </div>
        )
    }
);

export default function LocationPicker({ value, onChange, className = '' }: LocationPickerProps) {
    const [searchQuery, setSearchQuery] = useState('');
    const [searchResults, setSearchResults] = useState<Array<{
        display_name: string;
        lat: string;
        lon: string;
    }>>([]);
    const [isSearching, setIsSearching] = useState(false);

    // Handler for search functionality
    const handleSearch = async () => {
        if (!searchQuery.trim()) return;

        setIsSearching(true);
        try {
            // Using Nominatim for geocoding (OpenStreetMap)
            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}`
            );
            const data = await response.json();
            setSearchResults(data.slice(0, 5)); // Limit to 5 results
        } catch (error) {
            console.error('Error searching location:', error);
        } finally {
            setIsSearching(false);
        }
    };

    const handleSelectResult = (result: { lat: string; lon: string }) => {
        onChange({
            lat: parseFloat(result.lat),
            lng: parseFloat(result.lon),
        });
        setSearchResults([]);
        setSearchQuery('');
    };

    return (
        <div className={`flex flex-col ${className}`}>
            {/* Search Component */}
            <div className="mb-4">
                <div className="flex space-x-2">
                    <input
                        type="text"
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        placeholder="Search location (e.g., Karnataka, India)"
                        className="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                        onKeyDown={(e) => e.key === 'Enter' && handleSearch()}
                    />
                    <button
                        type="button"
                        onClick={handleSearch}
                        disabled={isSearching}
                        className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 disabled:bg-green-400"
                    >
                        {isSearching ? 'Searching...' : 'Search'}
                    </button>
                </div>

                {/* Search Results */}
                {searchResults.length > 0 && (
                    <div className="mt-2 border rounded-md shadow-sm max-h-60 overflow-y-auto bg-white">
                        <ul>
                            {searchResults.map((result, index) => (
                                <li
                                    key={index}
                                    className="px-3 py-2 hover:bg-gray-100 cursor-pointer border-b last:border-b-0"
                                    onClick={() => handleSelectResult(result)}
                                >
                                    {result.display_name}
                                </li>
                            ))}
                        </ul>
                    </div>
                )}
            </div>

            {/* Map Component - Dynamically loaded on client-side only */}
            <MapComponentWithNoSSR location={value} onLocationChange={onChange} />

            {/* Coordinate Display */}
            <div className="mt-2 flex justify-between text-sm text-gray-500">
                <span>Latitude: {value.lat.toFixed(6)}</span>
                <span>Longitude: {value.lng.toFixed(6)}</span>
            </div>

            <div className="mt-2 text-xs text-gray-500">
                Tip: Click on the map to set location or use the search box above
            </div>
        </div>
    );
}
</file>

<file path="components/farm/MapComponent.tsx">
"use client";

import React, { useEffect, useRef } from 'react';
import { MapContainer, TileLayer, Marker, useMapEvents } from 'react-leaflet';
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
import { GeoLocation } from '@/types/farm';

interface MapComponentProps {
    location: GeoLocation;
    onLocationChange: (location: GeoLocation) => void;
}

// Component to handle map clicks and update location
function LocationMarker({
    position,
    setPosition
}: {
    position: GeoLocation;
    setPosition: (pos: GeoLocation) => void;
}) {
    const map = useMapEvents({
        click(e) {
            const newPos = { lat: e.latlng.lat, lng: e.latlng.lng };
            setPosition(newPos);
        },
    });

    return <Marker position={[position.lat, position.lng]} />;
}

export default function MapComponent({ location, onLocationChange }: MapComponentProps) {
    const mapRef = useRef<L.Map | null>(null);

    // Fix Leaflet icon issue - only runs on client
    useEffect(() => {
        // Fix for Leaflet marker icons in Next.js
        delete (L.Icon.Default.prototype as any)._getIconUrl;
        L.Icon.Default.mergeOptions({
            iconRetinaUrl: '/images/icons/marker-icon-2x.png',
            iconUrl: '/images/icons/marker-icon.png',
            shadowUrl: '/images/icons/marker-shadow.png',
        });

        // Center map when location changes from external sources
        if (mapRef.current) {
            mapRef.current.setView([location.lat, location.lng], 10);
        }
    }, [location.lat, location.lng]);

    return (
        <div className="h-64 rounded-md overflow-hidden border border-gray-300">
            <MapContainer
                center={[location.lat, location.lng]}
                zoom={10}
                className="h-full w-full"
                whenCreated={(map) => {
                    mapRef.current = map;
                }}
            >
                <TileLayer
                    attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                />
                <LocationMarker
                    position={location}
                    setPosition={onLocationChange}
                />
            </MapContainer>
        </div>
    );
}
</file>

<file path="components/styles/Navbar.css">
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

.navbar-link {
  position: relative;
  color: #1f2937;
  transition: color 0.3s ease;
  font-family: "Inter", sans-serif;
  font-weight: 500;
  padding: 0.5rem 0;
}

.navbar-link::after {
  content: '';
  position: absolute;
  width: 0;
  height: 2px;
  bottom: -2px;
  left: 0;
  background-color: rgba(16, 185, 129, 0.7); /* Green color for Farm Bio-Boost theme */
  transition: width 0.3s ease;
}

.navbar-link:hover {
  color: rgb(16, 185, 129);
}

.navbar-link:hover::after {
  width: 100%;
}

/* Mobile menu styling */
.navbar-menu {
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* For screens smaller than 768px (md breakpoint in Tailwind) */
@media (max-width: 767px) {
  .hamburger-button {
    display: flex;
  }
}

/* For screens larger than 768px */
@media (min-width: 768px) {
  .hamburger-button {
    display: none;
  }
}

/* Add a backdrop for the mobile menu when open */
.navbar-menu-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(2px);
  z-index: 40;
}
</file>

<file path="components/ui/Button.tsx">
"use client";

import React from 'react';

type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'destructive';
type ButtonSize = 'sm' | 'md' | 'lg';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    variant?: ButtonVariant;
    size?: ButtonSize;
    children: React.ReactNode;
}

export const Button: React.FC<ButtonProps> = ({
    variant = 'primary',
    size = 'md',
    children,
    className = '',
    ...props
}) => {
    // Variant styles
    const variantStyles = {
        primary: 'bg-green-600 hover:bg-green-700 text-white',
        secondary: 'bg-blue-600 hover:bg-blue-700 text-white',
        outline: 'bg-transparent border border-green-600 text-green-600 hover:bg-green-50',
        destructive: 'bg-red-600 hover:bg-red-700 text-white',
    };

    // Size styles
    const sizeStyles = {
        sm: 'px-3 py-1.5 text-sm',
        md: 'px-4 py-2',
        lg: 'px-6 py-3 text-lg',
    };

    return (
        <button
            className={`rounded-md font-medium transition-colors focus:outline-none 
        focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 
        ${variantStyles[variant]} ${sizeStyles[size]} ${className}`}
            {...props}
        >
            {children}
        </button>
    );
};
</file>

<file path="components/ui/Card.tsx">
import React from 'react';

interface CardProps {
    children: React.ReactNode;
    className?: string;
}

export const Card: React.FC<CardProps> = ({ children, className = '' }) => {
    return (
        <div className={`bg-white rounded-lg shadow ${className}`}>
            {children}
        </div>
    );
};
</file>

<file path="components/ui/Navbar.tsx">
import Link from 'next/link';
import Image from 'next/image';

export default function Navbar() {
    return (
        <header className="bg-green-500 py-3">
            <div className="container max-w-screen-xl mx-auto px-4 lg:px-20 flex justify-between items-center">
                {/* Project Name */}
                <Link href="/" className="flex items-center">
                    <div className="text-xl font-bold text-white">Farm Bio-Boost</div>
                    <div className="text-sm text-white ml-2">Simulator</div>
                </Link>

                {/* Powered by Syngenta */}
                <div className="flex items-center text-sm text-gray-600">
                    <span className="mr-2">Powered by</span>
                    <Image
                        src="/images/syngenta-logo.png"
                        alt="Syngenta"
                        width={100}
                        height={30}
                        className="w-auto"
                    />
                </div>
            </div>
        </header>
    );
}
</file>

<file path="lib/data/products.json">
{
  "products": [
    {
      "name": "Stress Buster",
      "category": "Biostimulant",
      "type": "Anti-stress and growth activator",
      "application_method": "Foliar application",
      "timing": "As soon as a stress event is predicted",
      "composition": "Complex of selected vegetal extracts derived from selected plants",
      "description": "When applied in case of abiotic stresses, its synergistic action of different active ingredients allows plants to tolerate and quickly overcome the stress, preserving yield. Applied regularly in normal condition, optimizes plant growth.",
      "directions_for_use": {
        "fruit_crops": {
          "dose": "2-3 l/ha",
          "period": "pre-flowering, post-setting, fruit development and in all cases of plant growth stop"
        },
        "vegetable": {
          "dose": "2-3 l/ha",
          "period": "in open field and greenhouses after transplant every 10-15 days"
        },
        "row_crops": {
          "dose": "2-3 l/ha (150-250 mL/hL)",
          "period": "1-2 applications during growth cycle in case of abiotic stresses"
        }
      },
      "scientific_evidence": {
        "transcriptomics": {
          "non_stressed_plants": "Treated plants show activation of >100 genes (FC >3) vs. Control, mainly involved in: i) abiotic stress response/tolerance (\"hardening effect\" against abiotic stress), ii) activation of plant metabolism (thus better growth)",
          "drought_stressed_plants": "Pre-treated with stress buster show a decreased expression of stress-related marker genes during stress conditions, showing a lower perception of the stress itself (\"acclimated plants\"; Petrozza et al., 2014)"
        },
        "phenomics": {
          "improvements": [
            "Digital Biovolume/Biomass",
            "Health Index (less Stress Index)",
            "Water content",
            "Other indexes: Green/Yellow Index, etc"
          ]
        },
        "metabolomics": "METABOLOMICS has also been used recently, to highlight the action of Stress Buster in stress conditions. It has been observed that the product is capable of modulating specific classes of metabolites, connected to the response to abiotic stress."
      },
      "field_trial_results": {
        "crop_performance": {
          "row_crops": {
            "yield_increase": "+ 0,30 t/ha",
            "roi": "3,9:1"
          },
          "vegetable": {
            "yield_increase": "+ 2,3 t/ha",
            "roi": "11,6:1"
          },
          "fruit_crops": {
            "yield_increase": "+ 1,2 t/ha",
            "roi": "10,5:1"
          }
        },
        "stress_conditions": {
          "cold": {
            "evidences": 10,
            "win_rate": "70%",
            "yield_increase": "+5%"
          },
          "heat": {
            "evidences": 26,
            "win_rate": "76,9%",
            "yield_increase": "+8,2%"
          },
          "drought": {
            "evidences": 433,
            "win_rate": "70,7%",
            "yield_increase": "+5,1%"
          }
        },
        "notes": "850 selected trials for the summary, of which 68% were carried out under abiotic stress conditions."
      }
    },
    {
      "name": "Yield Booster",
      "category": "Biostimulant",
      "type": "Crop productivity enhancer",
      "application_method": "Foliar application",
      "timing": "Decision taken before the growing season based on historical data and upcoming season prediction",
      "description": "In our portfolio we have a biostimulant for row crops able to ensure highest productivity and return for farmers. This solution is able to increase plant productivity through better transport of sugars and nutrients, promotion of cell division, and fatty acids biosynthesis and transport.",
      "value_proposition": "Highest crop productivity, Highest return for farmers",
      "directions_for_use": {
        "wheat": {
          "dose": "2 l/ha",
          "period": "1 application at flag leaf growth stage"
        },
        "soybean": {
          "dose": "1-2 l/ha",
          "period": "2 applications: the 1st at Vn/Ri growth stage, the 2nd at R3/R5 growth stage"
        },
        "corn": {
          "dose": "2 l/ha",
          "period": "1 application at V4-V6 growth stage"
        },
        "rice": {
          "dose": "1-2 l/ha",
          "period": "2 applications: the 1st at the beginning of booting, the 2nd at heading growth stage"
        },
        "cotton": {
          "dose": "2 l/ha",
          "period": "2 applications: the 1st before squares appear and 2nd after 3-4 weeks"
        },
        "sunflower": {
          "dose": "2 l/ha",
          "period": "1 application at 4-6 leaf growth stage"
        }
      },
      "scientific_evidence": {
        "transcriptomics": {
          "description": "Next Generation Sequencing (NGS) experiment on corn and soybean: plants treated with Yield Booster showed activation of genes involved in:",
          "activities": [
            "Transport of sugars and nutrients: Zn and Fe uptake and transport, ammoniun and nitrogen assimilation, phosphate homeostasis (uptake, sensing), phloem loading",
            "Promotion of cell division: the coordination of specific hormonal processes, including the establishment of an optimal auxin/cytokinin balance",
            "Fatty acids biosynthesis/transport: lipid transport, photosynthesis"
          ]
        },
        "phenomics": {
          "description": "Experiments on corn and soybean, where Yield Booster improved:",
          "improvements": [
            "Digital Biovolume and height",
            "Plant compactness",
            "Green Index"
          ]
        }
      },
      "field_trial_results": {
        "crop_performance": {
          "bean": {"yield_increase_percentage": 12},
          "cotton": {"yield_increase_percentage": 11},
          "sunflower": {"yield_increase_percentage": 10},
          "rice": {"yield_increase_percentage": 9},
          "soft_wheat": {"yield_increase_percentage": 6},
          "corn": {"yield_increase_percentage": 5, "yield_increase": "+0,64 t/ha", "roi": "7:1"},
          "soybean": {"yield_increase_percentage": 4, "yield_increase": "+0,27 t/ha", "roi": "5:1"},
          "oilseed_rape": {"yield_increase_percentage": 4},
          "barley": {"yield_increase_percentage": 2},
          "wheat": {"yield_increase": "+0,30 t/ha", "roi": "5:1"},
          "rice_detailed": {"yield_increase": "+0,66 t/ha", "roi": "14:1"}
        },
        "trials": {
          "rice_trials": "2017-2022 Rice Trials showed 7.4% Average Yield Increase worldwide",
          "corn_trials": "64 corn trials in 2022 with YieldB application resulted in positive yield response in 83% of trials with an average bu/A increase of 6.8 Bu/A"
        }
      }
    },
    {
      "name": "Nutrient Use Efficiency (NUE) Product",
      "category": "Biofertilizer",
      "application_method": "Seed treatment and foliar application",
      "composition": "Based on 3 strains of endophytic bacteria (Sphingobium salicis, Pseudomonas siliginis, Curtobacterium salicis)",
      "description": "New innovative product concept with dual effect on N and P use efficiency and mineral nutrient uptakes",
      "functionality": {
        "nitrogen_sources": [
          "Air ‚Äì N2",
          "Soil ‚Äì NO, NO3, NH3/NH4",
          "Soil ‚Äì Organic, C-NP"
        ],
        "phosphate_management": [
          "Enhanced P-solubilization",
          "P and K uptake root to shoot transport",
          "Organic acid"
        ],
        "nutrient_availability": [
          "Siderophore production solubilization of micronutrients Fe, Mg, Cu, Zn, Mn, Mo"
        ]
      },
      "application_rates": {
        "foliar_application": {
          "wheat": "10-50 g/ha",
          "barley": "10-50 g/ha",
          "corn": "10-50 g/ha",
          "osr": "10-50 g/ha",
          "rice": "10-50 g/ha"
        },
        "seed_treatment": {
          "wheat": "10-50 g/T seeds",
          "barley": "10-50 g/T seeds",
          "corn": "50-150 g/T seeds",
          "osr": "100-250 g/T seeds",
          "sugarbeet": "500-1050 g/T seeds"
        }
      },
      "scientific_evidence": {
        "trials": "38 trials in corn (US, EU) 2023, 40-unit N reduction scenario - FOLIAR",
        "results": {
          "win_rate": "68% (positive response)",
          "yield_increase_percentage": "2.6%",
          "yield_increase_kg_ha": "250 kg/ha"
        }
      },
      "key_benefits": [
        "Product acts as a \"back up generator\" for plants when nutrients become limiting",
        "Versatile and easy to apply: seed treatment or foliar application",
        "Up to 2 years of shelf life",
        "High compatibility with tank mixtures(F, I, H, F)",
        "Trial data in key field crops"
      ],
      "notes": "Liquid formulation ‚âà Solid formulation (1.2 L/ha = 30 g/ha). 10% difference in N regime is not assumed to generate differences within the system."
    }
  ]
}
</file>

<file path="lib/hooks/useFarmData.ts">
"use client";

import { useState, useEffect } from 'react';
import { FarmData, Crop, GeoLocation } from '@/types/farm';

// Default India (Karnataka) location
const DEFAULT_LOCATION: GeoLocation = {
    lat: 15.3173,
    lng: 75.7139
};

const DEFAULT_FARM_DATA: FarmData = {
    name: 'My Farm',
    location: DEFAULT_LOCATION,
    crops: [
        {
            id: 'crop_1',
            name: 'Rice Field',
            type: 'rice',
            acreage: 5
        }
    ],
    totalAcreage: 10,
    soilType: 'clay loam',
    waterSource: 'irrigation'
};

interface UseFarmDataReturn {
    farmData: FarmData;
    isLoading: boolean;
    updateFarmData: (data: Partial<FarmData>) => void;
    updateFarmLocation: (location: GeoLocation) => void;
    updateFarmCrops: (crops: Crop[]) => void;
    updateFarmName: (name: string) => void;
    updateFarmSize: (acreage: number) => void;
    saveFarm: () => void;
    resetFarm: () => void;
    error: string | null;
}

export function useFarmData(): UseFarmDataReturn {
    const [farmData, setFarmData] = useState<FarmData>(DEFAULT_FARM_DATA);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // Load saved farm data on initial mount
    useEffect(() => {
        const loadFarmData = () => {
            try {
                setIsLoading(true);
                const savedFarmData = localStorage.getItem('farmData');

                if (savedFarmData) {
                    const parsedData = JSON.parse(savedFarmData) as FarmData;
                    setFarmData(parsedData);
                }

                setError(null);
            } catch (err) {
                console.error('Error loading farm data:', err);
                setError('Failed to load saved farm data');
            } finally {
                setIsLoading(false);
            }
        };

        loadFarmData();
    }, []);

    // Update entire farm data object
    const updateFarmData = (data: Partial<FarmData>) => {
        setFarmData(prevData => ({
            ...prevData,
            ...data
        }));
    };

    // Update farm location
    const updateFarmLocation = (location: GeoLocation) => {
        setFarmData(prevData => ({
            ...prevData,
            location
        }));
    };

    // Update farm crops
    const updateFarmCrops = (crops: Crop[]) => {
        // Validate crops
        const totalAcreage = crops.reduce((sum, crop) => sum + crop.acreage, 0);

        if (totalAcreage > farmData.totalAcreage) {
            setError(`Total crop acreage (${totalAcreage}) exceeds farm size (${farmData.totalAcreage})`);
        } else {
            setError(null);
        }

        setFarmData(prevData => ({
            ...prevData,
            crops
        }));
    };

    // Update farm name
    const updateFarmName = (name: string) => {
        setFarmData(prevData => ({
            ...prevData,
            name
        }));
    };

    // Update farm size/acreage
    const updateFarmSize = (acreage: number) => {
        // Validate that new size is sufficient for existing crops
        const cropAcreage = farmData.crops.reduce((sum, crop) => sum + crop.acreage, 0);

        if (cropAcreage > acreage) {
            setError(`Cannot reduce farm size to ${acreage} acres as crops require ${cropAcreage} acres`);
        } else {
            setError(null);
            setFarmData(prevData => ({
                ...prevData,
                totalAcreage: acreage
            }));
        }
    };

    // Save farm data to localStorage
    const saveFarm = () => {
        try {
            localStorage.setItem('farmData', JSON.stringify(farmData));
            setError(null);
        } catch (err) {
            console.error('Error saving farm data:', err);
            setError('Failed to save farm data');
        }
    };

    // Reset farm to default
    const resetFarm = () => {
        setFarmData(DEFAULT_FARM_DATA);
        localStorage.removeItem('farmData');
        setError(null);
    };

    return {
        farmData,
        isLoading,
        updateFarmData,
        updateFarmLocation,
        updateFarmCrops,
        updateFarmName,
        updateFarmSize,
        saveFarm,
        resetFarm,
        error,
    };
}
</file>

<file path="lib/hooks/useProducts.ts">
"use client";

import { useState, useEffect } from 'react';
import { Product } from '@/types/products';

interface UseProductsReturn {
    products: Product[];
    isLoading: boolean;
    error: string | null;
    filterProductsByCategory: (category: string | null) => Product[];
    filterProductsByCrop: (cropType: string | null) => Product[];
    getProductById: (id: string) => Product | undefined;
}

export function useProducts(): UseProductsReturn {
    const [products, setProducts] = useState<Product[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchProducts = async () => {
            try {
                setIsLoading(true);
                const response = await fetch('/api/products');

                if (!response.ok) {
                    throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                setProducts(data.products || []);
                setError(null);
            } catch (err) {
                console.error('Error fetching products:', err);
                setError('Failed to load products. Please try again later.');
            } finally {
                setIsLoading(false);
            }
        };

        fetchProducts();
    }, []);

    // Filter products by category
    const filterProductsByCategory = (category: string | null): Product[] => {
        if (!category) return products;
        return products.filter(product => product.category.toLowerCase() === category.toLowerCase());
    };

    // Filter products by crop compatibility
    const filterProductsByCrop = (cropType: string | null): Product[] => {
        if (!cropType) return products;
        return products.filter(product =>
            product.compatibleCrops.includes(cropType.toLowerCase())
        );
    };

    // Get a specific product by ID
    const getProductById = (id: string): Product | undefined => {
        return products.find(product => product.id === id);
    };

    return {
        products,
        isLoading,
        error,
        filterProductsByCategory,
        filterProductsByCrop,
        getProductById
    };
}
</file>

<file path="lib/services/farmEnvironmentService.ts">
import { FarmData, Crop, GeoLocation } from '@/types/farm';

interface EnvironmentalData {
    forecast?: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: {
        texture: string;
        properties: {
            bulkDensity: number;
            organicMatter: number;
            ph: number;
            waterHoldingCapacity: number;
            cationExchangeCapacity: number;
        };
    };
    stress_factors?: {
        current: {
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        };
        forecast: Array<{
            date: string;
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        }>;
    };
}

interface CropRequirements {
    temperature: {
        min: number;
        optimal: number;
        max: number;
    };
    water: {
        min: number;    // mm/day
        optimal: number;
        max: number;
    };
    soil: {
        ph: {
            min: number;
            optimal: number;
            max: number;
        };
        preferredTextures: string[];
    };
}

// Crop requirements database (simplified)
const cropRequirementsMap: Record<string, CropRequirements> = {
    rice: {
        temperature: { min: 20, optimal: 30, max: 35 },
        water: { min: 6, optimal: 10, max: 15 },
        soil: {
            ph: { min: 5.5, optimal: 6.5, max: 7.0 },
            preferredTextures: ["Clay", "Silty Clay", "Clay Loam"]
        }
    },
    wheat: {
        temperature: { min: 15, optimal: 23, max: 32 },
        water: { min: 3, optimal: 5, max: 8 },
        soil: {
            ph: { min: 6.0, optimal: 7.0, max: 7.5 },
            preferredTextures: ["Loam", "Clay Loam", "Silty Loam"]
        }
    },
    corn: {
        temperature: { min: 18, optimal: 27, max: 35 },
        water: { min: 4, optimal: 6, max: 9 },
        soil: {
            ph: { min: 5.8, optimal: 6.8, max: 7.2 },
            preferredTextures: ["Loam", "Silty Loam", "Sandy Loam"]
        }
    },
    soybean: {
        temperature: { min: 20, optimal: 28, max: 35 },
        water: { min: 4, optimal: 6, max: 8 },
        soil: {
            ph: { min: 6.0, optimal: 6.8, max: 7.5 },
            preferredTextures: ["Loam", "Silty Loam", "Clay Loam"]
        }
    },
    cotton: {
        temperature: { min: 18, optimal: 30, max: 38 },
        water: { min: 5, optimal: 7, max: 9 },
        soil: {
            ph: { min: 5.8, optimal: 7.0, max: 8.0 },
            preferredTextures: ["Loam", "Sandy Loam", "Clay Loam"]
        }
    },
    vegetable: {
        temperature: { min: 15, optimal: 24, max: 30 },
        water: { min: 3, optimal: 5, max: 7 },
        soil: {
            ph: { min: 6.0, optimal: 6.8, max: 7.5 },
            preferredTextures: ["Loam", "Silty Loam", "Sandy Loam"]
        }
    },
    fruit: {
        temperature: { min: 15, optimal: 25, max: 33 },
        water: { min: 3, optimal: 5, max: 8 },
        soil: {
            ph: { min: 6.0, optimal: 6.5, max: 7.2 },
            preferredTextures: ["Loam", "Sandy Loam", "Silty Loam"]
        }
    }
};

/**
 * Fetches environmental data for a farm location
 */
export async function fetchEnvironmentalData(location: GeoLocation): Promise<EnvironmentalData> {
    try {
        // Calculate dates for API query
        const today = new Date();
        const startDate = today.toISOString().split('T')[0];
        const endDate = new Date(today.setDate(today.getDate() + 14)).toISOString().split('T')[0];

        // Fetch forecast data
        const forecastResponse = await fetch(
            `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=forecast&startDate=${startDate}&endDate=${endDate}`
        );

        if (!forecastResponse.ok) {
            throw new Error(`Failed to fetch forecast data: ${forecastResponse.status}`);
        }

        const forecastData = await forecastResponse.json();

        // Fetch soil data
        const soilResponse = await fetch(
            `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=soil`
        );

        if (!soilResponse.ok) {
            throw new Error(`Failed to fetch soil data: ${soilResponse.status}`);
        }

        const soilData = await soilResponse.json();

        // Combine the data
        return {
            ...forecastData,
            ...soilData
        };
    } catch (error) {
        console.error('Error fetching environmental data:', error);
        throw error;
    }
}

/**
 * Analyzes environmental conditions for a specific crop
 */
export function analyzeCropSuitability(crop: Crop, environmentalData: EnvironmentalData) {
    const cropRequirements = cropRequirementsMap[crop.type];
    const results = {
        temperature: { suitability: 0, stress: 0 },
        water: { suitability: 0, stress: 0 },
        soil: { suitability: 0, stress: 0 },
        overall: { suitability: 0, stress: 0 }
    };

    // Temperature analysis
    if (environmentalData.forecast?.daily) {
        const forecast = environmentalData.forecast.daily;
        let tempSuitabilitySum = 0;
        let tempStressSum = 0;

        forecast.forEach(day => {
            const avgTemp = day.temperature.avg;
            const { min, optimal, max } = cropRequirements.temperature;

            // Calculate temperature suitability (0-1 scale)
            let tempSuitability = 0;
            if (avgTemp < min) {
                tempSuitability = 0;
            } else if (avgTemp < optimal) {
                tempSuitability = (avgTemp - min) / (optimal - min);
            } else if (avgTemp <= max) {
                tempSuitability = 1 - (avgTemp - optimal) / (max - optimal);
            } else {
                tempSuitability = 0;
            }

            // Calculate temperature stress
            let tempStress = 0;
            if (avgTemp < min) {
                tempStress = (min - avgTemp) / min * 0.5; // Cold stress
            } else if (avgTemp > max) {
                tempStress = (avgTemp - max) / max * 0.5; // Heat stress
            }

            tempSuitabilitySum += tempSuitability;
            tempStressSum += tempStress;
        });

        results.temperature.suitability = tempSuitabilitySum / forecast.length;
        results.temperature.stress = tempStressSum / forecast.length;
    }

    // Water/precipitation analysis
    if (environmentalData.forecast?.daily) {
        const forecast = environmentalData.forecast.daily;
        let waterSuitabilitySum = 0;
        let waterStressSum = 0;

        forecast.forEach(day => {
            const precip = day.precipitation;
            const { min, optimal, max } = cropRequirements.water;

            // Calculate water suitability (0-1 scale)
            let waterSuitability = 0;
            if (precip < min) {
                waterSuitability = precip / min;
            } else if (precip < optimal) {
                waterSuitability = (precip - min) / (optimal - min);
            } else if (precip <= max) {
                waterSuitability = 1 - (precip - optimal) / (max - optimal);
            } else {
                waterSuitability = Math.max(0, 1 - (precip - max) / max);
            }

            // Calculate water stress
            let waterStress = 0;
            if (precip < min) {
                waterStress = (min - precip) / min; // Drought stress
            } else if (precip > max * 1.5) {
                waterStress = (precip - max * 1.5) / (max * 1.5); // Excess water stress
            }

            waterSuitabilitySum += waterSuitability;
            waterStressSum += waterStress;
        });

        results.water.suitability = waterSuitabilitySum / forecast.length;
        results.water.stress = waterStressSum / forecast.length;
    }

    // Soil analysis
    if (environmentalData.soil) {
        const { texture, properties } = environmentalData.soil;
        const { ph, preferredTextures } = cropRequirements.soil;

        // Calculate pH suitability
        let phSuitability = 0;
        const soilPh = properties.ph;

        if (soilPh < ph.min) {
            phSuitability = Math.max(0, soilPh / ph.min);
        } else if (soilPh < ph.optimal) {
            phSuitability = (soilPh - ph.min) / (ph.optimal - ph.min);
        } else if (soilPh <= ph.max) {
            phSuitability = 1 - (soilPh - ph.optimal) / (ph.max - ph.optimal);
        } else {
            phSuitability = Math.max(0, 1 - (soilPh - ph.max) / 2);
        }

        // Calculate texture suitability
        const textureSuitability = preferredTextures.includes(texture) ? 1 : 0.5;

        results.soil.suitability = (phSuitability + textureSuitability) / 2;
        results.soil.stress = 1 - results.soil.suitability;
    }

    // Calculate overall suitability and stress
    results.overall.suitability = (
        results.temperature.suitability +
        results.water.suitability +
        results.soil.suitability
    ) / 3;

    results.overall.stress = (
        results.temperature.stress +
        results.water.stress +
        results.soil.stress
    ) / 3;

    return results;
}

/**
 * Generates crop yield estimations based on environmental factors
 */
export function estimateCropYield(crop: Crop, environmentalData: EnvironmentalData) {
    const suitabilityResults = analyzeCropSuitability(crop, environmentalData);

    // Base yield potential per acre for each crop (tons)
    const baseYieldPotential: Record<string, number> = {
        rice: 3.5,
        wheat: 2.8,
        corn: 5.0,
        soybean: 1.8,
        cotton: 0.9,
        vegetable: 10.0,
        fruit: 7.5
    };

    // Calculate estimated yield
    const yieldPotential = baseYieldPotential[crop.type] || 1.0;
    const estimatedYield = yieldPotential * (1 - suitabilityResults.overall.stress);

    // Calculate potential improvement with bio-products
    const potentialImprovement = yieldPotential * suitabilityResults.overall.stress * 0.7;

    return {
        cropName: crop.name,
        cropType: crop.type,
        acreage: crop.acreage,
        baseYieldPotential: yieldPotential,
        estimatedYield,
        totalEstimatedYield: estimatedYield * crop.acreage,
        potentialImprovement,
        totalPotentialImprovement: potentialImprovement * crop.acreage,
        stressFactors: {
            temperature: suitabilityResults.temperature.stress,
            water: suitabilityResults.water.stress,
            soil: suitabilityResults.soil.stress
        }
    };
}

/**
 * Analyzes a farm's environmental conditions and crop suitability
 */
export async function analyzeFarm(farmData: FarmData) {
    try {
        // Fetch environmental data for farm location
        const environmentalData = await fetchEnvironmentalData(farmData.location);

        // Analyze each crop
        const cropAnalysis = farmData.crops.map(crop => {
            const suitability = analyzeCropSuitability(crop, environmentalData);
            const yieldEstimate = estimateCropYield(crop, environmentalData);

            return {
                crop,
                suitability,
                yieldEstimate
            };
        });

        // Calculate farm-wide metrics
        const totalAcreage = farmData.totalAcreage;
        const allocatedAcreage = farmData.crops.reduce((sum, crop) => sum + crop.acreage, 0);
        const farmSuitability = cropAnalysis.reduce((sum, analysis) => {
            return sum + (analysis.suitability.overall.suitability * analysis.crop.acreage);
        }, 0) / allocatedAcreage;

        return {
            farmData,
            environmentalData,
            cropAnalysis,
            totalAcreage,
            allocatedAcreage,
            unallocatedAcreage: totalAcreage - allocatedAcreage,
            farmSuitability
        };
    } catch (error) {
        console.error('Error analyzing farm:', error);
        throw error;
    }
}
</file>

<file path="public/data/mock-environment.json">
{
  "forecast": {
    "daily": [
      {
        "date": "2025-03-19",
        "temperature": {
          "max": 28.4,
          "min": 18.2,
          "avg": 23.1
        },
        "precipitation": 0,
        "humidity": 65.2,
        "windSpeed": 3.4,
        "globalRadiation": 6750
      },
      {
        "date": "2025-03-20",
        "temperature": {
          "max": 29.1,
          "min": 19.3,
          "avg": 24.2
        },
        "precipitation": 0,
        "humidity": 62.1,
        "windSpeed": 2.8,
        "globalRadiation": 7020
      },
      {
        "date": "2025-03-21",
        "temperature": {
          "max": 27.5,
          "min": 17.8,
          "avg": 22.6
        },
        "precipitation": 5.3,
        "humidity": 78.4,
        "windSpeed": 4.6,
        "globalRadiation": 4250
      },
      {
        "date": "2025-03-22",
        "temperature": {
          "max": 24.8,
          "min": 16.9,
          "avg": 20.3
        },
        "precipitation": 12.7,
        "humidity": 83.9,
        "windSpeed": 5.2,
        "globalRadiation": 3850
      },
      {
        "date": "2025-03-23",
        "temperature": {
          "max": 26.2,
          "min": 17.5,
          "avg": 21.8
        },
        "precipitation": 2.1,
        "humidity": 75.3,
        "windSpeed": 3.9,
        "globalRadiation": 5420
      },
      {
        "date": "2025-03-24",
        "temperature": {
          "max": 28.7,
          "min": 18.9,
          "avg": 23.5
        },
        "precipitation": 0,
        "humidity": 64.8,
        "windSpeed": 3.1,
        "globalRadiation": 6980
      },
      {
        "date": "2025-03-25",
        "temperature": {
          "max": 30.2,
          "min": 19.7,
          "avg": 24.8
        },
        "precipitation": 0,
        "humidity": 59.2,
        "windSpeed": 2.5,
        "globalRadiation": 7240
      }
    ],
    "hourly": [
      {
        "datetime": "2025-03-19T00:00:00",
        "temperature": 19.2,
        "humidity": 72.5,
        "windSpeed": 2.1,
        "precipitation": 0,
        "cloudCover": 15
      },
      {
        "datetime": "2025-03-19T01:00:00",
        "temperature": 18.7,
        "humidity": 74.8,
        "windSpeed": 1.8,
        "precipitation": 0,
        "cloudCover": 10
      }
    ]
  },
  "historical": {
    "temperature": {
      "avg": 24.5,
      "max": 35.2,
      "min": 15.1
    },
    "precipitation": {
      "annual": 850,
      "monthly": [45, 60, 75, 90, 120, 65, 45, 35, 70, 95, 85, 65]
    }
  },
  "soil": {
    "texture": "Clay Loam",
    "properties": {
      "bulkDensity": 1.35,
      "organicMatter": 2.8,
      "ph": 6.5,
      "waterHoldingCapacity": 0.22,
      "cationExchangeCapacity": 12.5
    }
  },
  "stress_factors": {
    "current": {
      "drought": 0.2,
      "heat": 0.1,
      "nutrient_deficiency": 0.05
    },
    "forecast": [
      {
        "date": "2025-03-20",
        "drought": 0.25,
        "heat": 0.15,
        "nutrient_deficiency": 0.05
      },
      {
        "date": "2025-03-21",
        "drought": 0.15,
        "heat": 0.1,
        "nutrient_deficiency": 0.05
      },
      {
        "date": "2025-03-22",
        "drought": 0.05,
        "heat": 0.05,
        "nutrient_deficiency": 0.05
      }
    ]
  }
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="types/farm.ts">
export interface GeoLocation {
    lat: number;
    lng: number;
}

export interface Crop {
    id: string;
    name: string;
    type: CropType;
    acreage: number;
}

export type CropType =
    | 'rice'
    | 'wheat'
    | 'corn'
    | 'soybean'
    | 'cotton'
    | 'vegetable'
    | 'fruit';

export interface FarmData {
    id?: string;
    name: string;
    location: GeoLocation;
    crops: Crop[];
    totalAcreage: number;
    soilType?: string;
    waterSource?: string;
}
</file>

<file path="types/products.ts">
export type ProductCategory = 'Biocontrol' | 'Biofertilizer' | 'Biostimulant';

export interface Product {
    id: string;
    name: string;
    category: ProductCategory;
    type: string;
    description: string;
    applicationMethod: string;
    compatibleCrops: string[];
    dosageRate: Record<string, string>;
    applicationTiming: Record<string, string>;
    effectivenessRating: number; // 1-10 scale
    roiRating: number; // Return on investment rating
    imageUrl?: string;
}

export interface ApplicationSchedule {
    productId: string;
    day: number;
    cropType: string;
    dosage: string;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="app/api/environmental-data/route.ts">
import { NextRequest, NextResponse } from 'next/server';

// Define interfaces for API responses
interface CEHubResponse {
    success: boolean;
    data: any;
    error?: string;
}

interface WeatherData {
    forecast: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: any;
}

/**
 * Environmental data API route handler
 * Fetches weather forecast and soil data from CE Hub API
 */
export async function GET(request: NextRequest) {
    const searchParams = request.nextUrl.searchParams;
    const lat = searchParams.get('lat');
    const lng = searchParams.get('lng');
    const type = searchParams.get('type') || 'forecast';
    const startDate = searchParams.get('startDate') || new Date().toISOString().split('T')[0];
    const endDate = searchParams.get('endDate') || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    // Validate required parameters
    if (!lat || !lng) {
        return NextResponse.json(
            { error: 'Missing required parameters: lat and lng' },
            { status: 400 }
        );
    }

    try {
        // Get API config based on endpoint type
        let apiUrl, apiKey, apiEndpoint, requestBody, requestMethod = 'GET';
        let headers: Record<string, string> = { 'Content-Type': 'application/json' };

        // Configure API parameters based on request type
        if (type === 'forecast') {
            // FORECAST API CONFIGURATION
            apiUrl = process.env.CE_HUB_FORECAST_API_URL;
            apiKey = process.env.CE_HUB_FORECAST_API_KEY;

            if (!apiUrl || !apiKey) {
                console.log('Forecast API config missing, using mock data');
                return NextResponse.json(await getMockData(type, lat, lng, startDate, endDate));
            }

            console.log(`Forecast API config: ${apiUrl} ${apiKey}`);
            headers['ApiKey'] = apiKey;

            // Match Postman example for Forecast API path
            apiEndpoint = `${apiUrl}/api/Forecast/ShortRangeForecastDaily?latitude=${lat}&longitude=${lng}&startDate=${startDate}&endDate=${endDate}&supplier=Meteoblue&measureLabel=TempAir_DailyMax;TempAir_DailyMin;TempAir_DailyAvg;Precip_DailySum;HumidityRel_DailyAvg;WindSpeed_DailyAvg;GlobalRadiation_DailySum&format=json`;
        }
        else if (type === 'historical') {
            // HISTORICAL API CONFIGURATION
            apiUrl = process.env.CE_HUB_HISTORICAL_API_URL;
            apiKey = process.env.CE_HUB_HISTORICAL_API_KEY;

            if (!apiUrl || !apiKey) {
                console.log('Historical API config missing, using mock data');
                return NextResponse.json(await getMockData(type, lat, lng, startDate, endDate));
            }

            console.log(`Historical API config: ${apiUrl} ${apiKey}`);

            // For historical API, key goes in URL
            apiEndpoint = `${apiUrl}?apikey=${apiKey}`;
            requestMethod = 'POST';

            // Match Postman example for Historical API
            requestBody = {
                units: {
                    temperature: "C",
                    velocity: "km/h", // Changed from m/s to match Postman example
                    length: "metric",
                    energy: "watts"
                },
                geometry: {
                    type: "MultiPoint", // Changed from Point to match Postman
                    coordinates: [[parseFloat(lng), parseFloat(lat)]],
                    locationNames: ["Location"],
                    mode: "preferLandWithMatchingElevation"
                },
                format: "json",
                timeIntervals: [`${startDate}T+00:00/${endDate}T+00:00`],
                timeIntervalsAlignment: "none",
                queries: [
                    {
                        domain: "ERA5T", // Matches Postman example
                        gapFillDomain: "NEMSGLOBAL",
                        timeResolution: "daily",
                        codes: [
                            {
                                code: 11,
                                level: "2 m above gnd",
                                aggregation: "mean"
                            }
                        ]
                    },
                    {
                        domain: "ERA5T",
                        gapFillDomain: "NEMSGLOBAL",
                        timeResolution: "daily",
                        codes: [
                            {
                                code: 61,
                                level: "sfc",
                                aggregation: "sum"
                            }
                        ]
                    }
                ]
            };
        }
        else if (type === 'soil') {
            // SOIL API CONFIGURATION
            apiUrl = process.env.CE_HUB_HISTORICAL_API_URL;
            apiKey = process.env.CE_HUB_HISTORICAL_API_KEY;

            if (!apiUrl || !apiKey) {
                console.log('Soil API config missing, using mock data');
                return NextResponse.json(await getMockData(type, lat, lng, startDate, endDate));
            }

            console.log(`Soil API config: ${apiUrl} ${apiKey}`);

            // For soil API, key goes in URL
            apiEndpoint = `${apiUrl}?apikey=${apiKey}`;
            requestMethod = 'POST';

            // Match Postman example for Soil API exactly
            requestBody = {
                units: {
                    temperature: "C",
                    velocity: "km/h",
                    length: "metric",
                    energy: "watts"
                },
                geometry: {
                    type: "MultiPoint",
                    coordinates: [[parseFloat(lng), parseFloat(lat)]],
                    locationNames: ["Location"],
                    mode: "preferLandWithMatchingElevation"
                },
                format: "json",
                timeIntervals: [`${startDate}T+00:00/${endDate}T+00:00`],
                timeIntervalsAlignment: "none",
                queries: [
                    {
                        domain: "SOILGRIDS1000", // Critical: Correct domain from Postman
                        gapFillDomain: null,
                        timeResolution: "static",
                        codes: [
                            { code: 812, level: "5 cm" } // Specific soil code from Postman
                        ]
                    },
                    {
                        domain: "SOILGRIDS1000",
                        gapFillDomain: null,
                        timeResolution: "static",
                        codes: [
                            { code: 806, level: "0 cm" } // Specific soil code from Postman
                        ]
                    },
                    {
                        domain: "WISE30",
                        gapFillDomain: null,
                        timeResolution: "static",
                        codes: [
                            { code: 831, level: "0-20 cm" } // Additional soil property
                        ]
                    }
                ]
            };
        }
        else {
            return NextResponse.json(
                { error: `Unsupported data type: ${type}` },
                { status: 400 }
            );
        }

        // Make request to CE Hub API with enhanced logging
        console.log(`Making ${requestMethod} request to: ${apiEndpoint.split('?')[0]}`);

        const response = requestMethod === 'GET'
            ? await fetch(apiEndpoint, { headers })
            : await fetch(apiEndpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify(requestBody)
            });

        console.log(`CE Hub API response: ${response.status} ${response.statusText}`);

        // Handle different response statuses appropriately
        let responseData;

        if (response.status === 204) {
            // Handle No Content responses
            console.log('Received 204 No Content response - using empty data set');
            responseData = { data: [] };
        }
        else if (!response.ok) {
            // Try to get error details for better diagnostics
            let errorDetails = '';
            try {
                const errorText = await response.text();
                errorDetails = errorText.substring(0, 200);
                console.error(`API Error response details: ${errorDetails}`);
            } catch (readError) {
                console.error('Could not read error response body');
            }

            // Throw appropriate error based on status code
            if (response.status === 401 || response.status === 403) {
                throw new Error(`Authentication failed for CE Hub ${type} API: Invalid API key`);
            } else if (response.status === 400) {
                throw new Error(`Invalid request to CE Hub ${type} API: Bad Request - ${errorDetails || 'Check parameters'}`);
            } else if (response.status === 404) {
                throw new Error(`Endpoint not found for CE Hub ${type} API: Check URL configuration`);
            } else {
                throw new Error(`CE Hub API responded with ${response.status}: ${response.statusText}`);
            }
        }
        else {
            // Process successful responses
            try {
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    responseData = await response.json();
                } else {
                    console.log(`Non-JSON response received: ${contentType}`);
                    const textResponse = await response.text();
                    console.log(`Response preview: ${textResponse.substring(0, 100)}...`);
                    responseData = { data: [] };
                }
            } catch (parseError) {
                console.error('Error parsing response:', parseError);
                responseData = { data: [] };
            }
        }

        // Process the data based on the type
        const processedData = processApiResponse(type, responseData);
        console.log(`Successfully processed ${type} data`);

        return NextResponse.json(processedData);
    } catch (error) {
        console.error('Error fetching environmental data:', error);

        // Return mock data if API request fails
        const mockData = await getMockData(type, lat, lng, startDate, endDate);
        return NextResponse.json(mockData);
    }
}

/**
 * Process the API response based on the type of data requested
 */
function processApiResponse(type: string, responseData: any) {
    // First check if we have valid data to process
    const hasValidData = responseData &&
        responseData.data &&
        Array.isArray(responseData.data) &&
        responseData.data.length > 0;

    if (!hasValidData) {
        console.log(`API returned empty or invalid data for ${type}, using mock data instead`);
        // Generate mock data based on type
        return getMockDataSync(type);
    }

    switch (type) {
        case 'forecast':
            // Extract and format forecast data from the response
            const dailyData = responseData.data.map((item: any) => ({
                date: item.date || new Date().toISOString().split('T')[0],
                temperature: {
                    max: item.TempAir_DailyMax ?? (20 + Math.random() * 10),
                    min: item.TempAir_DailyMin ?? (10 + Math.random() * 5),
                    avg: item.TempAir_DailyAvg ?? (15 + Math.random() * 7)
                },
                precipitation: item.Precip_DailySum ?? (Math.random() > 0.7 ? Math.random() * 10 : 0),
                humidity: item.HumidityRel_DailyAvg ?? (50 + Math.random() * 30),
                windSpeed: item.WindSpeed_DailyAvg ?? (2 + Math.random() * 6),
                globalRadiation: item.GlobalRadiation_DailySum ?? (5000 + Math.random() * 3000)
            }));

            // If mapped data is empty, fall back to mock
            if (dailyData.length === 0) {
                console.log('Mapped forecast data is empty, using mock data');
                return getMockDataSync('forecast');
            }

            return {
                forecast: {
                    daily: dailyData
                }
            };

        case 'historical':
        // [Similar implementation for historical data]
        // ...

        case 'soil':
        // [Similar implementation for soil data]
        // ...

        default:
            return responseData;
    }
}

/**
 * Synchronous version of getMockData for use within processApiResponse
 */
function getMockDataSync(type: string): any {
    const today = new Date();
    const startDate = today.toISOString().split('T')[0];
    const endDate = new Date(today.setDate(today.getDate() + 7)).toISOString().split('T')[0];

    switch (type) {
        case 'forecast':
            return generateMockForecast(startDate, endDate);
        case 'historical':
            return generateMockHistorical(startDate, endDate);
        case 'soil':
            // Use a default location when no coordinates are available
            return generateMockSoil('15', '75');
        default:
            return { error: "Unknown data type requested" };
    }
}

/**
 * Helper to get the first data value from a dataset
 */
/**
 * Helper to get the first data value from a dataset
 */
function getFirstDataValue(dataset: any): number | null {
    if (!dataset) {
        console.warn('Dataset not found in response, using randomized mock value');
        // Return a reasonable mock value instead of null
        return Math.random() * 10;
    }

    if (!dataset.data || !dataset.data.length) {
        console.warn(`Dataset ${dataset?.domain || 'unknown'}/${dataset?.code || 'unknown'} has no data points, using randomized mock value`);
        return Math.random() * 10;
    }

    // Handle the case where value might be null or not a number
    const value = dataset.data[0].value;
    if (value === null || value === undefined || typeof value !== 'number') {
        console.warn(`Invalid value type in dataset ${dataset.domain}/${dataset.code}, using randomized mock value`);
        return Math.random() * 10;
    }

    return value;
}

/**
 * Get the soil texture description based on the value
 */
function getSoilTextureDescription(textureValue: number | null): string {
    if (textureValue === null) return "Unknown";

    // Soil texture classification mapping
    const textureClassMap: { [key: number]: string } = {
        1: "Clay (Cl)",
        2: "Silty Clay (SiCl)",
        3: "Sandy Clay (SaCl)",
        4: "Clay Loam (ClLo)",
        5: "Silty Clay Loam (SiClLo)",
        6: "Sandy Clay Loam (SaClLo)",
        7: "Loam (Lo)",
        8: "Silty Loam (SiLo)",
        9: "Sandy Loam (SaLo)",
        10: "Silt (Si)",
        11: "Loamy Sand (LoSa)",
        12: "Sand (Sa)"
    };

    return textureClassMap[textureValue] || "Unknown";
}

/**
 * Get mock data for development and testing
 */
async function getMockData(type: string, lat: string, lng: string, startDate: string, endDate: string): Promise<any> {
    // Generate realistic mock data based on type and params
    switch (type) {
        case 'forecast':
            return generateMockForecast(startDate, endDate);
        case 'historical':
            return generateMockHistorical(startDate, endDate);
        case 'soil':
            return generateMockSoil(lat, lng);
        default:
            return { error: "Unknown data type requested" };
    }
}

/**
 * Generate mock forecast data
 */
function generateMockForecast(startDate: string, endDate: string) {
    const start = new Date(startDate);
    const end = new Date(endDate);
    const days = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));

    const dailyData = [];

    for (let i = 0; i < days; i++) {
        const currentDate = new Date(start);
        currentDate.setDate(start.getDate() + i);

        // Generate somewhat realistic weather data with some variability
        const baseTemp = 25 + Math.sin(i / 3) * 5; // Oscillating temperature pattern

        dailyData.push({
            date: currentDate.toISOString().split('T')[0],
            temperature: {
                max: baseTemp + Math.random() * 3,
                min: baseTemp - 10 + Math.random() * 3,
                avg: baseTemp - 5 + Math.random() * 2
            },
            precipitation: Math.random() > 0.7 ? Math.random() * 10 : 0, // 30% chance of rain
            humidity: 50 + Math.random() * 30,
            windSpeed: 2 + Math.random() * 6,
            globalRadiation: 5000 + Math.random() * 3000
        });
    }

    return {
        forecast: {
            daily: dailyData
        }
    };
}

/**
 * Generate mock historical data
 */
function generateMockHistorical(startDate: string, endDate: string) {
    // Simple mock historical data
    return {
        historical: {
            temperature: {
                avg: 24.5,
                max: 35.2,
                min: 15.1
            },
            precipitation: {
                annual: 850,
                monthly: [45, 60, 75, 90, 120, 65, 45, 35, 70, 95, 85, 65]
            }
        }
    };
}

/**
 * Generate mock soil data
 */
function generateMockSoil(lat: string, lng: string) {
    // Generate mock soil data based on coordinates
    // This is very simplified - real soil data would be much more complex
    const latNum = parseFloat(lat);
    const lngNum = parseFloat(lng);

    // Use coordinates to deterministically generate different soil types
    // This creates a simple pattern across different locations
    const soilTextureIndex = Math.floor((Math.abs(latNum * 10) + Math.abs(lngNum * 10)) % 12) + 1;

    const soilTextureMap: { [key: number]: string } = {
        1: "Clay (Cl)",
        2: "Silty Clay (SiCl)",
        3: "Sandy Clay (SaCl)",
        4: "Clay Loam (ClLo)",
        5: "Silty Clay Loam (SiClLo)",
        6: "Sandy Clay Loam (SaClLo)",
        7: "Loam (Lo)",
        8: "Silty Loam (SiLo)",
        9: "Sandy Loam (SaLo)",
        10: "Silt (Si)",
        11: "Loamy Sand (LoSa)",
        12: "Sand (Sa)"
    };

    return {
        soil: {
            texture: soilTextureMap[soilTextureIndex],
            properties: {
                bulkDensity: 1.2 + Math.random() * 0.4,
                organicMatter: 1 + Math.random() * 3,
                ph: 5.5 + Math.random() * 2.5,
                waterHoldingCapacity: 0.1 + Math.random() * 0.2,
                cationExchangeCapacity: 5 + Math.random() * 15
            }
        }
    };
}
</file>

<file path="components/farm/CropSelector.tsx">
"use client";

import React, { useState } from 'react';
import { Crop, CropType } from '@/types/farm';
import { Button } from '@/components/ui/Button';

interface CropSelectorProps {
    crops: Crop[];
    onChange: (crops: Crop[]) => void;
    totalFarmSize: number;
    className?: string;
}

// Crop type options with metadata
const cropOptions: Array<{
    value: CropType;
    label: string;
    description: string;
    icon: string;
}> = [
        {
            value: 'rice',
            label: 'Rice',
            description: 'Thrives in warm, wet conditions with high rainfall',
            icon: 'üåæ',
        },
        {
            value: 'wheat',
            label: 'Wheat',
            description: 'Adaptable to various climates, requires moderate rainfall',
            icon: 'üåø',
        },
        {
            value: 'corn',
            label: 'Corn',
            description: 'Needs warm soil and plenty of sunshine',
            icon: 'üåΩ',
        },
        {
            value: 'soybean',
            label: 'Soybean',
            description: 'Fixes nitrogen, grows well in warm climates',
            icon: 'üå±',
        },
        {
            value: 'cotton',
            label: 'Cotton',
            description: 'Requires long, frost-free periods and plenty of sunshine',
            icon: 'üß∂',
        },
        {
            value: 'vegetable',
            label: 'Vegetables',
            description: 'Various vegetable crops with different requirements',
            icon: 'ü•¶',
        },
        {
            value: 'fruit',
            label: 'Fruit',
            description: 'Tree and shrub fruits typically requiring good drainage',
            icon: 'üçé',
        },
    ];

export default function CropSelector({
    crops,
    onChange,
    totalFarmSize,
    className = '',
}: CropSelectorProps) {
    const [validationError, setValidationError] = useState<string | null>(null);

    // Calculate total acreage currently allocated
    const allocatedAcreage = crops.reduce((sum, crop) => sum + crop.acreage, 0);
    const remainingAcreage = totalFarmSize - allocatedAcreage;

    // Function to add a new crop
    const handleAddCrop = () => {
        // Default to first available crop type not yet selected
        const usedCropTypes = crops.map(crop => crop.type);
        const availableCropType = cropOptions.find(
            option => !usedCropTypes.includes(option.value)
        )?.value || cropOptions[0].value;

        const newCrop: Crop = {
            id: `crop_${Date.now()}`,
            name: `New ${cropOptions.find(c => c.value === availableCropType)?.label || 'Crop'}`,
            type: availableCropType,
            acreage: Math.min(1, remainingAcreage) // Use remaining acreage or 1, whichever is smaller
        };

        if (remainingAcreage <= 0) {
            setValidationError('Cannot add more crops. Increase farm size or reduce other crop acreages.');
            return;
        }

        onChange([...crops, newCrop]);
        setValidationError(null);
    };

    // Function to remove a crop
    const handleRemoveCrop = (cropId: string) => {
        onChange(crops.filter(crop => crop.id !== cropId));
        setValidationError(null);
    };

    // Function to update a crop
    const handleCropChange = (index: number, updatedCrop: Partial<Crop>) => {
        const newCrops = [...crops];
        newCrops[index] = { ...newCrops[index], ...updatedCrop };

        // Validate acreage
        const totalAcreage = newCrops.reduce((sum, crop) => sum + crop.acreage, 0);
        if (totalAcreage > totalFarmSize) {
            setValidationError(`Total acreage (${totalAcreage}) exceeds farm size (${totalFarmSize})`);
            // Still update the state, but with the validation error
        } else {
            setValidationError(null);
        }

        onChange(newCrops);
    };

    return (
        <div className={`space-y-4 ${className}`}>
            <div className="flex justify-between items-center">
                <h3 className="text-lg font-medium">Crops ({crops.length})</h3>
                <div className="text-sm text-gray-500">
                    Acreage: {allocatedAcreage} / {totalFarmSize}
                    ({remainingAcreage >= 0 ? `${remainingAcreage} available` : `${Math.abs(remainingAcreage)} over limit`})
                </div>
            </div>

            {validationError && (
                <div className="p-3 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
                    {validationError}
                </div>
            )}

            <div className="space-y-3">
                {crops.map((crop, index) => (
                    <div
                        key={crop.id}
                        className="p-4 border rounded-lg bg-white shadow-sm flex flex-col sm:flex-row gap-4"
                    >
                        <div className="flex-1 space-y-4">
                            <div>
                                <label htmlFor={`crop-type-${index}`} className="block text-sm font-medium text-gray-700 mb-1">
                                    Crop Type
                                </label>
                                <select
                                    id={`crop-type-${index}`}
                                    value={crop.type}
                                    onChange={(e) => handleCropChange(index, { type: e.target.value as CropType })}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                                >
                                    {cropOptions.map(option => (
                                        <option key={option.value} value={option.value}>
                                            {option.icon} {option.label}
                                        </option>
                                    ))}
                                </select>
                                <p className="mt-1 text-xs text-gray-500">
                                    {cropOptions.find(c => c.value === crop.type)?.description}
                                </p>
                            </div>
                        </div>

                        <div className="flex flex-row sm:flex-col justify-between items-center sm:items-end space-y-0 sm:space-y-4">
                            <div className="w-full max-w-[120px]">
                                <label htmlFor={`crop-acreage-${index}`} className="block text-sm font-medium text-gray-700 mb-1">
                                    Acreage
                                </label>
                                <input
                                    id={`crop-acreage-${index}`}
                                    type="number"
                                    min="0.1"
                                    step="0.1"
                                    value={crop.acreage}
                                    onChange={(e) => handleCropChange(index, { acreage: parseFloat(e.target.value) || 0 })}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                                />
                            </div>

                            <Button
                                variant="destructive"
                                size="sm"
                                onClick={() => handleRemoveCrop(crop.id)}
                                className="mt-4 sm:mt-0"
                                aria-label={`Remove ${crop.name}`}
                            >
                                Remove
                            </Button>
                        </div>
                    </div>
                ))}
            </div>

            <Button
                variant="outline"
                onClick={handleAddCrop}
                disabled={remainingAcreage <= 0}
                className="w-full"
            >
                + Add Crop
            </Button>

            {crops.length === 0 && (
                <div className="text-center p-8 border border-dashed rounded-lg">
                    <p className="text-gray-500">No crops added yet. Click the button above to add your first crop.</p>
                </div>
            )}
        </div>
    );
}
</file>

<file path="components/farm/FarmSetupWizard.tsx">
"use client";

import React, { useState } from 'react';
import { FarmData, Crop, GeoLocation } from '@/types/farm';
import { Card } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import LocationPicker from '@/components/farm/LocationPicker';
import CropSelector from '@/components/farm/CropSelector';
import { useFarmData } from '@/lib/hooks/useFarmData';
import { useRouter } from 'next/navigation';

// Define the steps in our wizard - reduced to 3 substantive steps plus completion
enum SetupStep {
  LOCATION = 0,
  FARM_INFO = 1,
  CROPS = 2,
  COMPLETE = 3  // Now the 4th state (index 3) instead of 5th
}

interface StepIndicatorProps {
  currentStep: SetupStep;
  totalSteps: number;
}

// A simple step indicator component
function StepIndicator({ currentStep, totalSteps }: StepIndicatorProps) {
  return (
    <div className="flex items-center justify-center mb-8">
      {Array.from({ length: totalSteps }).map((_, index) => (
        <React.Fragment key={index}>
          <div 
            className={`w-8 h-8 rounded-full flex items-center justify-center
              ${index <= currentStep ? 'bg-green-600 text-white' : 'bg-gray-200 text-gray-600'}`}
          >
            {index + 1}
          </div>
          {index < totalSteps - 1 && (
            <div 
              className={`h-1 w-12 mx-1 
              ${index < currentStep ? 'bg-green-600' : 'bg-gray-200'}`}
            />
          )}
        </React.Fragment>
      ))}
    </div>
  );
}

export default function FarmSetupWizard() {
  const [currentStep, setCurrentStep] = useState<SetupStep>(SetupStep.LOCATION);
  const [showEnvironmentalData, setShowEnvironmentalData] = useState(false);
  const router = useRouter();
  
  const {
    farmData,
    isLoading,
    updateFarmName,
    updateFarmLocation,
    updateFarmSize,
    updateFarmCrops,
    saveFarm,
    error
  } = useFarmData();

  // Handle location selection and move to next step
  const handleLocationSelected = () => {
    if (farmData.location.lat !== 0 && farmData.location.lng !== 0) {
      setShowEnvironmentalData(true);
      setCurrentStep(SetupStep.FARM_INFO);
    }
  };

  // Handle farm info update and move to next step
  const handleFarmInfoSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setCurrentStep(SetupStep.CROPS);
  };
  
  // Handle crops setup and move directly to completion (skipping analysis)
  const handleCropsSubmit = () => {
    // Save farm data and proceed to completion
    saveFarm();
    setCurrentStep(SetupStep.COMPLETE);
    
    // Navigate to simulation after a brief delay
    setTimeout(() => {
      router.push('/simulation');
    }, 1000);
  };

  // Go back to previous step
  const handleBack = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  if (isLoading) {
    return (
      <Card className="p-6 max-w-3xl mx-auto">
        <div className="text-center py-12">
          <div className="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500 mb-4"></div>
          <p>Loading farm data...</p>
        </div>
      </Card>
    );
  }

  // For step 1: Location Selection
  if (currentStep === SetupStep.LOCATION) {
    return (
      <Card className="p-6 max-w-3xl mx-auto">
        <StepIndicator currentStep={currentStep} totalSteps={3} />
        <h2 className="text-2xl font-bold mb-6 text-center">Where is your farm located?</h2>
        <p className="text-gray-600 mb-6 text-center">
          Select your farm's location to get accurate environmental data and recommendations
        </p>
        
        <div className="space-y-6">
          <LocationPicker
            value={farmData.location}
            onChange={updateFarmLocation}
            className="w-full"
          />
          
          <div className="flex justify-end mt-6">
            <Button
              variant="primary"
              size="lg"
              onClick={handleLocationSelected}
              disabled={farmData.location.lat === 0 || farmData.location.lng === 0}
            >
              Continue
            </Button>
          </div>
        </div>
      </Card>
    );
  }

  // For step 2: Farm Information
  if (currentStep === SetupStep.FARM_INFO) {
    return (
      <Card className="p-6 max-w-3xl mx-auto">
        <StepIndicator currentStep={currentStep} totalSteps={3} />
        <h2 className="text-2xl font-bold mb-6 text-center">Tell us about your farm</h2>
        
        <form onSubmit={handleFarmInfoSubmit} className="space-y-6">
          <div>
            <label htmlFor="acreage" className="block text-sm font-medium text-gray-700 mb-1">
              Total Farm Size (acres)
            </label>
            <input
              type="number"
              id="acreage"
              value={farmData.totalAcreage}
              onChange={(e) => updateFarmSize(parseFloat(e.target.value))}
              min="1"
              step="0.1"
              className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
              required
            />
          </div>

          <div className="flex justify-between mt-6">
            <Button
              type="button"
              variant="outline"
              onClick={handleBack}
            >
              Back
            </Button>
            <Button
              type="submit"
              variant="primary"
              size="lg"
            >
              Continue
            </Button>
          </div>
        </form>
      </Card>
    );
  }

  // For step 3: Crop Selection - now leads directly to completion
  if (currentStep === SetupStep.CROPS) {
    return (
      <Card className="p-6 max-w-3xl mx-auto">
        <StepIndicator currentStep={currentStep} totalSteps={3} />
        <h2 className="text-2xl font-bold mb-6 text-center">What crops do you grow?</h2>
        <p className="text-gray-600 mb-6 text-center">
          Add the crops you're growing and their approximate acreage
        </p>
        
        <div className="space-y-6">
          <CropSelector
            crops={farmData.crops}
            onChange={updateFarmCrops}
            totalFarmSize={farmData.totalAcreage}
          />
          
          {error && (
            <div className="p-3 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
              {error}
            </div>
          )}
          
          <div className="flex justify-between mt-6">
            <Button
              variant="outline"
              onClick={handleBack}
            >
              Back
            </Button>
            <Button
              variant="primary"
              size="lg"
              onClick={handleCropsSubmit}
              disabled={farmData.crops.length === 0 || !!error}
            >
              Start Simulation
            </Button>
          </div>
        </div>
      </Card>
    );
  }

  // For completion step
  if (currentStep === SetupStep.COMPLETE) {
    return (
      <Card className="p-6 max-w-3xl mx-auto">
        <div className="text-center py-12">
          <div className="inline-block text-green-500 text-5xl mb-4">‚úì</div>
          <h2 className="text-2xl font-bold mb-4">Setup Complete!</h2>
          <p className="text-gray-600 mb-8">Redirecting to the simulation...</p>
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500 mx-auto"></div>
        </div>
      </Card>
    );
  }

  // Default fallback (shouldn't reach here)
  return null;
}
</file>

<file path="components/ui/HeroSection.tsx">
"use client";

import React from 'react';
import Image from 'next/image';
import Navbar from './Navbar';

interface HeroSectionProps {
    onGetStarted: () => void;
}

export default function HeroSection({ onGetStarted }: HeroSectionProps) {
    return (
        <>
            {/* Full viewport background container */}
            <div className="fixed inset-0 z-0">
                <Image
                    src="/images/farm-hero.png"
                    alt="Sustainable farming landscape"
                    fill
                    priority
                    className="object-cover"
                />
                {/* Gradient overlay for text readability */}
                <div className="absolute inset-0 bg-black/20"></div>
            </div>

            {/* Header bar - positioned absolutely to maintain its position */}
            <Navbar />

            {/* Main content container - positioned absolutely to maintain layout */}
            <div className="fixed inset-0 z-5 flex items-center justify-center pt-16">
                <div className="text-center px-4 py-8 max-w-3xl mx-auto">
                    <h1 className="text-5xl font-bold text-white mb-6">
                        Nature helps nature
                    </h1>
                    <h2 className="text-2xl md:text-3xl text-white mb-8">
                        Use AI to improve global farming through nature-powered innovation
                    </h2>

                    <div className="backdrop-blur-sm bg-white/10 rounded-xl p-6 mb-10 border border-white/20">
                        <p className="text-lg text-white mb-8">
                            Our AI-powered Farm Bio-Boost Simulator helps you visualize environmental risks,
                            recommend biological products for your specific crops, and track outcomes to
                            improve yields sustainably.
                        </p>

                        {/* Get Started button */}
                        <button
                            onClick={onGetStarted}
                            className="inline-flex items-center bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full transition-all shadow-lg"
                        >
                            Get Started
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </>
    );
}
</file>

<file path="package.json">
{
  "name": "start-hack",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "leaflet": "^1.9.4",
    "next": "15.2.3",
    "react": "19.0.0-rc.1",
    "react-dom": "19.0.0-rc.1",
    "react-leaflet": "5.0.0-rc.2",
    "three": "^0.152.2",
    "@react-three/fiber": "^8.13.3",
    "@react-three/drei": "^9.77.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/leaflet": "^1.9.16",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.152.1",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

body {
  background: var(--background);
  color: var(--foreground);
}

button,
a, select {
  cursor: pointer;
}

@layer base {
  h1 {
    @apply text-3xl font-bold;
  }
  h2 {
    @apply text-2xl font-bold;
  }
  h3 {
    @apply text-xl font-bold;
  }
}

@keyframes shine {
  from {
    left: -100%;
  }
  to {
    left: 200%;
  }
}

.animate-shine {
  animation: shine 1.5s ease-in-out infinite;
}

main {
  background-image: src("images/farm-hero.jpg");
}

@keyframes grow {
  0% {
    transform: scale(0.1);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes sway {
  0% {
    transform: rotate(0deg);
  }
  25% {
    transform: rotate(2deg);
  }
  75% {
    transform: rotate(-2deg);
  }
  100% {
    transform: rotate(0deg);
  }
}

@keyframes fall {
  0% {
    transform: translateY(-10px);
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateY(100px);
    opacity: 0;
  }
}

@keyframes float {
  0% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
  100% {
    transform: translateY(0px);
  }
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

.crop-seedling {
  animation: grow 2s ease-out forwards;
}

.crop-growing {
  animation: sway 4s ease-in-out infinite;
}

.crop-mature {
  animation: sway 6s ease-in-out infinite;
}

.crop-harvesting {
  animation: pulse 2s ease-in-out infinite;
}

.weather-rain {
  animation: fall 1.5s linear infinite;
}

.notification {
  animation: float 2s ease-in-out;
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/ui/Navbar';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
    title: 'Farm Bio-Boost Simulator',
    description: 'Simulate the effects of biological products on crop performance',
};

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="en">
            <body className={`${inter.className} bg-gray-50 min-h-screen`}>
                <Navbar />
                <main className="container mx-auto">{children}</main>
            </body>
        </html>
    );
}
</file>

<file path="app/page.tsx">
"use client";

import React, { useState } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/Button';
import HeroSection from '@/components/ui/HeroSection';
import FarmSetupWizard from '@/components/farm/FarmSetupWizard';
import Image from 'next/image';

export default function HomePage() {
    const [showWizard, setShowWizard] = useState(false);

    const handleGetStarted = () => {
        setShowWizard(true);
        // Smooth scroll to the wizard section
        setTimeout(() => {
            document.getElementById('setup-wizard')?.scrollIntoView({ 
                behavior: 'smooth' 
            });
        }, 100);
    };

    return (
        <div className="relative min-h-screen">
            {/* Persistent Background Container */}
            <div className="fixed inset-0 z-0">
                <Image
                    src="/images/farm-hero.jpg"
                    alt="Sustainable farming landscape"
                    fill
                    priority
                    className="object-cover"
                />
                {/* Gradient overlay for text readability */}
                <div className="absolute inset-0 bg-black/40"></div>
            </div>

            {/* Header Bar */}
            <div className="fixed top-0 left-0 right-0 z-10 bg-green-500 py-3 px-4">
                <div className="container mx-auto max-w-5xl flex justify-between items-center">
                    <div className="flex items-center">
                        <span className="text-white font-bold text-xl">Farm Bio-Boost</span>
                        <span className="text-white ml-2">Simulator</span>
                    </div>
                {/* Powered by Syngenta */}
                <div className="flex items-center text-sm text-gray-600">
                    <span className="mr-2">Powered by</span>
                    <Image
                        src="/images/syngenta-logo.png"
                        alt="Syngenta"
                        width={100}
                        height={30}
                        className="w-auto"
                    />
                </div>
                </div>
            </div>

            {/* Content Container */}
            <div className="relative z-5 pt-16 min-h-screen">
                <div className="container mx-auto max-w-5xl">
                    {/* Show the hero section if we're not in wizard mode */}
                    {!showWizard && (
                        <div className="flex items-center justify-center min-h-[calc(100vh-4rem)]">
                            <HeroSection onGetStarted={handleGetStarted} />
                        </div>
                    )}

                    {/* Show the wizard when the user clicks "Get Started" */}
                    {showWizard && (
                        <div id="setup-wizard" className="pt-4 pb-12">
                            <FarmSetupWizard />
                            
                            <div className="text-center mt-8">
                                <button 
                                    onClick={() => setShowWizard(false)}
                                    className="text-white hover:text-gray-200 text-sm underline"
                                >
                                    Return to home page
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}
</file>

</files>
