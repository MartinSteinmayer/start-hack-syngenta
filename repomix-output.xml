This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  api/
    environmental-data/
      route.ts
    products/
      route.ts
    satellite-proxy/
      route.ts
  simulation/
    components/
      LocationInput.tsx
      SeasonTimelineControls.tsx
      WeatherInfo.tsx
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  farm/
    CropSelector.tsx
    CropStressAnalysis.tsx
    FarmReviewStep.tsx
    FarmSetupWizard.tsx
    FarmShapeStep.tsx
    FarmSizeStep.tsx
    LocationInputWithMap.tsx
    LocationPicker.tsx
    MapComponent.tsx
  styles/
    Navbar.css
  ui/
    Button.tsx
    Card.tsx
    HeroSection.tsx
    Navbar.tsx
lib/
  crops/
    constants.ts
    corn.ts
    cotton.ts
    index.ts
    rice.ts
    soybean.ts
    wheat.ts
  data/
    products.json
  environment/
    clouds.ts
    index.ts
    skybox.ts
    terrain.ts
  hooks/
    useFarmData.ts
    useProducts.ts
  services/
    farmEnvironmentService.ts
    modelLoader.ts
  simulation/
    cameraUtils.ts
    fieldUtils.ts
    index.ts
    plantGrowth.ts
    sceneSetup.ts
    timeline.ts
    timelineControler.ts
  utils/
    coordinateUtils.ts
  weather/
    index.ts
    weatherService.tsx
public/
  data/
    mock-environment.json
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
types/
  farm.ts
  products.ts
  simulation.ts
.gitignore
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/satellite-proxy/route.ts">
import { NextRequest, NextResponse } from 'next/server';

/**
 * Satellite image proxy API route
 * This proxies requests to the Python satellite API to avoid CORS issues
 */
export async function POST(request: NextRequest) {
  try {
    // Get parameters from the request body
    const body = await request.json();
    const { latitude, longitude, hectares, start_date, end_date } = body;

    // Validate required parameters
    if (!latitude || !longitude) {
      return NextResponse.json(
        { error: 'Missing required parameters: latitude and longitude' },
        { status: 400 }
      );
    }

    // Construct the API endpoint URL with query parameters
    const apiUrl = 'http://localhost:5032/satellite';
    const params = new URLSearchParams({
      latitude: latitude.toString(),
      longitude: longitude.toString(),
      hectares: hectares ? hectares.toString() : '10',
      start_date: start_date || '2023-01-01',
      end_date: end_date || '2025-03-20'
    });

    console.log(`Proxying satellite image request to: ${apiUrl}?${params}`);

    // Make the request to the Python API
    const response = await fetch(`${apiUrl}?${params}`, {
      method: 'GET',
      // We're in node.js context here, so CORS doesn't apply
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Satellite API error: ${response.status} ${response.statusText}`, errorText);
      return NextResponse.json(
        { error: `Satellite API responded with ${response.status}: ${response.statusText}` },
        { status: response.status }
      );
    }

    // Get the content type to forward it correctly
    const contentType = response.headers.get('content-type') || 'image/png';
    
    // Get the image data as an array buffer
    const imageBuffer = await response.arrayBuffer();

    // Return the image with appropriate headers
    return new NextResponse(imageBuffer, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=3600',
      },
    });
  } catch (error: any) {
    console.error('Error proxying satellite image:', error);
    return NextResponse.json(
      { error: `Failed to fetch satellite image: ${error.message}` },
      { status: 500 }
    );
  }
}

/**
 * Handle OPTIONS requests for CORS preflight
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}
</file>

<file path="app/simulation/components/LocationInput.tsx">
// components/LocationInput.tsx
'use client'

import React, { useState, useEffect } from 'react';

interface LocationInputProps {
    onLocationChange: (latitude: number, longitude: number, locationName: string) => void;
    disabled?: boolean;
}

interface GeocodeResult {
    name: string;
    country: string;
    state?: string;
    lat: number;
    lon: number;
}

const LocationInput: React.FC<LocationInputProps> = ({ onLocationChange, disabled = false }) => {
    const [searchQuery, setSearchQuery] = useState('');
    const [latitude, setLatitude] = useState<number | null>(null);
    const [longitude, setLongitude] = useState<number | null>(null);
    const [locationName, setLocationName] = useState('');
    const [searchResults, setSearchResults] = useState<GeocodeResult[]>([]);
    const [isSearching, setIsSearching] = useState(false);
    const [error, setError] = useState('');
    const [showResults, setShowResults] = useState(false);

    // Optional: Get user's current location when component mounts
    useEffect(() => {
        if (navigator.geolocation && !disabled) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    setLatitude(position.coords.latitude);
                    setLongitude(position.coords.longitude);
                    // Reverse geocode to get location name
                    reverseGeocode(position.coords.latitude, position.coords.longitude);
                },
                (error) => {
                    console.error("Error getting location:", error);
                    // Set default location (e.g., Central USA)
                    setLatitude(39.8283);
                    setLongitude(-98.5795);
                    setLocationName('United States (default)');
                    onLocationChange(39.8283, -98.5795, 'United States (default)');
                }
            );
        } else if (!disabled) {
            // Geolocation not available, set default
            setLatitude(39.8283);
            setLongitude(-98.5795);
            setLocationName('United States (default)');
            onLocationChange(39.8283, -98.5795, 'United States (default)');
        }
    }, [disabled]);

    // Reverse geocode to get location name from coordinates
    const reverseGeocode = async (lat: number, lon: number) => {
        try {
            const response = await fetch(
                `https://api.openweathermap.org/geo/1.0/reverse?lat=${lat}&lon=${lon}&limit=1&appid=${process.env.NEXT_PUBLIC_OPENWEATHER_API_KEY}`
            );

            if (!response.ok) {
                throw new Error(`Geocoding API error: ${response.status}`);
            }

            const data = await response.json();

            if (data && data.length > 0) {
                const placeName = data[0].name;
                const country = data[0].country;
                const fullName = `${placeName}, ${country}`;

                setLocationName(fullName);
                onLocationChange(lat, lon, fullName);
            } else {
                setLocationName(`${lat.toFixed(4)}, ${lon.toFixed(4)}`);
                onLocationChange(lat, lon, `${lat.toFixed(4)}, ${lon.toFixed(4)}`);
            }
        } catch (error) {
            console.error("Error during reverse geocoding:", error);
            setLocationName(`${lat.toFixed(4)}, ${lon.toFixed(4)}`);
            onLocationChange(lat, lon, `${lat.toFixed(4)}, ${lon.toFixed(4)}`);
        }
    };

    // Search for location by name
    const searchLocation = async () => {
        if (!searchQuery.trim() || disabled) return;

        setIsSearching(true);
        setError('');

        try {
            const response = await fetch(
                `https://api.openweathermap.org/geo/1.0/direct?q=${encodeURIComponent(searchQuery)}&limit=5&appid=${process.env.NEXT_PUBLIC_OPENWEATHER_API_KEY}`
            );

            if (!response.ok) {
                throw new Error(`Geocoding API error: ${response.status}`);
            }

            const data = await response.json();

            if (data && data.length > 0) {
                const results: GeocodeResult[] = data.map((item: any) => ({
                    name: item.name,
                    country: item.country,
                    state: item.state,
                    lat: item.lat,
                    lon: item.lon
                }));

                setSearchResults(results);
                setShowResults(true);
            } else {
                setSearchResults([]);
                setError('No locations found. Try a different search term.');
            }
        } catch (error) {
            console.error("Error searching location:", error);
            setError('Error searching for location. Please try again.');
        } finally {
            setIsSearching(false);
        }
    };

    // Handle location selection from search results
    const selectLocation = (result: GeocodeResult) => {
        setLatitude(result.lat);
        setLongitude(result.lon);

        const locationString = result.state
            ? `${result.name}, ${result.state}, ${result.country}`
            : `${result.name}, ${result.country}`;

        setLocationName(locationString);
        setSearchQuery('');
        setShowResults(false);

        // Notify parent component
        onLocationChange(result.lat, result.lon, locationString);
    };

    // Handle manual entry of coordinates
    const handleManualCoordinates = () => {
        if (latitude !== null && longitude !== null) {
            reverseGeocode(latitude, longitude);
        }
    };

    return (
        <div className="bg-white p-4 rounded shadow-md">
            <h3 className="text-lg font-semibold mb-2">Location Settings</h3>

            {/* Search by place name */}
            <div className="mb-3">
                <label className="block text-sm font-medium mb-1">Search by place name:</label>
                <div className="flex">
                    <input
                        type="text"
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && searchLocation()}
                        placeholder="City name, country"
                        className="w-full p-2 border rounded-l"
                        disabled={disabled}
                    />
                    <button
                        onClick={searchLocation}
                        className="bg-blue-500 text-white px-3 rounded-r hover:bg-blue-600"
                        disabled={isSearching || disabled || !searchQuery.trim()}
                    >
                        {isSearching ? '...' : 'Search'}
                    </button>
                </div>

                {/* Search results dropdown */}
                {showResults && searchResults.length > 0 && (
                    <div className="absolute z-10 mt-1 w-64 bg-white border rounded shadow-lg">
                        {searchResults.map((result, index) => (
                            <div
                                key={index}
                                className="p-2 hover:bg-gray-100 cursor-pointer"
                                onClick={() => selectLocation(result)}
                            >
                                {result.name}, {result.state && `${result.state}, `}{result.country}
                            </div>
                        ))}
                    </div>
                )}

                {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
            </div>

            {/* Or enter coordinates manually */}
            <div className="mb-3">
                <label className="block text-sm font-medium mb-1">Or enter coordinates:</label>
                <div className="grid grid-cols-2 gap-2">
                    <div>
                        <input
                            type="number"
                            value={latitude !== null ? latitude : ''}
                            onChange={(e) => setLatitude(parseFloat(e.target.value) || null)}
                            placeholder="Latitude"
                            min="-90"
                            max="90"
                            step="0.0001"
                            className="w-full p-2 border rounded"
                            disabled={disabled}
                        />
                    </div>
                    <div>
                        <input
                            type="number"
                            value={longitude !== null ? longitude : ''}
                            onChange={(e) => setLongitude(parseFloat(e.target.value) || null)}
                            placeholder="Longitude"
                            min="-180"
                            max="180"
                            step="0.0001"
                            className="w-full p-2 border rounded"
                            disabled={disabled}
                        />
                    </div>
                </div>
                <button
                    onClick={handleManualCoordinates}
                    className="mt-2 bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600"
                    disabled={latitude === null || longitude === null || disabled}
                >
                    Set Location
                </button>
            </div>

            {/* Display current location */}
            {locationName && (
                <div className="mt-3 p-2 bg-gray-100 rounded">
                    <p className="text-sm font-medium">Current Location:</p>
                    <p>{locationName}</p>
                    <p className="text-xs text-gray-600">
                        Lat: {latitude?.toFixed(4)}, Lon: {longitude?.toFixed(4)}
                    </p>
                </div>
            )}
        </div>
    );
};

export default LocationInput;
</file>

<file path="app/simulation/components/WeatherInfo.tsx">
// components/WeatherInfo.tsx
'use client'

import React from 'react';

interface WeatherInfoProps {
    dayInfo: {
        date: Date;
        dateString: string;
        dayNumber: number;
        temperature: number;
        humidity: number;
        weather: string;
        growthPercent: number;
        growthStage: string;
    } | null;
    location?: {
        name: string;
        latitude: number;
        longitude: number;
    };
}

const WeatherInfo: React.FC<WeatherInfoProps> = ({ dayInfo, location }) => {
    // Helper function to get weather icon
    const getWeatherIcon = (weather: string) => {
        switch (weather) {
            case 'sunny': return '☀️';
            case 'partly_cloudy': return '⛅';
            case 'cloudy': return '☁️';
            case 'rainy': return '🌧️';
            case 'stormy': return '⛈️';
            default: return '☁️';
        }
    };

    // Helper function to get growth stage icon
    const getGrowthStageIcon = (stage: string) => {
        switch (stage) {
            case 'SEEDLING': return '🌱';
            case 'VEGETATIVE': return '🌿';
            case 'REPRODUCTIVE': return '🌾';
            case 'MATURE': return '🌽';
            default: return '🌱';
        }
    };

    // Helper function to get formatted weather name
    const getWeatherName = (weather: string) => {
        switch (weather) {
            case 'sunny': return 'Sunny';
            case 'partly_cloudy': return 'Partly Cloudy';
            case 'cloudy': return 'Cloudy';
            case 'rainy': return 'Rainy';
            case 'stormy': return 'Stormy';
            default: return weather;
        }
    };

    // No data available
    if (!dayInfo) {
        return (
            <div className="bg-gray-800 text-white p-3 rounded shadow-lg">
                <p className="text-center">Weather data not available</p>
            </div>
        );
    }

    return (
        <div className="bg-gray-800 text-white p-3 rounded shadow-lg">
            {/* Location information */}
            {location && (
                <div className="mb-2 pb-2 border-b border-gray-600">
                    <h3 className="text-sm font-bold">Location</h3>
                    <p className="text-sm">{location.name}</p>
                    <p className="text-xs text-gray-400">
                        Lat: {location.latitude.toFixed(4)}, Lon: {location.longitude.toFixed(4)}
                    </p>
                </div>
            )}

            {/* Weather information */}
            <div className="grid grid-cols-2 gap-2">
                <div className="text-center p-2 bg-gray-700 rounded">
                    <div className="text-xl mb-1">{getWeatherIcon(dayInfo.weather)}</div>
                    <div className="text-sm font-medium">{getWeatherName(dayInfo.weather)}</div>
                </div>

                <div className="text-center p-2 bg-gray-700 rounded">
                    <div className="text-xl mb-1">🌡️</div>
                    <div className="text-sm font-medium">{dayInfo.temperature}°C</div>
                </div>

                <div className="text-center p-2 bg-gray-700 rounded">
                    <div className="text-xl mb-1">💧</div>
                    <div className="text-sm font-medium">{dayInfo.humidity}% Humidity</div>
                </div>

                <div className="text-center p-2 bg-gray-700 rounded">
                    <div className="text-xl mb-1">{getGrowthStageIcon(dayInfo.growthStage)}</div>
                    <div className="text-sm font-medium">
                        {dayInfo.growthStage.charAt(0) + dayInfo.growthStage.slice(1).toLowerCase()}
                    </div>
                    <div className="text-xs text-gray-300">{Math.round(dayInfo.growthPercent * 100)}% Growth</div>
                </div>
            </div>

            {/* Date information */}
            <div className="mt-2 pt-2 border-t border-gray-600 text-center">
                <p className="text-sm">
                    <span className="font-bold">Day {dayInfo.dayNumber}</span> - {new Date(dayInfo.date).toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        year: 'numeric'
                    })}
                </p>
            </div>
        </div>
    );
};

export default WeatherInfo;
</file>

<file path="components/farm/CropStressAnalysis.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import { Card } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import { Crop, GeoLocation } from '@/types/farm';
import { analyzeCropSuitability } from '@/lib/services/farmEnvironmentService';

interface CropStressAnalysisProps {
    crops: Crop[];
    location: GeoLocation;
    className?: string;
    onSelectProduct?: (cropId: string, stressType: string) => void;
}

interface StressResult {
    cropId: string;
    cropName: string;
    cropType: string;
    temperature: { stress: number };
    water: { stress: number };
    soil: { stress: number };
    overall: { stress: number };
    loading: boolean;
    error: string | null;
}

export default function CropStressAnalysis({
    crops,
    location,
    className = '',
    onSelectProduct
}: CropStressAnalysisProps) {
    const [stressResults, setStressResults] = useState<StressResult[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        async function analyzeStress() {
            if (!crops || crops.length === 0) {
                setIsLoading(false);
                return;
            }

            setIsLoading(true);
            setError(null);

            try {
                // Initialize stress results with loading state
                const initialStressResults = crops.map(crop => ({
                    cropId: crop.id,
                    cropName: crop.name,
                    cropType: crop.type,
                    temperature: { stress: 0 },
                    water: { stress: 0 },
                    soil: { stress: 0 },
                    overall: { stress: 0 },
                    loading: true,
                    error: null
                }));

                setStressResults(initialStressResults);

                // Fetch environmental data
                const forecastResponse = await fetch(
                    `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=forecast`
                );

                if (!forecastResponse.ok) {
                    throw new Error(`Failed to fetch forecast data: ${forecastResponse.status}`);
                }

                const forecastData = await forecastResponse.json();

                // Fetch soil data
                const soilResponse = await fetch(
                    `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=soil`
                );

                if (!soilResponse.ok) {
                    throw new Error(`Failed to fetch soil data: ${soilResponse.status}`);
                }

                const soilData = await soilResponse.json();

                // Combine environmental data
                const environmentalData = {
                    ...forecastData,
                    ...soilData
                };

                // Analyze each crop
                const results = crops.map(crop => {
                    try {
                        const analysis = analyzeCropSuitability(crop, environmentalData);
                        return {
                            cropId: crop.id,
                            cropName: crop.name,
                            cropType: crop.type,
                            ...analysis,
                            loading: false,
                            error: null
                        };
                    } catch (err) {
                        console.error(`Error analyzing crop ${crop.name}:`, err);
                        return {
                            cropId: crop.id,
                            cropName: crop.name,
                            cropType: crop.type,
                            temperature: { stress: 0 },
                            water: { stress: 0 },
                            soil: { stress: 0 },
                            overall: { stress: 0 },
                            loading: false,
                            error: 'Analysis failed'
                        };
                    }
                });

                setStressResults(results);
            } catch (err) {
                console.error('Error in crop stress analysis:', err);
                setError('Failed to analyze crop stress. Please try again later.');
            } finally {
                setIsLoading(false);
            }
        }

        analyzeStress();
    }, [crops, location]);

    // Helper to render stress indicator
    const renderStressIndicator = (stressLevel: number) => {
        let color = 'bg-green-500';
        let label = 'Low';

        if (stressLevel > 0.7) {
            color = 'bg-red-500';
            label = 'High';
        } else if (stressLevel > 0.3) {
            color = 'bg-yellow-500';
            label = 'Medium';
        }

        const percentage = Math.min(100, Math.max(0, Math.round(stressLevel * 100)));

        return (
            <div className="w-full">
                <div className="flex justify-between text-xs mb-1">
                    <span>{label}</span>
                    <span>{percentage}%</span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2.5">
                    <div
                        className={`${color} h-2.5 rounded-full transition-all duration-500`}
                        style={{ width: `${percentage}%` }}
                    ></div>
                </div>
            </div>
        );
    };

    // Helper function to get appropriate recommendation based on stress type
    const getRecommendationText = (cropType: string, stressType: string, stressLevel: number) => {
        if (stressLevel < 0.3) return "No intervention needed";

        switch (stressType) {
            case 'temperature':
                return stressLevel > 0.7
                    ? "Consider Stress Buster for heat protection"
                    : "Monitor temperature changes";
            case 'water':
                return stressLevel > 0.7
                    ? "Consider Stress Buster for drought protection"
                    : "Monitor soil moisture";
            case 'soil':
                return stressLevel > 0.7
                    ? "Consider NUE Product to improve soil conditions"
                    : "Consider soil amendments";
            default:
                return "Consider crop-specific treatment";
        }
    };

    if (isLoading) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="flex justify-center items-center h-32">
                    <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500"></div>
                    <span className="ml-2">Analyzing crop conditions...</span>
                </div>
            </Card>
        );
    }

    if (error) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="text-red-500 p-2">
                    <p className="font-semibold">Error analyzing crops</p>
                    <p className="text-sm">{error}</p>
                </div>
            </Card>
        );
    }

    if (stressResults.length === 0) {
        return (
            <Card className={`p-4 ${className}`}>
                <div className="text-gray-500 p-2">
                    <p>No crops to analyze.</p>
                </div>
            </Card>
        );
    }

    return (
        <Card className={`p-4 ${className}`}>
            <div className="space-y-4">
                <h3 className="text-lg font-semibold">Crop Stress Analysis</h3>

                <div className="space-y-6">
                    {stressResults.map((result) => (
                        <div key={result.cropId} className="border rounded-lg p-4">
                            <div className="flex justify-between items-center mb-4">
                                <h4 className="font-medium">{result.cropName}</h4>
                                <span className="text-sm text-gray-500 capitalize">{result.cropType}</span>
                            </div>

                            {result.loading ? (
                                <div className="flex justify-center py-4">
                                    <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-green-500"></div>
                                </div>
                            ) : result.error ? (
                                <div className="text-red-500 text-sm">{result.error}</div>
                            ) : (
                                <div className="space-y-4">
                                    {/* Overall Stress */}
                                    <div className="mb-4">
                                        <div className="text-sm font-medium mb-1">Overall Stress Level</div>
                                        {renderStressIndicator(result.overall.stress)}
                                    </div>

                                    {/* Detailed Stress Factors */}
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        {/* Temperature Stress */}
                                        <div className="space-y-2">
                                            <div className="text-sm font-medium">Temperature Stress</div>
                                            {renderStressIndicator(result.temperature.stress)}
                                            <div className="text-xs text-gray-600">
                                                {getRecommendationText(result.cropType, 'temperature', result.temperature.stress)}
                                            </div>
                                            {onSelectProduct && result.temperature.stress > 0.3 && (
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    className="w-full mt-2"
                                                    onClick={() => onSelectProduct(result.cropId, 'temperature')}
                                                >
                                                    View Solutions
                                                </Button>
                                            )}
                                        </div>

                                        {/* Water Stress */}
                                        <div className="space-y-2">
                                            <div className="text-sm font-medium">Water Stress</div>
                                            {renderStressIndicator(result.water.stress)}
                                            <div className="text-xs text-gray-600">
                                                {getRecommendationText(result.cropType, 'water', result.water.stress)}
                                            </div>
                                            {onSelectProduct && result.water.stress > 0.3 && (
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    className="w-full mt-2"
                                                    onClick={() => onSelectProduct(result.cropId, 'water')}
                                                >
                                                    View Solutions
                                                </Button>
                                            )}
                                        </div>

                                        {/* Soil Stress */}
                                        <div className="space-y-2">
                                            <div className="text-sm font-medium">Soil Stress</div>
                                            {renderStressIndicator(result.soil.stress)}
                                            <div className="text-xs text-gray-600">
                                                {getRecommendationText(result.cropType, 'soil', result.soil.stress)}
                                            </div>
                                            {onSelectProduct && result.soil.stress > 0.3 && (
                                                <Button
                                                    variant="outline"
                                                    size="sm"
                                                    className="w-full mt-2"
                                                    onClick={() => onSelectProduct(result.cropId, 'soil')}
                                                >
                                                    View Solutions
                                                </Button>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            )}
                        </div>
                    ))}
                </div>
            </div>
        </Card>
    );
}
</file>

<file path="components/farm/FarmReviewStep.tsx">
// components/farm/FarmReviewStep.tsx
'use client'

import React from 'react';
import Image from 'next/image';
import MapComponent from './MapComponent';

interface FarmReviewStepProps {
  farmLocation: { latitude: number; longitude: number; name: string };
  farmSize: number;
  farmPolygon: Array<{latitude: number; longitude: number}>;
  cropType: string;
  onStartSimulation: () => void;
  onBack: () => void;
}

const FarmReviewStep: React.FC<FarmReviewStepProps> = ({
  farmLocation,
  farmSize,
  farmPolygon,
  cropType,
  onStartSimulation,
  onBack
}) => {
  // Helper function to get crop emoji
  const getCropEmoji = (crop: string) => {
    switch(crop.toLowerCase()) {
      case 'corn': return '🌽';
      case 'soybean': return '🌱';
      case 'wheat': return '🌾';
      case 'rice': return '🌾';
      case 'cotton': return '💮';
      default: return '🌿';
    }
  };

  // Format hectares for display
  const formatHectares = (value: number): string => {
    if (value >= 1000) {
      return `${(value / 1000).toFixed(1)}k ha`;
    }
    return `${value} ha`;
  };

  // Format a polygon point for display
  const formatCoordinate = (coord: number): string => {
    return coord.toFixed(6);
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <h2 className="text-2xl font-semibold mb-4 text-green-800">Review Your Setup</h2>
      <p className="text-gray-600 mb-6">
        Review your farm details before starting the simulation. The digital twin will be generated using these parameters.
      </p>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Farm Details */}
        <div>
          <div className="bg-green-50 p-5 rounded-lg border border-green-200 mb-6">
            <h3 className="text-xl font-semibold text-green-800 mb-4">Farm Details</h3>
            
            <div className="space-y-4">
              <div>
                <h4 className="font-medium text-green-700">Location</h4>
                <p className="text-gray-700 font-bold">{farmLocation.name}</p>
                <p className="text-sm text-gray-600">
                  Lat: {formatCoordinate(farmLocation.latitude)}, Lon: {formatCoordinate(farmLocation.longitude)}
                </p>
              </div>
              
              <div>
                <h4 className="font-medium text-green-700">Farm Size</h4>
                <p className="text-gray-700">
                  <span className="font-bold">{formatHectares(farmSize)}</span> 
                  <span className="text-sm text-gray-600 ml-2">({(farmSize * 2.47105).toFixed(2)} acres)</span>
                </p>
              </div>
              
              <div>
                <h4 className="font-medium text-green-700">Crop Type</h4>
                <p className="text-gray-700">
                  <span className="text-2xl mr-2">{getCropEmoji(cropType)}</span>
                  <span className="font-bold capitalize">{cropType}</span>
                </p>
              </div>
              
              <div>
                <h4 className="font-medium text-green-700">Farm Boundary</h4>
                <p className="text-sm text-gray-600">
                  {farmPolygon.length} points defining the farm perimeter
                </p>
                <div className="mt-2 max-h-32 overflow-y-auto text-xs bg-white p-2 rounded border border-gray-200">
                  {farmPolygon.map((point, index) => (
                    <div key={index} className="mb-1">
                      <span className="font-medium">Point {index + 1}:</span> {formatCoordinate(point.latitude)}, {formatCoordinate(point.longitude)}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
          
          <div className="bg-blue-50 p-5 rounded-lg border border-blue-200">
            <h3 className="text-xl font-semibold text-blue-800 mb-4">Simulation Information</h3>
            <div className="space-y-3">
              <p className="text-gray-700">
                Your digital twin simulation will include:
              </p>
              <ul className="list-disc pl-5 text-gray-700 space-y-2">
                <li>3D visualization of your farm</li>
                <li>Weather data and seasonal changes</li>
                <li>Crop growth stages simulation</li>
                <li>Biological product performance analysis</li>
                <li>Yield prediction and comparison</li>
              </ul>
              <p className="text-sm text-gray-600 mt-3">
                The simulation will run for one complete growing season with day-by-day progression.
              </p>
            </div>
          </div>
        </div>
        
        {/* Map Visualization */}
        <div className="space-y-4">
          <div className="bg-white rounded-lg border border-gray-300 overflow-hidden">
            <div className="bg-green-800 text-white py-2 px-4 font-medium">
              Farm Location Map
            </div>
            <div className="h-80">
              <MapComponent 
                latitude={farmLocation.latitude}
                longitude={farmLocation.longitude}
                hectares={farmSize}
                className="w-full h-full"
              />
            </div>
          </div>
          
          <div className="bg-white rounded-lg border border-gray-300 overflow-hidden">
            <div className="bg-green-800 text-white py-2 px-4 font-medium">
              Farm Boundary Polygon
            </div>
            <div className="relative h-80 bg-gray-100">
              {/* Here we would ideally render the actual polygon on a map */}
              {/* For MVP, we'll show a simplified representation */}
              <div className="absolute inset-0 flex items-center justify-center p-4">
                <svg width="100%" height="100%" viewBox="0 0 200 200" className="max-w-full max-h-full">
                  {/* Create a polygon from the farm boundary points */}
                  {farmPolygon.length >= 3 && (
                    <polygon 
                      points={farmPolygon.map((point, i) => {
                        // Very simple conversion to SVG coordinates (just for visualization)
                        // Center around the farm location, scale based on relative distances
                        const center = { x: 100, y: 100 };
                        const scale = 500; // Arbitrary scale factor
                        
                        const dx = (point.longitude - farmLocation.longitude) * scale;
                        const dy = (farmLocation.latitude - point.latitude) * scale;
                        
                        return `${center.x + dx},${center.y + dy}`;
                      }).join(' ')}
                      fill="rgba(76, 175, 80, 0.3)"
                      stroke="green"
                      strokeWidth="2"
                    />
                  )}
                  
                  {/* Add point markers */}
                  {farmPolygon.map((point, i) => {
                    const center = { x: 100, y: 100 };
                    const scale = 500;
                    
                    const dx = (point.longitude - farmLocation.longitude) * scale;
                    const dy = (farmLocation.latitude - point.latitude) * scale;
                    
                    return (
                      <g key={i}>
                        <circle 
                          cx={center.x + dx} 
                          cy={center.y + dy} 
                          r="4" 
                          fill="red" 
                        />
                        <text 
                          x={center.x + dx} 
                          y={center.y + dy - 7} 
                          fontSize="10" 
                          textAnchor="middle"
                          fill="black"
                        >
                          {i + 1}
                        </text>
                      </g>
                    );
                  })}
                  
                  {/* Center point marker */}
                  <circle cx="100" cy="100" r="6" fill="blue" opacity="0.7" />
                </svg>
              </div>
              <div className="absolute bottom-0 left-0 right-0 bg-white bg-opacity-80 p-2 text-xs text-center">
                Farm polygon visualization (simplified view)
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Start Simulation Button */}
      <div className="mt-8 text-center">
        <button
          onClick={onStartSimulation}
          className="px-8 py-4 bg-green-600 text-white text-lg font-bold rounded-lg shadow-lg hover:bg-green-700 transform hover:scale-105 transition-all"
        >
          Start Simulation &rarr;
        </button>
        <p className="text-sm text-gray-600 mt-2">
          Your digital twin will be generated with these parameters
        </p>
      </div>

      {/* Navigation buttons */}
      <div className="flex justify-between mt-8">
        <button
          onClick={onBack}
          className="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600"
        >
          Back
        </button>
      </div>
    </div>
  );
};

export default FarmReviewStep;
</file>

<file path="components/farm/FarmSizeStep.tsx">
// components/farm/FarmSizeStep.tsx
'use client'

import React, { useState, useEffect } from 'react';
import Image from 'next/image';
import MapComponent from './MapComponent';

interface FarmSizeStepProps {
  farmLocation: { latitude: number; longitude: number; name: string };
  farmSize: number;
  onFarmSizeChange: (size: number) => void;
  onContinue: () => void;
  onBack: () => void;
}

const FarmSizeStep: React.FC<FarmSizeStepProps> = ({
  farmLocation,
  farmSize,
  onFarmSizeChange,
  onContinue,
  onBack
}) => {
  const [mapUrl, setMapUrl] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);

  // Update map when location or size changes
  useEffect(() => {
    updateMapPreview();
  }, [farmLocation, farmSize]);

  // Generate map preview using OpenStreetMap
  const updateMapPreview = () => {
    if (!farmLocation) return;
    
    setIsLoading(true);
    
    // Calculate radius in km based on hectares
    // Area = π × r²
    // 1 hectare = 0.01 km²
    // r = √(area ÷ π)
    const areaKm2 = farmSize * 0.01;
    const radiusKm = Math.sqrt(areaKm2 / Math.PI);
    
    // Use OpenStreetMap static map API
    // We'll use the OpenStreetMap Static Maps API via Thunderforest
    // You'll need to create an account and get an API key at https://www.thunderforest.com/
    // For demo purposes, we'll use a placeholder API key - replace with your own
    const apiKey = process.env.NEXT_PUBLIC_THUNDERFOREST_API_KEY || 'placeholder-key';
    
    // Calculate zoom level based on farm size
    // This is an approximation - smaller hectares need higher zoom
    let zoomLevel;
    if (farmSize <= 10) zoomLevel = 14;
    else if (farmSize <= 50) zoomLevel = 13;
    else if (farmSize <= 200) zoomLevel = 12;
    else if (farmSize <= 500) zoomLevel = 11;
    else if (farmSize <= 1000) zoomLevel = 10;
    else zoomLevel = 9;
    
    // Create the map URL
    const baseUrl = 'https://tile.thunderforest.com/landscape';
    const mapPreviewUrl = `${baseUrl}/${farmLocation.longitude},${farmLocation.latitude},${zoomLevel}/600x400.png?apikey=${apiKey}`;
    
    // For development without an API key, fall back to a screenshot or embedded iframe
    if (apiKey === 'placeholder-key') {
      // Use a fallback map approach
      const openStreetMapUrl = `https://www.openstreetmap.org/export/embed.html?bbox=${farmLocation.longitude-0.1},${farmLocation.latitude-0.1},${farmLocation.longitude+0.1},${farmLocation.latitude+0.1}&layer=mapnik&marker=${farmLocation.latitude},${farmLocation.longitude}`;
      setMapUrl(openStreetMapUrl);
    } else {
      setMapUrl(mapPreviewUrl);
    }
    
    setIsLoading(false);
  };

  // Format hectares for display
  const formatHectares = (value: number): string => {
    if (value >= 1000) {
      return `${(value / 1000).toFixed(1)}k ha`;
    }
    return `${value} ha`;
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <h2 className="text-2xl font-semibold mb-4 text-green-800">Specify Your Farm Size</h2>
      <p className="text-gray-600 mb-6">
        Enter the approximate size of your farm in hectares.
        This will determine the scale of your simulation.
      </p>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <div className="mb-6">
            <label className="block text-sm font-medium mb-2">Farm size (hectares):</label>
            <input
              type="range"
              min="10"
              max="1000"
              step="10"
              value={farmSize}
              onChange={(e) => onFarmSizeChange(parseInt(e.target.value))}
              className="w-full h-2 bg-green-200 rounded-lg appearance-none cursor-pointer"
            />
            <div className="flex justify-between mt-2">
              <span className="text-sm text-gray-600">10 ha</span>
              <span className="font-medium text-green-800">{formatHectares(farmSize)}</span>
              <span className="text-sm text-gray-600">1000 ha</span>
            </div>
            
            <div className="mt-4">
              <label className="block text-sm font-medium mb-2">Or enter exact size:</label>
              <div className="flex items-center">
                <input
                  type="number"
                  min="1"
                  max="10000"
                  value={farmSize}
                  onChange={(e) => onFarmSizeChange(parseInt(e.target.value) || 1)}
                  className="w-full p-2 border rounded mr-2"
                />
                <span className="text-gray-600">hectares</span>
              </div>
            </div>
            
            <div className="mt-4 p-4 bg-green-50 rounded-lg">
              <h3 className="font-medium text-green-800 mb-2">Farm Location:</h3>
              <p className="font-medium">{farmLocation.name || 'Custom Location'}</p>
              <p className="text-sm text-gray-600">
                Lat: {farmLocation.latitude.toFixed(6)}, Lon: {farmLocation.longitude.toFixed(6)}
              </p>
            </div>
            
            <div className="mt-4">
              <div className="text-sm text-gray-500">
                <p><strong>Farm area:</strong> {farmSize} hectares ({(farmSize * 2.47105).toFixed(2)} acres)</p>
                <p><strong>Approximate radius:</strong> {(Math.sqrt(farmSize * 10000 / Math.PI)).toFixed(0)} meters</p>
              </div>
            </div>
          </div>
        </div>
        
        {/* Map preview */}
        <div className="bg-gray-100 rounded-lg overflow-hidden">
          <div className="bg-green-800 text-white py-2 px-4 text-sm font-medium">
            Location Preview
          </div>
          {isLoading ? (
            <div className="flex justify-center items-center h-64">
              <div className="inline-block w-8 h-8 border-4 border-green-500 border-t-transparent rounded-full animate-spin"></div>
            </div>
          ) : (
            // Using our MapComponent
            <MapComponent 
              latitude={farmLocation.latitude}
              longitude={farmLocation.longitude}
              hectares={farmSize}
              className="w-full h-64 md:h-80"
              showCircle={true}
            />
          )}
          <div className="px-4 py-2 text-xs text-gray-600">
            Map shows approximate farm location. You'll define the exact boundary in the next step.
          </div>
        </div>
      </div>
      
      <div className="flex justify-between mt-6">
        <button
          onClick={onBack}
          className="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600"
        >
          Back
        </button>
        
        <button
          onClick={onContinue}
          className="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
        >
          Continue
        </button>
      </div>
    </div>
  );
};

export default FarmSizeStep;
</file>

<file path="components/farm/LocationInputWithMap.tsx">
// components/farm/LocationInputWithMap.tsx
'use client'

import React, { useState, useEffect, useRef } from 'react';
import MapComponent from './MapComponent';

interface LocationInputWithMapProps {
  onLocationChange: (latitude: number, longitude: number, locationName: string) => void;
  initialLocation: {
    latitude: number;
    longitude: number;
    name: string;
  };
  disabled?: boolean;
}

interface GeocodeResult {
  name: string;
  country: string;
  state?: string;
  lat: number;
  lon: number;
}

const LocationInputWithMap: React.FC<LocationInputWithMapProps> = ({ 
  onLocationChange, 
  initialLocation,
  disabled = false 
}) => {
  const [searchQuery, setSearchQuery] = useState('');
  const [latitude, setLatitude] = useState<number>(initialLocation.latitude);
  const [longitude, setLongitude] = useState<number>(initialLocation.longitude);
  const [locationName, setLocationName] = useState(initialLocation.name);
  const [searchResults, setSearchResults] = useState<GeocodeResult[]>([]);
  const [isSearching, setIsSearching] = useState(false);
  const [error, setError] = useState('');
  const [showResults, setShowResults] = useState(false);
  const [mapClicked, setMapClicked] = useState(false);
  
  const mapContainerRef = useRef<HTMLDivElement>(null);

  // Initialize with the provided values
  useEffect(() => {
    setLatitude(initialLocation.latitude);
    setLongitude(initialLocation.longitude);
    setLocationName(initialLocation.name);
  }, [initialLocation]);

  // Handle map click to set coordinates
  const handleMapClick = (event: MessageEvent) => {
    // Check if the message is from our map iframe
    if (event.data && event.data.type === 'map-click') {
      const { lat, lng } = event.data;
      setLatitude(lat);
      setLongitude(lng);
      setMapClicked(true);
      
      // Reverse geocode to get location name
      reverseGeocode(lat, lng);
    }
  };

  // Add listener for messages from the iframe
  useEffect(() => {
    window.addEventListener('message', handleMapClick);
    return () => {
      window.removeEventListener('message', handleMapClick);
    };
  }, []);

  // Reverse geocode to get location name from coordinates
  const reverseGeocode = async (lat: number, lon: number) => {
    try {
      // Use OpenStreetMap Nominatim for reverse geocoding
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18&addressdetails=1`,
        {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Farm Bio-Boost Simulator' // Nominatim requires a user agent
          }
        }
      );

      if (!response.ok) {
        throw new Error(`Geocoding API error: ${response.status}`);
      }

      const data = await response.json();

      if (data && data.display_name) {
        // Create a more concise location name
        let placeName = '';
        
        if (data.address) {
          const parts = [];
          if (data.address.city) parts.push(data.address.city);
          else if (data.address.town) parts.push(data.address.town);
          else if (data.address.village) parts.push(data.address.village);
          else if (data.address.hamlet) parts.push(data.address.hamlet);
          
          if (data.address.state) parts.push(data.address.state);
          if (data.address.country) parts.push(data.address.country);
          
          placeName = parts.join(', ');
        }
        
        if (!placeName) placeName = data.display_name.split(',').slice(0, 3).join(',');
        
        setLocationName(placeName);
        onLocationChange(lat, lon, placeName);
      } else {
        setLocationName(`${lat.toFixed(6)}, ${lon.toFixed(6)}`);
        onLocationChange(lat, lon, `${lat.toFixed(6)}, ${lon.toFixed(6)}`);
      }
    } catch (error) {
      console.error("Error during reverse geocoding:", error);
      setLocationName(`${lat.toFixed(6)}, ${lon.toFixed(6)}`);
      onLocationChange(lat, lon, `${lat.toFixed(6)}, ${lon.toFixed(6)}`);
    }
  };

  // Search for location by name
  const searchLocation = async () => {
    if (!searchQuery.trim() || disabled) return;

    setIsSearching(true);
    setError('');

    try {
      // Use OpenStreetMap Nominatim for search
      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}&limit=5`,
        {
          headers: {
            'Accept': 'application/json',
            'User-Agent': 'Farm Bio-Boost Simulator' // Nominatim requires a user agent
          }
        }
      );

      if (!response.ok) {
        throw new Error(`Geocoding API error: ${response.status}`);
      }

      const data = await response.json();

      if (data && data.length > 0) {
        const results: GeocodeResult[] = data.map((item: any) => ({
          name: item.display_name.split(',')[0],
          country: item.display_name.split(',').pop().trim(),
          state: item.display_name.split(',').length > 2 ? item.display_name.split(',')[1].trim() : '',
          lat: parseFloat(item.lat),
          lon: parseFloat(item.lon)
        }));

        setSearchResults(results);
        setShowResults(true);
      } else {
        setSearchResults([]);
        setError('No locations found. Try a different search term.');
      }
    } catch (error) {
      console.error("Error searching location:", error);
      setError('Error searching for location. Please try again.');
    } finally {
      setIsSearching(false);
    }
  };

  // Handle location selection from search results
  const selectLocation = (result: GeocodeResult) => {
    setLatitude(result.lat);
    setLongitude(result.lon);

    const locationString = result.state
      ? `${result.name}, ${result.state}, ${result.country}`
      : `${result.name}, ${result.country}`;

    setLocationName(locationString);
    setSearchQuery('');
    setShowResults(false);

    // Notify parent component
    onLocationChange(result.lat, result.lon, locationString);
  };

  // Handle manual entry of coordinates
  const handleManualCoordinates = () => {
    if (latitude !== null && longitude !== null) {
      reverseGeocode(latitude, longitude);
    }
  };

  // Helper function to create a specialized map URL for location picking
  const getMapUrl = () => {
    return `https://www.openstreetmap.org/export/embed.html?bbox=${longitude-1},${latitude-1},${longitude+1},${latitude+1}&layer=mapnik&marker=${latitude},${longitude}`;
  };

  return (
    <div className="bg-white p-4 rounded-lg shadow-md">
      <h3 className="text-lg font-semibold mb-2 text-green-800">Location Settings</h3>

      {/* Map for visual selection */}
      <div className="mb-4 rounded-lg overflow-hidden border border-gray-300" ref={mapContainerRef}>
        <div className="bg-green-800 text-white py-1 px-3 text-sm">
          Click on map to set farm location
        </div>
        <div className="relative" style={{ height: '300px' }}>
          <iframe
            src={getMapUrl()}
            width="100%"
            height="100%"
            frameBorder="0"
            scrolling="no"
            className="absolute inset-0"
            title="Farm location map"
          ></iframe>
        </div>
      </div>

      {/* Search by place name */}
      <div className="mb-3">
        <label className="block text-sm font-medium mb-1">Search by place name:</label>
        <div className="flex">
          <input
            type="text"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && searchLocation()}
            placeholder="City name, country"
            className="w-full p-2 border rounded-l"
            disabled={disabled}
          />
          <button
            onClick={searchLocation}
            className="bg-blue-500 text-white px-3 rounded-r hover:bg-blue-600"
            disabled={isSearching || disabled || !searchQuery.trim()}
          >
            {isSearching ? '...' : 'Search'}
          </button>
        </div>

        {/* Search results dropdown */}
        {showResults && searchResults.length > 0 && (
          <div className="absolute z-10 mt-1 w-64 bg-white border rounded shadow-lg">
            {searchResults.map((result, index) => (
              <div
                key={index}
                className="p-2 hover:bg-gray-100 cursor-pointer"
                onClick={() => selectLocation(result)}
              >
                {result.name}, {result.state && `${result.state}, `}{result.country}
              </div>
            ))}
          </div>
        )}

        {error && <p className="text-red-500 text-sm mt-1">{error}</p>}
      </div>

      {/* Or enter coordinates manually */}
      <div className="mb-3">
        <label className="block text-sm font-medium mb-1">Or enter coordinates:</label>
        <div className="grid grid-cols-2 gap-2">
          <div>
            <input
              type="number"
              value={latitude}
              onChange={(e) => setLatitude(parseFloat(e.target.value))}
              placeholder="Latitude"
              min="-90"
              max="90"
              step="0.000001"
              className="w-full p-2 border rounded"
              disabled={disabled}
            />
          </div>
          <div>
            <input
              type="number"
              value={longitude}
              onChange={(e) => setLongitude(parseFloat(e.target.value))}
              placeholder="Longitude"
              min="-180"
              max="180"
              step="0.000001"
              className="w-full p-2 border rounded"
              disabled={disabled}
            />
          </div>
        </div>
        <button
          onClick={handleManualCoordinates}
          className="mt-2 bg-green-500 text-white px-3 py-1 rounded hover:bg-green-600"
          disabled={!latitude || !longitude || disabled}
        >
          Set Location
        </button>
      </div>

      {/* Display current location */}
      {locationName && (
        <div className="mt-3 p-2 bg-gray-100 rounded">
          <p className="text-sm font-medium">Current Location:</p>
          <p className="font-bold text-green-800">{locationName}</p>
          <p className="text-xs text-gray-600">
            Lat: {latitude?.toFixed(6)}, Lon: {longitude?.toFixed(6)}
          </p>
        </div>
      )}
    </div>
  );
};

export default LocationInputWithMap;
</file>

<file path="components/farm/LocationPicker.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { GeoLocation } from '@/types/farm';

// Import types but not actual components to avoid SSR issues
import type { MapContainer as MapContainerType } from 'react-leaflet';

interface LocationPickerProps {
    value: GeoLocation;
    onChange: (location: GeoLocation) => void;
    className?: string;
}

// Dynamically import the map component with SSR disabled
// This ensures Leaflet only loads in the browser, not during server rendering
const MapComponentWithNoSSR = dynamic(
    () => import('@/components/farm/MapComponent').then((mod) => mod.default),
    {
        ssr: false,
        loading: () => (
            <div className="h-64 rounded-md overflow-hidden border border-gray-300 bg-gray-100 flex items-center justify-center">
                <div className="text-gray-500">Loading map...</div>
            </div>
        )
    }
);

export default function LocationPicker({ value, onChange, className = '' }: LocationPickerProps) {
    const [searchQuery, setSearchQuery] = useState('');
    const [searchResults, setSearchResults] = useState<Array<{
        display_name: string;
        lat: string;
        lon: string;
    }>>([]);
    const [isSearching, setIsSearching] = useState(false);

    // Handler for search functionality
    const handleSearch = async () => {
        if (!searchQuery.trim()) return;

        setIsSearching(true);
        try {
            // Using Nominatim for geocoding (OpenStreetMap)
            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}`
            );
            const data = await response.json();
            setSearchResults(data.slice(0, 5)); // Limit to 5 results
        } catch (error) {
            console.error('Error searching location:', error);
        } finally {
            setIsSearching(false);
        }
    };

    const handleSelectResult = (result: { lat: string; lon: string }) => {
        onChange({
            lat: parseFloat(result.lat),
            lng: parseFloat(result.lon),
        });
        setSearchResults([]);
        setSearchQuery('');
    };

    return (
        <div className={`flex flex-col ${className}`}>
            {/* Search Component */}
            <div className="mb-4">
                <div className="flex space-x-2">
                    <input
                        type="text"
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        placeholder="Search location (e.g., Karnataka, India)"
                        className="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                        onKeyDown={(e) => e.key === 'Enter' && handleSearch()}
                    />
                    <button
                        type="button"
                        onClick={handleSearch}
                        disabled={isSearching}
                        className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 disabled:bg-green-400"
                    >
                        {isSearching ? 'Searching...' : 'Search'}
                    </button>
                </div>

                {/* Search Results */}
                {searchResults.length > 0 && (
                    <div className="mt-2 border rounded-md shadow-sm max-h-60 overflow-y-auto bg-white">
                        <ul>
                            {searchResults.map((result, index) => (
                                <li
                                    key={index}
                                    className="px-3 py-2 hover:bg-gray-100 cursor-pointer border-b last:border-b-0"
                                    onClick={() => handleSelectResult(result)}
                                >
                                    {result.display_name}
                                </li>
                            ))}
                        </ul>
                    </div>
                )}
            </div>

            {/* Map Component - Dynamically loaded on client-side only */}
            <MapComponentWithNoSSR location={value} onLocationChange={onChange} />

            {/* Coordinate Display */}
            <div className="mt-2 flex justify-between text-sm text-gray-500">
                <span>Latitude: {value.lat.toFixed(6)}</span>
                <span>Longitude: {value.lng.toFixed(6)}</span>
            </div>

            <div className="mt-2 text-xs text-gray-500">
                Tip: Click on the map to set location or use the search box above
            </div>
        </div>
    );
}
</file>

<file path="components/styles/Navbar.css">
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

.navbar-link {
  position: relative;
  color: #1f2937;
  transition: color 0.3s ease;
  font-family: "Inter", sans-serif;
  font-weight: 500;
  padding: 0.5rem 0;
}

.navbar-link::after {
  content: '';
  position: absolute;
  width: 0;
  height: 2px;
  bottom: -2px;
  left: 0;
  background-color: rgba(16, 185, 129, 0.7); /* Green color for Farm Bio-Boost theme */
  transition: width 0.3s ease;
}

.navbar-link:hover {
  color: rgb(16, 185, 129);
}

.navbar-link:hover::after {
  width: 100%;
}

/* Mobile menu styling */
.navbar-menu {
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* For screens smaller than 768px (md breakpoint in Tailwind) */
@media (max-width: 767px) {
  .hamburger-button {
    display: flex;
  }
}

/* For screens larger than 768px */
@media (min-width: 768px) {
  .hamburger-button {
    display: none;
  }
}

/* Add a backdrop for the mobile menu when open */
.navbar-menu-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(2px);
  z-index: 40;
}
</file>

<file path="components/ui/Button.tsx">
"use client";

import React from 'react';

type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'destructive';
type ButtonSize = 'sm' | 'md' | 'lg';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    variant?: ButtonVariant;
    size?: ButtonSize;
    children: React.ReactNode;
}

export const Button: React.FC<ButtonProps> = ({
    variant = 'primary',
    size = 'md',
    children,
    className = '',
    ...props
}) => {
    // Variant styles
    const variantStyles = {
        primary: 'bg-green-600 hover:bg-green-700 text-white',
        secondary: 'bg-blue-600 hover:bg-blue-700 text-white',
        outline: 'bg-transparent border border-green-600 text-green-600 hover:bg-green-50',
        destructive: 'bg-red-600 hover:bg-red-700 text-white',
    };

    // Size styles
    const sizeStyles = {
        sm: 'px-3 py-1.5 text-sm',
        md: 'px-4 py-2',
        lg: 'px-6 py-3 text-lg',
    };

    return (
        <button
            className={`rounded-md font-medium transition-colors focus:outline-none 
        focus:ring-2 focus:ring-green-500 focus:ring-opacity-50 
        ${variantStyles[variant]} ${sizeStyles[size]} ${className}`}
            {...props}
        >
            {children}
        </button>
    );
};
</file>

<file path="components/ui/Card.tsx">
import React from 'react';

interface CardProps {
    children: React.ReactNode;
    className?: string;
}

export const Card: React.FC<CardProps> = ({ children, className = '' }) => {
    return (
        <div className={`bg-white rounded-lg shadow ${className}`}>
            {children}
        </div>
    );
};
</file>

<file path="components/ui/Navbar.tsx">
import Link from 'next/link';
import Image from 'next/image';

export default function Navbar() {
    return (
        <header className="bg-green-500 py-3">
            <div className="container max-w-screen-xl mx-auto px-4 lg:px-20 flex justify-between items-center">
                {/* Project Name */}
                <Link href="/" className="flex items-center">
                    <div className="text-xl font-bold text-white">Farm Bio-Boost</div>
                    <div className="text-sm text-white ml-2">Simulator</div>
                </Link>

                {/* Powered by Syngenta */}
                <div className="flex items-center text-sm text-gray-600">
                    <span className="mr-2">Powered by</span>
                    <Image
                        src="/images/syngenta-logo.png"
                        alt="Syngenta"
                        width={100}
                        height={30}
                        className="w-auto"
                    />
                </div>
            </div>
        </header>
    );
}
</file>

<file path="lib/crops/corn.ts">
import * as THREE from 'three';

const createCornPlant = (plantHeight) => {
  const plantGroup = new THREE.Group();
  
  // Corn stalk
  const stalkGeometry = new THREE.CylinderGeometry(0.05, 0.08, plantHeight, 8);
  const stalkMaterial = new THREE.MeshStandardMaterial({ color: 0x7D6E2A });
  const stalk = new THREE.Mesh(stalkGeometry, stalkMaterial);
  stalk.position.y = plantHeight / 2;
  stalk.castShadow = true;
  plantGroup.add(stalk);
  
  // Corn leaves
  for (let i = 0; i < 6; i++) {
    const leafHeight = plantHeight * 0.7;
    const leafGeometry = new THREE.PlaneGeometry(0.3, leafHeight);
    const leafMaterial = new THREE.MeshStandardMaterial({
      color: 0x4CAF50,
      side: THREE.DoubleSide
    });
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf.position.y = (Math.random() * 0.5 + 0.2) * plantHeight;
    leaf.rotation.y = Math.PI / 2 * i;
    leaf.rotation.x = Math.PI / 6;
    leaf.castShadow = true;
    plantGroup.add(leaf);
  }
  
  // Corn cob
  const cobGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.4, 8);
  const cobMaterial = new THREE.MeshStandardMaterial({ color: 0xFFF176 });
  const cob = new THREE.Mesh(cobGeometry, cobMaterial);
  cob.position.y = plantHeight * 0.6;
  cob.position.x = 0.15;
  cob.rotation.z = Math.PI / 2;
  cob.castShadow = true;
  plantGroup.add(cob);
  
  // Optional second cob on larger plants
  if (plantHeight > 2.2) {
    const secondCob = new THREE.Mesh(cobGeometry, cobMaterial);
    secondCob.position.y = plantHeight * 0.45;
    secondCob.position.x = -0.15;
    secondCob.rotation.z = Math.PI / 2;
    secondCob.castShadow = true;
    plantGroup.add(secondCob);
  }
  
  return plantGroup;
};

export default createCornPlant;
</file>

<file path="lib/crops/cotton.ts">
import * as THREE from 'three';

const createCottonPlant = (plantHeight) => {
  const plantGroup = new THREE.Group();
  
  // Cotton stem
  const cottonStemGeometry = new THREE.CylinderGeometry(0.02, 0.03, plantHeight, 6);
  const cottonStemMaterial = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
  const cottonStem = new THREE.Mesh(cottonStemGeometry, cottonStemMaterial);
  cottonStem.position.y = plantHeight / 2;
  cottonStem.castShadow = true;
  plantGroup.add(cottonStem);
  
  // Cotton leaves
  for (let i = 0; i < 5; i++) {
    const leafGeometry = new THREE.CircleGeometry(0.1, 5);
    const leafMaterial = new THREE.MeshStandardMaterial({
      color: 0x388E3C,
      side: THREE.DoubleSide
    });
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf.position.y = (i / 5) * plantHeight;
    leaf.position.x = 0.1 * (i % 2 === 0 ? 1 : -1);
    leaf.rotation.x = Math.PI / 4;
    leaf.rotation.y = (i / 5) * Math.PI;
    leaf.castShadow = true;
    plantGroup.add(leaf);
  }
  
  // Cotton bolls
  for (let i = 0; i < 3; i++) {
    const bollGeometry = new THREE.SphereGeometry(0.06, 8, 8);
    const bollMaterial = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
    const boll = new THREE.Mesh(bollGeometry, bollMaterial);
    boll.position.y = plantHeight * 0.6 + (i * 0.15);
    boll.position.x = 0.1 * (i % 2 === 0 ? 1 : -1);
    boll.position.z = 0.05 * (i % 2 === 0 ? 1 : -1);
    boll.castShadow = true;
    plantGroup.add(boll);
  }
  
  return plantGroup;
};

export default createCottonPlant;
</file>

<file path="lib/crops/rice.ts">
import * as THREE from 'three';

const createRicePlant = (plantHeight) => {
  const plantGroup = new THREE.Group();
  
  // Rice stem
  const riceStemGeometry = new THREE.CylinderGeometry(0.01, 0.015, plantHeight, 6);
  const riceStemMaterial = new THREE.MeshStandardMaterial({ color: 0x9CCC65 });
  const riceStem = new THREE.Mesh(riceStemGeometry, riceStemMaterial);
  riceStem.position.y = plantHeight / 2;
  riceStem.castShadow = true;
  plantGroup.add(riceStem);
  
  // Rice grains
  const grainGeometry = new THREE.ConeGeometry(0.04, 0.2, 6);
  const grainMaterial = new THREE.MeshStandardMaterial({ color: 0xF0E68C });
  const grain = new THREE.Mesh(grainGeometry, grainMaterial);
  grain.position.y = plantHeight + 0.05;
  grain.rotation.x = Math.PI;
  grain.castShadow = true;
  plantGroup.add(grain);
  
  // Rice leaves
  for (let i = 0; i < 3; i++) {
    const leafGeometry = new THREE.PlaneGeometry(0.02, 0.3);
    const leafMaterial = new THREE.MeshStandardMaterial({
      color: 0x81C784,
      side: THREE.DoubleSide
    });
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf.position.y = plantHeight * 0.5 + (i * 0.1);
    leaf.position.x = 0.03 * (i % 2 === 0 ? 1 : -1);
    leaf.rotation.x = Math.PI / 6;
    leaf.rotation.z = Math.PI / 6 * (i % 2 === 0 ? 1 : -1);
    leaf.castShadow = true;
    plantGroup.add(leaf);
  }
  
  return plantGroup;
};

export default createRicePlant;
</file>

<file path="lib/crops/soybean.ts">
import * as THREE from 'three';

const createSoybeanPlant = (plantHeight) => {
  const plantGroup = new THREE.Group();
  
  // Soybean stem
  const stemGeometry = new THREE.CylinderGeometry(0.02, 0.03, plantHeight, 6);
  const stemMaterial = new THREE.MeshStandardMaterial({ color: 0x8D6E63 });
  const stem = new THREE.Mesh(stemGeometry, stemMaterial);
  stem.position.y = plantHeight / 2;
  stem.castShadow = true;
  plantGroup.add(stem);
  
  // Soybean leaves
  for (let i = 0; i < 4; i++) {
    const leafGeometry = new THREE.CircleGeometry(0.1, 8);
    const leafMaterial = new THREE.MeshStandardMaterial({
      color: 0x2E7D32,
      side: THREE.DoubleSide
    });
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf.position.y = (i / 4) * plantHeight + 0.1;
    leaf.position.x = 0.1;
    leaf.position.z = 0.05 * (i % 2 === 0 ? 1 : -1);
    leaf.rotation.y = Math.PI / 4;
    leaf.castShadow = true;
    plantGroup.add(leaf);
  }
  
  // Soybean pods
  for (let i = 0; i < 3; i++) {
    const podGeometry = new THREE.CapsuleGeometry(0.02, 0.08, 4, 8);
    const podMaterial = new THREE.MeshStandardMaterial({ color: 0x9CCC65 });
    const pod = new THREE.Mesh(podGeometry, podMaterial);
    pod.position.y = plantHeight * 0.7 - (i * 0.1);
    pod.position.x = 0.08;
    pod.position.z = 0.05 * (i % 2 === 0 ? 1 : -1);
    pod.rotation.z = Math.PI / 3;
    pod.castShadow = true;
    plantGroup.add(pod);
  }
  
  return plantGroup;
};

export default createSoybeanPlant;
</file>

<file path="lib/crops/wheat.ts">
import * as THREE from 'three';

const createWheatPlant = (plantHeight) => {
  const plantGroup = new THREE.Group();
  
  // Wheat stalk
  const wheatStalkGeometry = new THREE.CylinderGeometry(0.01, 0.02, plantHeight, 6);
  const wheatStalkMaterial = new THREE.MeshStandardMaterial({ color: 0xCDDC39 });
  const wheatStalk = new THREE.Mesh(wheatStalkGeometry, wheatStalkMaterial);
  wheatStalk.position.y = plantHeight / 2;
  wheatStalk.castShadow = true;
  plantGroup.add(wheatStalk);
  
  // Wheat head
  const wheatHeadGeometry = new THREE.CylinderGeometry(0.03, 0.01, 0.2, 6);
  const wheatHeadMaterial = new THREE.MeshStandardMaterial({ color: 0xFDD835 });
  const wheatHead = new THREE.Mesh(wheatHeadGeometry, wheatHeadMaterial);
  wheatHead.position.y = plantHeight + 0.1;
  wheatHead.castShadow = true;
  plantGroup.add(wheatHead);
  
  return plantGroup;
};

export default createWheatPlant;
</file>

<file path="lib/data/products.json">
{
  "products": [
    {
      "name": "Stress Buster",
      "category": "Biostimulant",
      "type": "Anti-stress and growth activator",
      "application_method": "Foliar application",
      "timing": "As soon as a stress event is predicted",
      "composition": "Complex of selected vegetal extracts derived from selected plants",
      "description": "When applied in case of abiotic stresses, its synergistic action of different active ingredients allows plants to tolerate and quickly overcome the stress, preserving yield. Applied regularly in normal condition, optimizes plant growth.",
      "directions_for_use": {
        "fruit_crops": {
          "dose": "2-3 l/ha",
          "period": "pre-flowering, post-setting, fruit development and in all cases of plant growth stop"
        },
        "vegetable": {
          "dose": "2-3 l/ha",
          "period": "in open field and greenhouses after transplant every 10-15 days"
        },
        "row_crops": {
          "dose": "2-3 l/ha (150-250 mL/hL)",
          "period": "1-2 applications during growth cycle in case of abiotic stresses"
        }
      },
      "scientific_evidence": {
        "transcriptomics": {
          "non_stressed_plants": "Treated plants show activation of >100 genes (FC >3) vs. Control, mainly involved in: i) abiotic stress response/tolerance (\"hardening effect\" against abiotic stress), ii) activation of plant metabolism (thus better growth)",
          "drought_stressed_plants": "Pre-treated with stress buster show a decreased expression of stress-related marker genes during stress conditions, showing a lower perception of the stress itself (\"acclimated plants\"; Petrozza et al., 2014)"
        },
        "phenomics": {
          "improvements": [
            "Digital Biovolume/Biomass",
            "Health Index (less Stress Index)",
            "Water content",
            "Other indexes: Green/Yellow Index, etc"
          ]
        },
        "metabolomics": "METABOLOMICS has also been used recently, to highlight the action of Stress Buster in stress conditions. It has been observed that the product is capable of modulating specific classes of metabolites, connected to the response to abiotic stress."
      },
      "field_trial_results": {
        "crop_performance": {
          "row_crops": {
            "yield_increase": "+ 0,30 t/ha",
            "roi": "3,9:1"
          },
          "vegetable": {
            "yield_increase": "+ 2,3 t/ha",
            "roi": "11,6:1"
          },
          "fruit_crops": {
            "yield_increase": "+ 1,2 t/ha",
            "roi": "10,5:1"
          }
        },
        "stress_conditions": {
          "cold": {
            "evidences": 10,
            "win_rate": "70%",
            "yield_increase": "+5%"
          },
          "heat": {
            "evidences": 26,
            "win_rate": "76,9%",
            "yield_increase": "+8,2%"
          },
          "drought": {
            "evidences": 433,
            "win_rate": "70,7%",
            "yield_increase": "+5,1%"
          }
        },
        "notes": "850 selected trials for the summary, of which 68% were carried out under abiotic stress conditions."
      }
    },
    {
      "name": "Yield Booster",
      "category": "Biostimulant",
      "type": "Crop productivity enhancer",
      "application_method": "Foliar application",
      "timing": "Decision taken before the growing season based on historical data and upcoming season prediction",
      "description": "In our portfolio we have a biostimulant for row crops able to ensure highest productivity and return for farmers. This solution is able to increase plant productivity through better transport of sugars and nutrients, promotion of cell division, and fatty acids biosynthesis and transport.",
      "value_proposition": "Highest crop productivity, Highest return for farmers",
      "directions_for_use": {
        "wheat": {
          "dose": "2 l/ha",
          "period": "1 application at flag leaf growth stage"
        },
        "soybean": {
          "dose": "1-2 l/ha",
          "period": "2 applications: the 1st at Vn/Ri growth stage, the 2nd at R3/R5 growth stage"
        },
        "corn": {
          "dose": "2 l/ha",
          "period": "1 application at V4-V6 growth stage"
        },
        "rice": {
          "dose": "1-2 l/ha",
          "period": "2 applications: the 1st at the beginning of booting, the 2nd at heading growth stage"
        },
        "cotton": {
          "dose": "2 l/ha",
          "period": "2 applications: the 1st before squares appear and 2nd after 3-4 weeks"
        },
        "sunflower": {
          "dose": "2 l/ha",
          "period": "1 application at 4-6 leaf growth stage"
        }
      },
      "scientific_evidence": {
        "transcriptomics": {
          "description": "Next Generation Sequencing (NGS) experiment on corn and soybean: plants treated with Yield Booster showed activation of genes involved in:",
          "activities": [
            "Transport of sugars and nutrients: Zn and Fe uptake and transport, ammoniun and nitrogen assimilation, phosphate homeostasis (uptake, sensing), phloem loading",
            "Promotion of cell division: the coordination of specific hormonal processes, including the establishment of an optimal auxin/cytokinin balance",
            "Fatty acids biosynthesis/transport: lipid transport, photosynthesis"
          ]
        },
        "phenomics": {
          "description": "Experiments on corn and soybean, where Yield Booster improved:",
          "improvements": [
            "Digital Biovolume and height",
            "Plant compactness",
            "Green Index"
          ]
        }
      },
      "field_trial_results": {
        "crop_performance": {
          "bean": {"yield_increase_percentage": 12},
          "cotton": {"yield_increase_percentage": 11},
          "sunflower": {"yield_increase_percentage": 10},
          "rice": {"yield_increase_percentage": 9},
          "soft_wheat": {"yield_increase_percentage": 6},
          "corn": {"yield_increase_percentage": 5, "yield_increase": "+0,64 t/ha", "roi": "7:1"},
          "soybean": {"yield_increase_percentage": 4, "yield_increase": "+0,27 t/ha", "roi": "5:1"},
          "oilseed_rape": {"yield_increase_percentage": 4},
          "barley": {"yield_increase_percentage": 2},
          "wheat": {"yield_increase": "+0,30 t/ha", "roi": "5:1"},
          "rice_detailed": {"yield_increase": "+0,66 t/ha", "roi": "14:1"}
        },
        "trials": {
          "rice_trials": "2017-2022 Rice Trials showed 7.4% Average Yield Increase worldwide",
          "corn_trials": "64 corn trials in 2022 with YieldB application resulted in positive yield response in 83% of trials with an average bu/A increase of 6.8 Bu/A"
        }
      }
    },
    {
      "name": "Nutrient Use Efficiency (NUE) Product",
      "category": "Biofertilizer",
      "application_method": "Seed treatment and foliar application",
      "composition": "Based on 3 strains of endophytic bacteria (Sphingobium salicis, Pseudomonas siliginis, Curtobacterium salicis)",
      "description": "New innovative product concept with dual effect on N and P use efficiency and mineral nutrient uptakes",
      "functionality": {
        "nitrogen_sources": [
          "Air – N2",
          "Soil – NO, NO3, NH3/NH4",
          "Soil – Organic, C-NP"
        ],
        "phosphate_management": [
          "Enhanced P-solubilization",
          "P and K uptake root to shoot transport",
          "Organic acid"
        ],
        "nutrient_availability": [
          "Siderophore production solubilization of micronutrients Fe, Mg, Cu, Zn, Mn, Mo"
        ]
      },
      "application_rates": {
        "foliar_application": {
          "wheat": "10-50 g/ha",
          "barley": "10-50 g/ha",
          "corn": "10-50 g/ha",
          "osr": "10-50 g/ha",
          "rice": "10-50 g/ha"
        },
        "seed_treatment": {
          "wheat": "10-50 g/T seeds",
          "barley": "10-50 g/T seeds",
          "corn": "50-150 g/T seeds",
          "osr": "100-250 g/T seeds",
          "sugarbeet": "500-1050 g/T seeds"
        }
      },
      "scientific_evidence": {
        "trials": "38 trials in corn (US, EU) 2023, 40-unit N reduction scenario - FOLIAR",
        "results": {
          "win_rate": "68% (positive response)",
          "yield_increase_percentage": "2.6%",
          "yield_increase_kg_ha": "250 kg/ha"
        }
      },
      "key_benefits": [
        "Product acts as a \"back up generator\" for plants when nutrients become limiting",
        "Versatile and easy to apply: seed treatment or foliar application",
        "Up to 2 years of shelf life",
        "High compatibility with tank mixtures(F, I, H, F)",
        "Trial data in key field crops"
      ],
      "notes": "Liquid formulation ≈ Solid formulation (1.2 L/ha = 30 g/ha). 10% difference in N regime is not assumed to generate differences within the system."
    }
  ]
}
</file>

<file path="lib/environment/clouds.ts">
import * as THREE from 'three';

/**
 * Creates cloud objects in the scene
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {number} count - Number of clouds to create
 * @returns {Array} - Array of cloud objects
 */
export const createClouds = (scene, count = 20) => {
  const clouds = [];
  
  for (let i = 0; i < count; i++) {
    const cloudGroup = new THREE.Group();
    
    // Random position and size
    const x = Math.random() * 400 - 200;
    const y = Math.random() * 30 + 50;
    const z = Math.random() * 400 - 200;
    const scale = Math.random() * 2 + 1;
    
    // Create cloud parts
    const cloudMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    
    const cloudPartsCount = Math.floor(Math.random() * 5) + 3;
    
    for (let j = 0; j < cloudPartsCount; j++) {
      const cloudGeo = new THREE.SphereGeometry(scale, 7, 7);
      const cloudPart = new THREE.Mesh(cloudGeo, cloudMaterial);
      
      // Position cloud parts
      const partX = (Math.random() - 0.5) * scale * 3;
      const partY = (Math.random() - 0.5) * scale;
      const partZ = (Math.random() - 0.5) * scale * 3;
      
      cloudPart.position.set(partX, partY, partZ);
      cloudGroup.add(cloudPart);
    }
    
    // Set cloud position and speed
    cloudGroup.position.set(x, y, z);
    cloudGroup.userData = { speed: Math.random() * 0.05 + 0.01 };
    
    // Add cloud to scene and collection
    scene.add(cloudGroup);
    clouds.push(cloudGroup);
  }
  
  return clouds;
};

/**
 * Updates cloud positions for animation
 * @param {Array} clouds - Array of cloud objects
 */
export const animateClouds = (clouds) => {
  if (clouds.length > 0) {
    clouds.forEach(cloud => {
      cloud.position.x += cloud.userData.speed;
      if (cloud.position.x > 200) {
        cloud.position.x = -200;
      }
    });
  }
};
</file>

<file path="lib/environment/index.ts">
import { createSkybox } from './skybox';
import { createTerrain, createFieldSoil, createFieldBoundary } from './terrain';
import { createClouds, animateClouds } from './clouds';

export {
  createSkybox,
  createTerrain,
  createFieldSoil,
  createFieldBoundary,
  createClouds,
  animateClouds
};
</file>

<file path="lib/environment/skybox.ts">
import * as THREE from 'three';

/**
 * Creates skybox with distant horizons
 * @param {THREE.Scene} scene - The THREE.js scene
 */
export const createSkybox = (scene) => {
  // Sky dome
  const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
  const skyMat = new THREE.MeshBasicMaterial({
    color: 0x87ceeb,
    side: THREE.BackSide
  });
  const sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);
  
  // Distant horizon
  const horizonGeo = new THREE.CylinderGeometry(1000, 1000, 10, 64, 1, true);
  
  // Create canvas for horizon texture
  const canvas = document.createElement('canvas');
  canvas.width = 1024;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  
  // Draw gradient sky
  const gradientSky = ctx.createLinearGradient(0, 0, 0, 128);
  gradientSky.addColorStop(0, '#87ceeb');
  gradientSky.addColorStop(1, '#a7d8f7');
  ctx.fillStyle = gradientSky;
  ctx.fillRect(0, 0, 1024, 128);
  
  // Draw green hills
  ctx.fillStyle = '#228B22';
  
  // Draw random hills
  let x = 0;
  while (x < 1024) {
    const width = Math.random() * 100 + 50;
    const height = Math.random() * 30 + 20;
    ctx.beginPath();
    ctx.moveTo(x, 128);
    ctx.quadraticCurveTo(x + width/2, 128 - height, x + width, 128);
    ctx.fill();
    x += width;
  }
  
  // Create texture from canvas
  const texture = new THREE.CanvasTexture(canvas);
  texture.wrapS = THREE.RepeatWrapping;
  texture.repeat.set(4, 1);
  
  const horizonMat = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.BackSide,
    transparent: true
  });
  
  const horizon = new THREE.Mesh(horizonGeo, horizonMat);
  horizon.position.y = -40;
  scene.add(horizon);
  
  return { sky, horizon };
};
</file>

<file path="lib/environment/terrain.ts">
import * as THREE from 'three';

/**
 * Creates terrain with ground planes and boundaries
 * @param {THREE.Scene} scene - The THREE.js scene
 */
export const createTerrain = (scene) => {
  const terrainObjects = [];
  
  // Large ground plane (distant terrain)
  const groundGeo = new THREE.PlaneGeometry(2000, 2000, 100, 100);
  const groundMat = new THREE.MeshStandardMaterial({
    color: 0x336633,
    side: THREE.DoubleSide,
    roughness: 0.8,
    metalness: 0.2
  });
  
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.position.y = -0.1;
  ground.receiveShadow = true;
  scene.add(ground);
  terrainObjects.push(ground);
  
  // Create farm field ground (cultivatable area)
  const farmGroundGeo = new THREE.PlaneGeometry(400, 400, 1, 1);
  const farmGroundMat = new THREE.MeshStandardMaterial({
    color: 0x5e4e35,
    side: THREE.DoubleSide,
    roughness: 0.9,
    metalness: 0
  });
  
  const farmGround = new THREE.Mesh(farmGroundGeo, farmGroundMat);
  farmGround.rotation.x = -Math.PI / 2;
  farmGround.position.y = 0;
  farmGround.receiveShadow = true;
  scene.add(farmGround);
  terrainObjects.push(farmGround);
  
  // Field borders (overall boundary)
  const borderMat = new THREE.LineBasicMaterial({ color: 0x000000 });
  const borderGeo = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(-200, 0.01, -200),
    new THREE.Vector3(-200, 0.01, 200),
    new THREE.Vector3(200, 0.01, 200),
    new THREE.Vector3(200, 0.01, -200),
    new THREE.Vector3(-200, 0.01, -200)
  ]);
  const border = new THREE.Line(borderGeo, borderMat);
  scene.add(border);
  terrainObjects.push(border);
  
  return terrainObjects;
};

/**
 * Creates a soil mesh for a specific field based on polygon shape
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {Array} vertices - Array of vertices defining the field
 * @returns {THREE.Mesh} - The created soil mesh
 */
export const createFieldSoil = (scene, vertices) => {
  // Create a 2D shape from the vertices
  const shape = new THREE.Shape();
  shape.moveTo(vertices[0][0], vertices[0][2]);
  
  for (let i = 1; i < vertices.length; i++) {
    shape.lineTo(vertices[i][0], vertices[i][2]);
  }
  
  // Close the shape
  shape.lineTo(vertices[0][0], vertices[0][2]);
  
  // Create geometry from shape
  const soilGeometry = new THREE.ShapeGeometry(shape);
  const soilMaterial = new THREE.MeshStandardMaterial({
    color: 0x6d4c41,
    roughness: 0.9,
    metalness: 0
  });
  
  const soil = new THREE.Mesh(soilGeometry, soilMaterial);
  soil.rotation.x = -Math.PI / 2;
  soil.position.y = 0.005;
  soil.receiveShadow = true;
  scene.add(soil);
  
  return soil;
};

/**
 * Creates a boundary line for a field
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {Array} vertices - Array of vertices defining the field boundary
 * @returns {THREE.Line} - The created boundary line
 */
export const createFieldBoundary = (scene, vertices) => {
  const borderMat = new THREE.LineBasicMaterial({ 
    color: 0x000000,
    linewidth: 2
  });
  
  const points = [];
  
  // Create points for the line
  vertices.forEach(vertex => {
    points.push(new THREE.Vector3(vertex[0], 0.01, vertex[2]));
  });
  
  // Close the loop
  points.push(new THREE.Vector3(vertices[0][0], 0.01, vertices[0][2]));
  
  const borderGeo = new THREE.BufferGeometry().setFromPoints(points);
  const border = new THREE.Line(borderGeo, borderMat);
  scene.add(border);
  
  return border;
};
</file>

<file path="lib/hooks/useFarmData.ts">
"use client";

import { useState, useEffect } from 'react';
import { FarmData, Crop, GeoLocation } from '@/types/farm';

// Default India (Karnataka) location
const DEFAULT_LOCATION: GeoLocation = {
    lat: 15.3173,
    lng: 75.7139
};

const DEFAULT_FARM_DATA: FarmData = {
    name: 'My Farm',
    location: DEFAULT_LOCATION,
    crops: [
        {
            id: 'crop_1',
            name: 'Rice Field',
            type: 'rice',
            acreage: 5
        }
    ],
    totalAcreage: 10,
    soilType: 'clay loam',
    waterSource: 'irrigation'
};

interface UseFarmDataReturn {
    farmData: FarmData;
    isLoading: boolean;
    updateFarmData: (data: Partial<FarmData>) => void;
    updateFarmLocation: (location: GeoLocation) => void;
    updateFarmCrops: (crops: Crop[]) => void;
    updateFarmName: (name: string) => void;
    updateFarmSize: (acreage: number) => void;
    saveFarm: () => void;
    resetFarm: () => void;
    error: string | null;
}

export function useFarmData(): UseFarmDataReturn {
    const [farmData, setFarmData] = useState<FarmData>(DEFAULT_FARM_DATA);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // Load saved farm data on initial mount
    useEffect(() => {
        const loadFarmData = () => {
            try {
                setIsLoading(true);
                const savedFarmData = localStorage.getItem('farmData');

                if (savedFarmData) {
                    const parsedData = JSON.parse(savedFarmData) as FarmData;
                    setFarmData(parsedData);
                }

                setError(null);
            } catch (err) {
                console.error('Error loading farm data:', err);
                setError('Failed to load saved farm data');
            } finally {
                setIsLoading(false);
            }
        };

        loadFarmData();
    }, []);

    // Update entire farm data object
    const updateFarmData = (data: Partial<FarmData>) => {
        setFarmData(prevData => ({
            ...prevData,
            ...data
        }));
    };

    // Update farm location
    const updateFarmLocation = (location: GeoLocation) => {
        setFarmData(prevData => ({
            ...prevData,
            location
        }));
    };

    // Update farm crops
    const updateFarmCrops = (crops: Crop[]) => {
        // Validate crops
        const totalAcreage = crops.reduce((sum, crop) => sum + crop.acreage, 0);

        if (totalAcreage > farmData.totalAcreage) {
            setError(`Total crop acreage (${totalAcreage}) exceeds farm size (${farmData.totalAcreage})`);
        } else {
            setError(null);
        }

        setFarmData(prevData => ({
            ...prevData,
            crops
        }));
    };

    // Update farm name
    const updateFarmName = (name: string) => {
        setFarmData(prevData => ({
            ...prevData,
            name
        }));
    };

    // Update farm size/acreage
    const updateFarmSize = (acreage: number) => {
        // Validate that new size is sufficient for existing crops
        const cropAcreage = farmData.crops.reduce((sum, crop) => sum + crop.acreage, 0);

        if (cropAcreage > acreage) {
            setError(`Cannot reduce farm size to ${acreage} acres as crops require ${cropAcreage} acres`);
        } else {
            setError(null);
            setFarmData(prevData => ({
                ...prevData,
                totalAcreage: acreage
            }));
        }
    };

    // Save farm data to localStorage
    const saveFarm = () => {
        try {
            localStorage.setItem('farmData', JSON.stringify(farmData));
            setError(null);
        } catch (err) {
            console.error('Error saving farm data:', err);
            setError('Failed to save farm data');
        }
    };

    // Reset farm to default
    const resetFarm = () => {
        setFarmData(DEFAULT_FARM_DATA);
        localStorage.removeItem('farmData');
        setError(null);
    };

    return {
        farmData,
        isLoading,
        updateFarmData,
        updateFarmLocation,
        updateFarmCrops,
        updateFarmName,
        updateFarmSize,
        saveFarm,
        resetFarm,
        error,
    };
}
</file>

<file path="lib/hooks/useProducts.ts">
"use client";

import { useState, useEffect } from 'react';
import { Product } from '@/types/products';

interface UseProductsReturn {
    products: Product[];
    isLoading: boolean;
    error: string | null;
    filterProductsByCategory: (category: string | null) => Product[];
    filterProductsByCrop: (cropType: string | null) => Product[];
    getProductById: (id: string) => Product | undefined;
}

export function useProducts(): UseProductsReturn {
    const [products, setProducts] = useState<Product[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchProducts = async () => {
            try {
                setIsLoading(true);
                const response = await fetch('/api/products');

                if (!response.ok) {
                    throw new Error(`Failed to fetch products: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                setProducts(data.products || []);
                setError(null);
            } catch (err) {
                console.error('Error fetching products:', err);
                setError('Failed to load products. Please try again later.');
            } finally {
                setIsLoading(false);
            }
        };

        fetchProducts();
    }, []);

    // Filter products by category
    const filterProductsByCategory = (category: string | null): Product[] => {
        if (!category) return products;
        return products.filter(product => product.category.toLowerCase() === category.toLowerCase());
    };

    // Filter products by crop compatibility
    const filterProductsByCrop = (cropType: string | null): Product[] => {
        if (!cropType) return products;
        return products.filter(product =>
            product.compatibleCrops.includes(cropType.toLowerCase())
        );
    };

    // Get a specific product by ID
    const getProductById = (id: string): Product | undefined => {
        return products.find(product => product.id === id);
    };

    return {
        products,
        isLoading,
        error,
        filterProductsByCategory,
        filterProductsByCrop,
        getProductById
    };
}
</file>

<file path="lib/services/farmEnvironmentService.ts">
import { FarmData, Crop, GeoLocation } from '@/types/farm';

interface EnvironmentalData {
    forecast?: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: {
        texture: string;
        properties: {
            bulkDensity: number;
            organicMatter: number;
            ph: number;
            waterHoldingCapacity: number;
            cationExchangeCapacity: number;
        };
    };
    stress_factors?: {
        current: {
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        };
        forecast: Array<{
            date: string;
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        }>;
    };
}

interface CropRequirements {
    temperature: {
        min: number;
        optimal: number;
        max: number;
    };
    water: {
        min: number;    // mm/day
        optimal: number;
        max: number;
    };
    soil: {
        ph: {
            min: number;
            optimal: number;
            max: number;
        };
        preferredTextures: string[];
    };
}

// Crop requirements database (simplified)
const cropRequirementsMap: Record<string, CropRequirements> = {
    rice: {
        temperature: { min: 20, optimal: 30, max: 35 },
        water: { min: 6, optimal: 10, max: 15 },
        soil: {
            ph: { min: 5.5, optimal: 6.5, max: 7.0 },
            preferredTextures: ["Clay", "Silty Clay", "Clay Loam"]
        }
    },
    wheat: {
        temperature: { min: 15, optimal: 23, max: 32 },
        water: { min: 3, optimal: 5, max: 8 },
        soil: {
            ph: { min: 6.0, optimal: 7.0, max: 7.5 },
            preferredTextures: ["Loam", "Clay Loam", "Silty Loam"]
        }
    },
    corn: {
        temperature: { min: 18, optimal: 27, max: 35 },
        water: { min: 4, optimal: 6, max: 9 },
        soil: {
            ph: { min: 5.8, optimal: 6.8, max: 7.2 },
            preferredTextures: ["Loam", "Silty Loam", "Sandy Loam"]
        }
    },
    soybean: {
        temperature: { min: 20, optimal: 28, max: 35 },
        water: { min: 4, optimal: 6, max: 8 },
        soil: {
            ph: { min: 6.0, optimal: 6.8, max: 7.5 },
            preferredTextures: ["Loam", "Silty Loam", "Clay Loam"]
        }
    },
    cotton: {
        temperature: { min: 18, optimal: 30, max: 38 },
        water: { min: 5, optimal: 7, max: 9 },
        soil: {
            ph: { min: 5.8, optimal: 7.0, max: 8.0 },
            preferredTextures: ["Loam", "Sandy Loam", "Clay Loam"]
        }
    },
    vegetable: {
        temperature: { min: 15, optimal: 24, max: 30 },
        water: { min: 3, optimal: 5, max: 7 },
        soil: {
            ph: { min: 6.0, optimal: 6.8, max: 7.5 },
            preferredTextures: ["Loam", "Silty Loam", "Sandy Loam"]
        }
    },
    fruit: {
        temperature: { min: 15, optimal: 25, max: 33 },
        water: { min: 3, optimal: 5, max: 8 },
        soil: {
            ph: { min: 6.0, optimal: 6.5, max: 7.2 },
            preferredTextures: ["Loam", "Sandy Loam", "Silty Loam"]
        }
    }
};

/**
 * Fetches environmental data for a farm location
 */
export async function fetchEnvironmentalData(location: GeoLocation): Promise<EnvironmentalData> {
    try {
        // Calculate dates for API query
        const today = new Date();
        const startDate = today.toISOString().split('T')[0];
        const endDate = new Date(today.setDate(today.getDate() + 14)).toISOString().split('T')[0];

        // Fetch forecast data
        const forecastResponse = await fetch(
            `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=forecast&startDate=${startDate}&endDate=${endDate}`
        );

        if (!forecastResponse.ok) {
            throw new Error(`Failed to fetch forecast data: ${forecastResponse.status}`);
        }

        const forecastData = await forecastResponse.json();

        // Fetch soil data
        const soilResponse = await fetch(
            `/api/environmental-data?lat=${location.lat}&lng=${location.lng}&type=soil`
        );

        if (!soilResponse.ok) {
            throw new Error(`Failed to fetch soil data: ${soilResponse.status}`);
        }

        const soilData = await soilResponse.json();

        // Combine the data
        return {
            ...forecastData,
            ...soilData
        };
    } catch (error) {
        console.error('Error fetching environmental data:', error);
        throw error;
    }
}

/**
 * Analyzes environmental conditions for a specific crop
 */
export function analyzeCropSuitability(crop: Crop, environmentalData: EnvironmentalData) {
    const cropRequirements = cropRequirementsMap[crop.type];
    const results = {
        temperature: { suitability: 0, stress: 0 },
        water: { suitability: 0, stress: 0 },
        soil: { suitability: 0, stress: 0 },
        overall: { suitability: 0, stress: 0 }
    };

    // Temperature analysis
    if (environmentalData.forecast?.daily) {
        const forecast = environmentalData.forecast.daily;
        let tempSuitabilitySum = 0;
        let tempStressSum = 0;

        forecast.forEach(day => {
            const avgTemp = day.temperature.avg;
            const { min, optimal, max } = cropRequirements.temperature;

            // Calculate temperature suitability (0-1 scale)
            let tempSuitability = 0;
            if (avgTemp < min) {
                tempSuitability = 0;
            } else if (avgTemp < optimal) {
                tempSuitability = (avgTemp - min) / (optimal - min);
            } else if (avgTemp <= max) {
                tempSuitability = 1 - (avgTemp - optimal) / (max - optimal);
            } else {
                tempSuitability = 0;
            }

            // Calculate temperature stress
            let tempStress = 0;
            if (avgTemp < min) {
                tempStress = (min - avgTemp) / min * 0.5; // Cold stress
            } else if (avgTemp > max) {
                tempStress = (avgTemp - max) / max * 0.5; // Heat stress
            }

            tempSuitabilitySum += tempSuitability;
            tempStressSum += tempStress;
        });

        results.temperature.suitability = tempSuitabilitySum / forecast.length;
        results.temperature.stress = tempStressSum / forecast.length;
    }

    // Water/precipitation analysis
    if (environmentalData.forecast?.daily) {
        const forecast = environmentalData.forecast.daily;
        let waterSuitabilitySum = 0;
        let waterStressSum = 0;

        forecast.forEach(day => {
            const precip = day.precipitation;
            const { min, optimal, max } = cropRequirements.water;

            // Calculate water suitability (0-1 scale)
            let waterSuitability = 0;
            if (precip < min) {
                waterSuitability = precip / min;
            } else if (precip < optimal) {
                waterSuitability = (precip - min) / (optimal - min);
            } else if (precip <= max) {
                waterSuitability = 1 - (precip - optimal) / (max - optimal);
            } else {
                waterSuitability = Math.max(0, 1 - (precip - max) / max);
            }

            // Calculate water stress
            let waterStress = 0;
            if (precip < min) {
                waterStress = (min - precip) / min; // Drought stress
            } else if (precip > max * 1.5) {
                waterStress = (precip - max * 1.5) / (max * 1.5); // Excess water stress
            }

            waterSuitabilitySum += waterSuitability;
            waterStressSum += waterStress;
        });

        results.water.suitability = waterSuitabilitySum / forecast.length;
        results.water.stress = waterStressSum / forecast.length;
    }

    // Soil analysis
    if (environmentalData.soil) {
        const { texture, properties } = environmentalData.soil;
        const { ph, preferredTextures } = cropRequirements.soil;

        // Calculate pH suitability
        let phSuitability = 0;
        const soilPh = properties.ph;

        if (soilPh < ph.min) {
            phSuitability = Math.max(0, soilPh / ph.min);
        } else if (soilPh < ph.optimal) {
            phSuitability = (soilPh - ph.min) / (ph.optimal - ph.min);
        } else if (soilPh <= ph.max) {
            phSuitability = 1 - (soilPh - ph.optimal) / (ph.max - ph.optimal);
        } else {
            phSuitability = Math.max(0, 1 - (soilPh - ph.max) / 2);
        }

        // Calculate texture suitability
        const textureSuitability = preferredTextures.includes(texture) ? 1 : 0.5;

        results.soil.suitability = (phSuitability + textureSuitability) / 2;
        results.soil.stress = 1 - results.soil.suitability;
    }

    // Calculate overall suitability and stress
    results.overall.suitability = (
        results.temperature.suitability +
        results.water.suitability +
        results.soil.suitability
    ) / 3;

    results.overall.stress = (
        results.temperature.stress +
        results.water.stress +
        results.soil.stress
    ) / 3;

    return results;
}

/**
 * Generates crop yield estimations based on environmental factors
 */
export function estimateCropYield(crop: Crop, environmentalData: EnvironmentalData) {
    const suitabilityResults = analyzeCropSuitability(crop, environmentalData);

    // Base yield potential per acre for each crop (tons)
    const baseYieldPotential: Record<string, number> = {
        rice: 3.5,
        wheat: 2.8,
        corn: 5.0,
        soybean: 1.8,
        cotton: 0.9,
        vegetable: 10.0,
        fruit: 7.5
    };

    // Calculate estimated yield
    const yieldPotential = baseYieldPotential[crop.type] || 1.0;
    const estimatedYield = yieldPotential * (1 - suitabilityResults.overall.stress);

    // Calculate potential improvement with bio-products
    const potentialImprovement = yieldPotential * suitabilityResults.overall.stress * 0.7;

    return {
        cropName: crop.name,
        cropType: crop.type,
        acreage: crop.acreage,
        baseYieldPotential: yieldPotential,
        estimatedYield,
        totalEstimatedYield: estimatedYield * crop.acreage,
        potentialImprovement,
        totalPotentialImprovement: potentialImprovement * crop.acreage,
        stressFactors: {
            temperature: suitabilityResults.temperature.stress,
            water: suitabilityResults.water.stress,
            soil: suitabilityResults.soil.stress
        }
    };
}

/**
 * Analyzes a farm's environmental conditions and crop suitability
 */
export async function analyzeFarm(farmData: FarmData) {
    try {
        // Fetch environmental data for farm location
        const environmentalData = await fetchEnvironmentalData(farmData.location);

        // Analyze each crop
        const cropAnalysis = farmData.crops.map(crop => {
            const suitability = analyzeCropSuitability(crop, environmentalData);
            const yieldEstimate = estimateCropYield(crop, environmentalData);

            return {
                crop,
                suitability,
                yieldEstimate
            };
        });

        // Calculate farm-wide metrics
        const totalAcreage = farmData.totalAcreage;
        const allocatedAcreage = farmData.crops.reduce((sum, crop) => sum + crop.acreage, 0);
        const farmSuitability = cropAnalysis.reduce((sum, analysis) => {
            return sum + (analysis.suitability.overall.suitability * analysis.crop.acreage);
        }, 0) / allocatedAcreage;

        return {
            farmData,
            environmentalData,
            cropAnalysis,
            totalAcreage,
            allocatedAcreage,
            unallocatedAcreage: totalAcreage - allocatedAcreage,
            farmSuitability
        };
    } catch (error) {
        console.error('Error analyzing farm:', error);
        throw error;
    }
}
</file>

<file path="lib/services/modelLoader.ts">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

// Cache for already loaded models to avoid duplicate loading
const modelCache: Map<string, THREE.Group> = new Map();

// Loading manager to track overall loading progress
const loadingManager = new THREE.LoadingManager();
const gltfLoader = new GLTFLoader(loadingManager);

// Loading progress callback handlers
let onProgressCallback: ((progress: number) => void) | null = null;
let onCompleteCallback: (() => void) | null = null;

// Configure loading manager
loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
  const progress = itemsLoaded / itemsTotal;
  if (onProgressCallback) {
    onProgressCallback(progress);
  }
};

loadingManager.onLoad = () => {
  if (onCompleteCallback) {
    onCompleteCallback();
  }
};

/**
 * Set callbacks for loading progress and completion
 */
export const setLoadingCallbacks = (
  onProgress: (progress: number) => void,
  onComplete: () => void
) => {
  onProgressCallback = onProgress;
  onCompleteCallback = onComplete;
};

/**
 * Load a GLB model and return a clone of it
 * @param {string} path - Path to the GLB file
 * @returns {Promise<THREE.Group>} - Promise that resolves to the loaded model
 */
export const loadModel = async (path: string): Promise<THREE.Group> => {
  // Check if model is already in cache
  if (modelCache.has(path)) {
    // Clone the cached model to avoid modifying the original
    return modelCache.get(path)!.clone();
  }

  try {
    // Load the model
    const gltf = await new Promise<any>((resolve, reject) => {
      gltfLoader.load(
        path,
        (gltf) => resolve(gltf),
        undefined,
        (error) => reject(error)
      );
    });

    // Process the model
    const model = gltf.scene;
    
    // Normalize model size and position
    normalizeModel(model);
    
    // Enable shadows for all meshes in the model
    model.traverse((node: THREE.Object3D) => {
      if (node instanceof THREE.Mesh) {
        node.castShadow = true;
        node.receiveShadow = true;
      }
    });

    // Cache the original model
    modelCache.set(path, model.clone());
    
    return model;
  } catch (error) {
    console.error(`Error loading model ${path}:`, error);
    throw error;
  }
};

/**
 * Preload models to ensure they're available when needed
 * @param {Array<string>} paths - Array of paths to GLB files
 * @returns {Promise<void>}
 */
export const preloadModels = async (paths: string[]): Promise<void> => {
  const promises = paths.map(path => {
    // Only load if not already in cache
    if (!modelCache.has(path)) {
      return loadModel(path);
    }
    return Promise.resolve();
  });

  await Promise.all(promises);
};

/**
 * Get paths to crop models for different types
 * @returns {Object} - Object with crop types as keys and model paths as values
 */
export const getCropModelPaths = () => {
  return {
    corn: '/models/corn.glb',
    wheat: '/models/wheat.glb',
    soybean: '/models/soybean.glb',
    cotton: '/models/cotton.glb',
    rice: '/models/rice.glb'
  };
};

/**
 * Normalize a loaded model to ensure consistent scaling and positioning
 * @param {THREE.Group} model - The model to normalize
 */
const normalizeModel = (model: THREE.Group): void => {
  // Calculate the model's bounding box
  const bbox = new THREE.Box3().setFromObject(model);
  const size = new THREE.Vector3();
  bbox.getSize(size);
  
  // Get the model's height (usually the Y dimension)
  const modelHeight = size.y;
  
  // Move model so its base is at y=0
  const center = new THREE.Vector3();
  bbox.getCenter(center);
  model.position.y -= bbox.min.y;
  
  // Apply a consistent scale to make models usable with our growth system
  // We don't adjust scale here - instead we'll let the createPlant function handle scaling
  // based on the actual model size and desired plant height
};

/**
 * Get the dimensions of a model
 * @param {THREE.Group} model - The model to measure
 * @returns {Object} - Object containing width, height, and depth of the model
 */
export const getModelDimensions = (model: THREE.Group): { width: number, height: number, depth: number } => {
  const bbox = new THREE.Box3().setFromObject(model);
  const size = new THREE.Vector3();
  bbox.getSize(size);
  
  return {
    width: size.x,
    height: size.y,
    depth: size.z
  };
};

/**
 * Clear the model cache
 */
export const clearModelCache = () => {
  modelCache.clear();
};
</file>

<file path="lib/simulation/cameraUtils.ts">
/**
 * Adjusts camera to view the entire field
 * @param {Array} scaledPolygon - Scaled polygon vertices defining the field
 * @param {THREE.PerspectiveCamera} camera - The THREE.js camera
 * @param {OrbitControls} controls - The OrbitControls instance
 */
export const adjustCameraView = (scaledPolygon, camera, controls) => {
    if (!camera || !controls) return;
    
    // Find bounding box
    let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
    
    scaledPolygon.forEach(point => {
      minX = Math.min(minX, point[0]);
      maxX = Math.max(maxX, point[0]);
      minZ = Math.min(minZ, point[2]);
      maxZ = Math.max(maxZ, point[2]);
    });
    
    // Calculate center and size
    const centerX = (minX + maxX) / 2;
    const centerZ = (minZ + maxZ) / 2;
    const width = maxX - minX;
    const depth = maxZ - minZ;
    const size = Math.max(width, depth);
    
    // Position camera to see the entire field, adjusted for the sidebar
    camera.position.set(centerX + 20, size * 1.2, centerZ + size * 1.5);
    controls.target.set(centerX, 0, centerZ);
    controls.update();
  };
</file>

<file path="lib/simulation/sceneSetup.ts">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';

/**
 * Sets up the THREE.js scene, camera, renderer, and lighting
 * @param {HTMLElement} container - DOM element to attach the renderer to
 * @returns {Object} - Scene setup objects
 */
export const setupScene = (container) => {
  // Create scene
  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0xd7f0ff, 0.0025);
  
  // Create camera
  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    2000
  );
  camera.position.set(0, 150, 200);
  
  // Create renderer
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x87ceeb);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  container.appendChild(renderer.domElement);
  
  // Setup lighting
  setupLighting(scene);
  
  // Setup controls
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.screenSpacePanning = false;
  controls.minDistance = 5;
  controls.maxDistance = 500;
  controls.maxPolarAngle = Math.PI / 2 - 0.1;
  
  // Setup resize handler
  const handleResize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  };
  window.addEventListener('resize', handleResize);
  
  return {
    scene,
    camera,
    renderer,
    controls,
    handleResize,
    dispose: () => {
      window.removeEventListener('resize', handleResize);
      container.removeChild(renderer.domElement);
      renderer.dispose();
    }
  };
};

/**
 * Sets up lighting for the scene
 * @param {THREE.Scene} scene - The THREE.js scene
 * @returns {Object} - Created lights
 */
export const setupLighting = (scene) => {
  // Ambient light
  const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
  scene.add(ambientLight);
  
  // Directional light (sun)
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(100, 200, 100);
  directionalLight.castShadow = true;
  directionalLight.shadow.camera.near = 0.5;
  directionalLight.shadow.camera.far = 500;
  directionalLight.shadow.camera.left = -100;
  directionalLight.shadow.camera.right = 100;
  directionalLight.shadow.camera.top = 100;
  directionalLight.shadow.camera.bottom = -100;
  directionalLight.shadow.mapSize.width = 2048;
  directionalLight.shadow.mapSize.height = 2048;
  scene.add(directionalLight);
  
  return { ambientLight, directionalLight };
};
</file>

<file path="lib/simulation/timelineControler.ts">
// lib/simulation/timelineController.ts

import { RainSystem, applyWeatherToScene } from '../weather';
import { updatePlantsForGrowthStage } from './plantGrowth';

/**
 * Initialize timeline controls for the scene
 * @param {Object} timeline - Timeline data
 * @param {THREE.Scene} scene - The scene
 * @param {Object} sceneObjects - Object containing references to scene objects
 * @param {Function} setDayInfo - Function to update UI with day information
 * @returns {Object} Timeline controller
 */
export const initializeTimelineController = (timeline, scene, sceneObjects, setDayInfo) => {
  let currentDayIndex = 0;
  let paused = true;
  let autoAdvanceInterval = null;
  let rainSystem = null;
  
  // Initialize rain system
  rainSystem = new RainSystem(scene, 0);
  
  // Update the scene for a specific day
  const updateSceneForDay = (dayIndex) => {
    if (dayIndex < 0 || dayIndex >= timeline.days.length) return;
    
    const dayData = timeline.days[dayIndex];
    
    // Update plants with improved growth logic
    if (sceneObjects.plants && sceneObjects.plants.length > 0) {
      updatePlantsForGrowthStage(dayData, sceneObjects.plants, timeline.type);
    }
    
    // Update weather effects
    applyWeatherToScene(
      dayData, 
      scene, 
      { 
        directional: sceneObjects.directionalLight, 
        ambient: sceneObjects.ambientLight 
      },
      sceneObjects.clouds,
      rainSystem
    );
    
    // Update UI
    if (setDayInfo) {
      setDayInfo(dayData);
    }
    
    currentDayIndex = dayIndex;
  };
  
  // Set up auto-advance
  const setAutoAdvance = (enabled, intervalMs = 1000) => {
    clearInterval(autoAdvanceInterval);
    paused = !enabled;
    
    if (enabled) {
      autoAdvanceInterval = setInterval(() => {
        const nextDay = currentDayIndex + 1;
        if (nextDay < timeline.days.length) {
          updateSceneForDay(nextDay);
        } else {
          // Stop at the end
          clearInterval(autoAdvanceInterval);
          paused = true;
        }
      }, intervalMs);
    }
  };
  
  // Start with day 0
  updateSceneForDay(0);
  
  return {
    getCurrentDay: () => timeline.days[currentDayIndex],
    getCurrentDayIndex: () => currentDayIndex,
    getTotalDays: () => timeline.days.length,
    setDay: (dayIndex) => {
      updateSceneForDay(dayIndex);
    },
    nextDay: () => {
      if (currentDayIndex < timeline.days.length - 1) {
        updateSceneForDay(currentDayIndex + 1);
      }
    },
    prevDay: () => {
      if (currentDayIndex > 0) {
        updateSceneForDay(currentDayIndex - 1);
      }
    },
    isPaused: () => paused,
    play: () => setAutoAdvance(true),
    pause: () => setAutoAdvance(false),
    setSpeed: (speedFactor) => {
      const wasPlaying = !paused;
      if (wasPlaying) {
        pause();
        setAutoAdvance(true, 1000 / speedFactor);
      }
    },
    cleanup: () => {
      clearInterval(autoAdvanceInterval);
      if (rainSystem) {
        rainSystem.dispose();
      }
    }
  };
};
</file>

<file path="lib/utils/coordinateUtils.ts">
/**
 * Utility functions for working with geo coordinates and polygon conversions
 */

/**
 * Converts geo coordinates (latitude, longitude) to normalized 3D coordinates
 * suitable for use in Three.js. This keeps the scale consistent with the existing
 * polygon format [-30, 0, -30], [30, 0, 30] etc.
 * 
 * @param farmPolygon Array of lat/long points
 * @param farmLocation Center point of the farm
 * @param scale Scale factor to normalize the coordinates (default: 60)
 * @returns Array of 3D points [x, y, z] for Three.js
 */
export function convertGeoPolygonTo3D(
    farmPolygon: Array<{latitude: number; longitude: number}>,
    farmLocation: {latitude: number; longitude: number},
    scale: number = 60
  ): Array<[number, number, number]> {
    // If we don't have a valid polygon, return a default square
    if (!farmPolygon || farmPolygon.length < 3) {
      return [
        [-30, 0, -30],
        [-30, 0, 30],
        [30, 0, 30],
        [30, 0, -30]
      ];
    }
    
    // Calculate the max distance from center to normalize
    let maxDistance = 0;
    
    for (const point of farmPolygon) {
      // Calculate distance from center
      const latDiff = point.latitude - farmLocation.latitude;
      const lngDiff = point.longitude - farmLocation.longitude;
      const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
      
      if (distance > maxDistance) {
        maxDistance = distance;
      }
    }
    
    // Prevent division by zero
    if (maxDistance === 0) maxDistance = 0.0001;
    
    // Normalize factor to keep within our scale
    const normalizeFactor = scale / maxDistance;
    
    // Convert each point
    return farmPolygon.map(point => {
      // Calculate normalized differences - note we invert latitude for z-axis
      const x = (point.longitude - farmLocation.longitude) * normalizeFactor;
      const z = -(point.latitude - farmLocation.latitude) * normalizeFactor; 
      
      // y is always 0 for flat terrain
      return [x, 0, z] as [number, number, number];
    });
  }
  
  /**
   * Converts a URL parameters polygon string to the geo polygon format
   * 
   * @param polygonString The URL-encoded polygon string
   * @returns Array of latitude/longitude points
   */
  export function parsePolygonFromUrl(polygonString: string | null): Array<{latitude: number; longitude: number}> {
    if (!polygonString) return [];
    
    try {
      return JSON.parse(polygonString);
    } catch (e) {
      console.error('Failed to parse polygon from URL', e);
      return [];
    }
  }
</file>

<file path="lib/weather/index.ts">
import * as THREE from 'three';

// Weather constants
export const WEATHER_TYPES = {
  SUNNY: 'sunny',
  PARTLY_CLOUDY: 'partly_cloudy',
  CLOUDY: 'cloudy',
  RAINY: 'rainy',
  STORMY: 'stormy'
};

// Weather probabilities (can be adjusted seasonally)
const BASE_WEATHER_PROBABILITIES = {
  [WEATHER_TYPES.SUNNY]: 0.4,
  [WEATHER_TYPES.PARTLY_CLOUDY]: 0.3,
  [WEATHER_TYPES.CLOUDY]: 0.15,
  [WEATHER_TYPES.RAINY]: 0.1,
  [WEATHER_TYPES.STORMY]: 0.05
};

// Weather effects settings
const WEATHER_SETTINGS = {
  [WEATHER_TYPES.SUNNY]: {
    skyColor: 0x87ceeb,
    fogColor: 0xd7f0ff,
    fogDensity: 0.0025,
    lightIntensity: 1.0,
    ambientIntensity: 0.6,
    rainParticles: 0,
    cloudOpacity: 0.8,
    cloudCount: 10
  },
  [WEATHER_TYPES.PARTLY_CLOUDY]: {
    skyColor: 0x87ceeb,
    fogColor: 0xd7f0ff,
    fogDensity: 0.003,
    lightIntensity: 0.8,
    ambientIntensity: 0.5,
    rainParticles: 0,
    cloudOpacity: 0.9,
    cloudCount: 20
  },
  [WEATHER_TYPES.CLOUDY]: {
    skyColor: 0xa3b5c7,
    fogColor: 0xc7c7c7,
    fogDensity: 0.004,
    lightIntensity: 0.6,
    ambientIntensity: 0.4,
    rainParticles: 0,
    cloudOpacity: 1.0,
    cloudCount: 30
  },
  [WEATHER_TYPES.RAINY]: {
    skyColor: 0x708090,
    fogColor: 0xa3a3a3,
    fogDensity: 0.006,
    lightIntensity: 0.5,
    ambientIntensity: 0.3,
    rainParticles: 1000,
    cloudOpacity: 1.0,
    cloudCount: 35
  },
  [WEATHER_TYPES.STORMY]: {
    skyColor: 0x4a5259,
    fogColor: 0x7a7a7a,
    fogDensity: 0.008,
    lightIntensity: 0.4,
    ambientIntensity: 0.2,
    rainParticles: 2000,
    cloudOpacity: 1.0,
    cloudCount: 40
  }
};

/**
 * Generate weather data for a specified number of days
 * @param {number} days - Number of days to generate weather for
 * @param {Date} startDate - Starting date
 * @returns {Array} - Array of day objects with weather data
 */
export const generateWeatherData = (days, startDate = new Date('2025-03-20')) => {
  const weatherData = [];
  const currentDate = new Date(startDate);
  
  // Get the proper month for seasonality
  const getSeasonalFactor = (date) => {
    const month = date.getMonth();
    // Northern hemisphere seasons (adjust if needed)
    if (month >= 2 && month <= 4) return 'spring'; // March-May
    if (month >= 5 && month <= 7) return 'summer'; // June-August
    if (month >= 8 && month <= 10) return 'fall';  // September-November
    return 'winter'; // December-February
  };
  
  // Adjust weather probabilities based on season
  const getSeasonalProbabilities = (season) => {
    const probs = { ...BASE_WEATHER_PROBABILITIES };
    
    switch (season) {
      case 'spring':
        probs[WEATHER_TYPES.RAINY] = 0.2;
        probs[WEATHER_TYPES.SUNNY] = 0.3;
        break;
      case 'summer':
        probs[WEATHER_TYPES.SUNNY] = 0.5;
        probs[WEATHER_TYPES.RAINY] = 0.1;
        break;
      case 'fall':
        probs[WEATHER_TYPES.CLOUDY] = 0.25;
        probs[WEATHER_TYPES.RAINY] = 0.15;
        break;
      case 'winter':
        probs[WEATHER_TYPES.SUNNY] = 0.2;
        probs[WEATHER_TYPES.CLOUDY] = 0.3;
        break;
    }
    
    return probs;
  };
  
  // Create a coherent sequence of weather (not too random)
  let prevWeather = null;
  
  for (let i = 0; i < days; i++) {
    const date = new Date(currentDate);
    const season = getSeasonalFactor(date);
    const probabilities = getSeasonalProbabilities(season);
    
    // Weather tends to persist (we'll use this to create more realistic sequences)
    let weather;
    if (prevWeather && Math.random() < 0.7) {
      // 70% chance weather is similar to previous day
      const possibleWeathers = Object.keys(WEATHER_TYPES);
      const prevIndex = possibleWeathers.indexOf(prevWeather);
      
      // Get a weather that's at most one step away from the previous
      const maxStep = 1;
      const minIndex = Math.max(0, prevIndex - maxStep);
      const maxIndex = Math.min(possibleWeathers.length - 1, prevIndex + maxStep);
      const randomIndex = minIndex + Math.floor(Math.random() * (maxIndex - minIndex + 1));
      
      weather = possibleWeathers[randomIndex];
    } else {
      // Completely random weather based on probabilities
      const rand = Math.random();
      let cumulativeProbability = 0;
      
      for (const [type, probability] of Object.entries(probabilities)) {
        cumulativeProbability += probability;
        if (rand < cumulativeProbability) {
          weather = type;
          break;
        }
      }
    }
    
    prevWeather = weather;
    
    // Generate temperature based on season and weather
    let baseTemp = 0;
    switch (season) {
      case 'spring': baseTemp = 15; break; // ~60°F
      case 'summer': baseTemp = 25; break; // ~77°F
      case 'fall': baseTemp = 18; break;   // ~64°F
      case 'winter': baseTemp = 5; break;  // ~41°F
    }
    
    // Adjust for weather conditions
    let tempModifier = 0;
    switch (weather) {
      case WEATHER_TYPES.SUNNY: tempModifier = 5; break;
      case WEATHER_TYPES.PARTLY_CLOUDY: tempModifier = 2; break;
      case WEATHER_TYPES.CLOUDY: tempModifier = 0; break;
      case WEATHER_TYPES.RAINY: tempModifier = -3; break;
      case WEATHER_TYPES.STORMY: tempModifier = -5; break;
    }
    
    // Add some randomness
    const tempVariance = (Math.random() * 4) - 2; // -2 to +2 degrees
    
    // Generate humidity based on weather
    let baseHumidity = 0;
    switch (weather) {
      case WEATHER_TYPES.SUNNY: baseHumidity = 30; break;
      case WEATHER_TYPES.PARTLY_CLOUDY: baseHumidity = 45; break;
      case WEATHER_TYPES.CLOUDY: baseHumidity = 60; break;
      case WEATHER_TYPES.RAINY: baseHumidity = 80; break;
      case WEATHER_TYPES.STORMY: baseHumidity = 90; break;
    }
    
    // Add some randomness to humidity
    const humidityVariance = (Math.random() * 10) - 5; // -5 to +5 percent
    
    // Generate a daily growth factor based on conditions
    // Plants like moderate temperature, good sunlight, and adequate moisture
    const tempFactor = 1 - Math.abs(22 - (baseTemp + tempModifier + tempVariance)) / 22;
    const sunFactor = weather === WEATHER_TYPES.SUNNY ? 1.0 : 
                      weather === WEATHER_TYPES.PARTLY_CLOUDY ? 0.8 : 
                      weather === WEATHER_TYPES.CLOUDY ? 0.6 : 
                      weather === WEATHER_TYPES.RAINY ? 0.4 : 0.3;
    const moistureFactor = Math.min(1.0, (baseHumidity + humidityVariance) / 70);
    
    // Calculate growth factor (ideally between 0 and 1)
    const growthFactor = (tempFactor * 0.4 + sunFactor * 0.3 + moistureFactor * 0.3);
    
    weatherData.push({
      date,
      dayNumber: i + 1,
      dateString: date.toLocaleDateString(),
      weather,
      temperature: Math.round((baseTemp + tempModifier + tempVariance) * 10) / 10,
      humidity: Math.round(baseHumidity + humidityVariance),
      growthFactor: Math.max(0, Math.min(1, growthFactor)),
      settings: WEATHER_SETTINGS[weather]
    });
    
    // Increment the date by one day
    currentDate.setDate(currentDate.getDate() + 1);
  }
  
  return weatherData;
};

// Rain particle system
export class RainSystem {
  constructor(scene, count) {
    this.scene = scene;
    this.count = count;
    this.particles = null;
    
    if (count > 0) {
      this.createRain();
    }
  }
  
  createRain() {
    if (this.particles) {
      this.scene.remove(this.particles);
    }
    
    if (this.count <= 0) return;
    
    // Create rain particles
    const rainGeometry = new THREE.BufferGeometry();
    const rainVertices = [];
    const rainVelocity = [];
    
    const limit = 100; // Area limit
    
    for (let i = 0; i < this.count; i++) {
      // Random positions within a reasonable area
      const x = (Math.random() * 2 - 1) * limit;
      const y = (Math.random() * 100) + 10;
      const z = (Math.random() * 2 - 1) * limit;
      
      rainVertices.push(x, y, z);
      
      // Velocity vector (falling down with slight angle)
      const velocity = 0.1 + Math.random() * 0.3;
      rainVelocity.push(0, -velocity, 0);
    }
    
    rainGeometry.setAttribute('position', new THREE.Float32BufferAttribute(rainVertices, 3));
    rainGeometry.setAttribute('velocity', new THREE.Float32BufferAttribute(rainVelocity, 3));
    
    const rainMaterial = new THREE.PointsMaterial({
      color: 0xaaaaaa,
      size: 0.15,
      transparent: true,
      opacity: 0.7
    });
    
    this.particles = new THREE.Points(rainGeometry, rainMaterial);
    this.scene.add(this.particles);
  }
  
  update() {
    if (!this.particles) return;
    
    const positions = this.particles.geometry.attributes.position;
    const velocity = this.particles.geometry.attributes.velocity;
    
    for (let i = 0; i < positions.count; i++) {
      // Update position based on velocity
      positions.array[i * 3 + 0] += velocity.array[i * 3 + 0]; // x
      positions.array[i * 3 + 1] += velocity.array[i * 3 + 1]; // y
      positions.array[i * 3 + 2] += velocity.array[i * 3 + 2]; // z
      
      // Reset particles that go below ground level
      if (positions.array[i * 3 + 1] < 0) {
        const limit = 100;
        positions.array[i * 3 + 0] = (Math.random() * 2 - 1) * limit; // x
        positions.array[i * 3 + 1] = 100 + Math.random() * 20; // y
        positions.array[i * 3 + 2] = (Math.random() * 2 - 1) * limit; // z
      }
    }
    
    positions.needsUpdate = true;
  }
  
  setCount(count) {
    if (this.count !== count) {
      this.count = count;
      this.createRain();
    }
  }
  
  dispose() {
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      this.particles.material.dispose();
      this.particles = null;
    }
  }
}

/**
 * Apply weather settings to the scene
 * @param {Object} weather - Weather data object
 * @param {THREE.Scene} scene - The scene to apply weather to
 * @param {Object} lightRefs - Object containing references to lights
 * @param {Array} cloudRefs - Array of cloud objects
 * @param {RainSystem} rainSystem - Rain particle system
 */
export const applyWeatherToScene = (weather, scene, lightRefs, cloudRefs, rainSystem) => {
  if (!weather || !scene || !weather.settings) {
    console.error('Missing required parameters in applyWeatherToScene:', 
                 { weatherExists: !!weather, sceneExists: !!scene, 
                   settingsExist: weather ? !!weather.settings : false });
    return { rainSystem }; // Return early to prevent error
  }
  
  const settings = weather.settings;
  
  // Update fog
  if (scene.fog) {
    scene.fog.color.set(settings.fogColor);
    scene.fog.density = settings.fogDensity;
  } else {
    scene.fog = new THREE.FogExp2(settings.fogColor, settings.fogDensity);
  }
  
  // Update sky color
  scene.background = new THREE.Color(settings.skyColor);
  
  // Update lights
  if (lightRefs && lightRefs.directional) {
    lightRefs.directional.intensity = settings.lightIntensity;
  }
  
  if (lightRefs && lightRefs.ambient) {
    lightRefs.ambient.intensity = settings.ambientIntensity;
  }
  
  // Update cloud opacity and count
  if (cloudRefs && cloudRefs.length > 0) {
    // Set visibility for all clouds
    cloudRefs.forEach((cloud, index) => {
      if (cloud.material) {
        cloud.material.opacity = settings.cloudOpacity;
      } else if (cloud.children && cloud.children.length > 0) {
        cloud.children.forEach(part => {
          if (part.material) {
            part.material.opacity = settings.cloudOpacity;
          }
        });
      }
      
      // Hide excess clouds if we need fewer
      if (index < settings.cloudCount) {
        cloud.visible = true;
      } else {
        cloud.visible = false;
      }
    });
  }
  
  // Update rain
  if (rainSystem) {
    rainSystem.setCount(settings.rainParticles);
  }
  
  return { 
    rainSystem
  };
};
</file>

<file path="public/data/mock-environment.json">
{
  "forecast": {
    "daily": [
      {
        "date": "2025-03-19",
        "temperature": {
          "max": 28.4,
          "min": 18.2,
          "avg": 23.1
        },
        "precipitation": 0,
        "humidity": 65.2,
        "windSpeed": 3.4,
        "globalRadiation": 6750
      },
      {
        "date": "2025-03-20",
        "temperature": {
          "max": 29.1,
          "min": 19.3,
          "avg": 24.2
        },
        "precipitation": 0,
        "humidity": 62.1,
        "windSpeed": 2.8,
        "globalRadiation": 7020
      },
      {
        "date": "2025-03-21",
        "temperature": {
          "max": 27.5,
          "min": 17.8,
          "avg": 22.6
        },
        "precipitation": 5.3,
        "humidity": 78.4,
        "windSpeed": 4.6,
        "globalRadiation": 4250
      },
      {
        "date": "2025-03-22",
        "temperature": {
          "max": 24.8,
          "min": 16.9,
          "avg": 20.3
        },
        "precipitation": 12.7,
        "humidity": 83.9,
        "windSpeed": 5.2,
        "globalRadiation": 3850
      },
      {
        "date": "2025-03-23",
        "temperature": {
          "max": 26.2,
          "min": 17.5,
          "avg": 21.8
        },
        "precipitation": 2.1,
        "humidity": 75.3,
        "windSpeed": 3.9,
        "globalRadiation": 5420
      },
      {
        "date": "2025-03-24",
        "temperature": {
          "max": 28.7,
          "min": 18.9,
          "avg": 23.5
        },
        "precipitation": 0,
        "humidity": 64.8,
        "windSpeed": 3.1,
        "globalRadiation": 6980
      },
      {
        "date": "2025-03-25",
        "temperature": {
          "max": 30.2,
          "min": 19.7,
          "avg": 24.8
        },
        "precipitation": 0,
        "humidity": 59.2,
        "windSpeed": 2.5,
        "globalRadiation": 7240
      }
    ],
    "hourly": [
      {
        "datetime": "2025-03-19T00:00:00",
        "temperature": 19.2,
        "humidity": 72.5,
        "windSpeed": 2.1,
        "precipitation": 0,
        "cloudCover": 15
      },
      {
        "datetime": "2025-03-19T01:00:00",
        "temperature": 18.7,
        "humidity": 74.8,
        "windSpeed": 1.8,
        "precipitation": 0,
        "cloudCover": 10
      }
    ]
  },
  "historical": {
    "temperature": {
      "avg": 24.5,
      "max": 35.2,
      "min": 15.1
    },
    "precipitation": {
      "annual": 850,
      "monthly": [45, 60, 75, 90, 120, 65, 45, 35, 70, 95, 85, 65]
    }
  },
  "soil": {
    "texture": "Clay Loam",
    "properties": {
      "bulkDensity": 1.35,
      "organicMatter": 2.8,
      "ph": 6.5,
      "waterHoldingCapacity": 0.22,
      "cationExchangeCapacity": 12.5
    }
  },
  "stress_factors": {
    "current": {
      "drought": 0.2,
      "heat": 0.1,
      "nutrient_deficiency": 0.05
    },
    "forecast": [
      {
        "date": "2025-03-20",
        "drought": 0.25,
        "heat": 0.15,
        "nutrient_deficiency": 0.05
      },
      {
        "date": "2025-03-21",
        "drought": 0.15,
        "heat": 0.1,
        "nutrient_deficiency": 0.05
      },
      {
        "date": "2025-03-22",
        "drought": 0.05,
        "heat": 0.05,
        "nutrient_deficiency": 0.05
      }
    ]
  }
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="types/farm.ts">
export interface GeoLocation {
    lat: number;
    lng: number;
}

export interface Crop {
    id: string;
    name: string;
    type: CropType;
    acreage: number;
}

export type CropType =
    | 'rice'
    | 'wheat'
    | 'corn'
    | 'soybean'
    | 'cotton'
    | 'vegetable'
    | 'fruit';

export interface FarmData {
    id?: string;
    name: string;
    location: GeoLocation;
    crops: Crop[];
    totalAcreage: number;
    soilType?: string;
    waterSource?: string;
}
</file>

<file path="types/products.ts">
export type ProductCategory = 'Biocontrol' | 'Biofertilizer' | 'Biostimulant';

export interface Product {
    id: string;
    name: string;
    category: ProductCategory;
    type: string;
    description: string;
    applicationMethod: string;
    compatibleCrops: string[];
    dosageRate: Record<string, string>;
    applicationTiming: Record<string, string>;
    effectivenessRating: number; // 1-10 scale
    roiRating: number; // Return on investment rating
    imageUrl?: string;
}

export interface ApplicationSchedule {
    productId: string;
    day: number;
    cropType: string;
    dosage: string;
}
</file>

<file path="types/simulation.ts">
import { Crop } from './farm';
import { Product } from './products';

export interface SimulationState {
    // Timeline
    currentDay: number;
    totalDays: number;
    isPlaying: boolean;
    playbackSpeed: number;

    // Selections
    selectedCropId: string | null;
    selectedProducts: Record<string, string[]>; // Map of cropId -> productIds

    // Results
    yieldEstimates: Record<string, CropYieldEstimate>;
    environmentalData: EnvironmentalData | null;
}

export interface CropYieldEstimate {
    cropId: string;
    cropName: string;
    cropType: string;
    baseYieldPerAcre: number;
    estimatedYield: number;
    totalEstimatedYield: number;
    potentialImprovement: number;
    totalPotentialImprovement: number;
    productEffect?: number;
    stressFactors: {
        temperature: number;
        water: number;
        soil: number;
        overall: number;
    };
}

export interface EnvironmentalData {
    forecast?: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: {
        texture: string;
        properties: {
            bulkDensity: number;
            organicMatter: number;
            ph: number;
            waterHoldingCapacity: number;
            cationExchangeCapacity: number;
        };
    };
    stress_factors?: {
        current: {
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        };
        forecast: Array<{
            date: string;
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        }>;
    };
}

export interface SimulationAction {
    type: string;
    payload?: any;
}

// Simulation event types that can be tracked
export type SimulationEvent =
    | 'CROP_PLANTED'
    | 'PRODUCT_APPLIED'
    | 'STRESS_DETECTED'
    | 'HARVEST_READY'
    | 'WEATHER_CHANGE';

export interface SimulationEventData {
    type: SimulationEvent;
    day: number;
    cropId?: string;
    productId?: string;
    message: string;
    severity?: 'info' | 'warning' | 'success';
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="app/api/environmental-data/route.ts">
import { NextRequest, NextResponse } from 'next/server';

// Define interfaces for API responses
interface CEHubResponse {
    success: boolean;
    data: any;
    error?: string;
}

interface WeatherData {
    forecast: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: any;
}

/**
 * Environmental data API route handler
 * Fetches weather forecast and soil data from CE Hub API
 */
export async function GET(request: NextRequest) {
    const searchParams = request.nextUrl.searchParams;
    const lat = searchParams.get('lat');
    const lng = searchParams.get('lng');
    const type = searchParams.get('type') || 'forecast';
    const startDate = searchParams.get('startDate') || new Date().toISOString().split('T')[0];
    const endDate = searchParams.get('endDate') || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    // Validate required parameters
    if (!lat || !lng) {
        return NextResponse.json(
            { error: 'Missing required parameters: lat and lng' },
            { status: 400 }
        );
    }

    try {
        // Get API config based on endpoint type
        let apiUrl, apiKey, apiEndpoint, requestBody, requestMethod = 'GET';
        let headers: Record<string, string> = { 'Content-Type': 'application/json' };

        // Configure API parameters based on request type
        if (type === 'forecast') {
            // FORECAST API CONFIGURATION
            apiUrl = process.env.CE_HUB_FORECAST_API_URL;
            apiKey = process.env.CE_HUB_FORECAST_API_KEY;

            if (!apiUrl || !apiKey) {
                console.log('Forecast API config missing, using mock data');
                return NextResponse.json(await getMockData(type, lat, lng, startDate, endDate));
            }

            console.log(`Forecast API config: ${apiUrl} ${apiKey}`);
            headers['ApiKey'] = apiKey;

            // Match Postman example for Forecast API path
            apiEndpoint = `${apiUrl}/api/Forecast/ShortRangeForecastDaily?latitude=${lat}&longitude=${lng}&startDate=${startDate}&endDate=${endDate}&supplier=Meteoblue&measureLabel=TempAir_DailyMax;TempAir_DailyMin;TempAir_DailyAvg;Precip_DailySum;HumidityRel_DailyAvg;WindSpeed_DailyAvg;GlobalRadiation_DailySum&format=json`;
        }
        else if (type === 'historical') {
            // HISTORICAL API CONFIGURATION
            apiUrl = process.env.CE_HUB_HISTORICAL_API_URL;
            apiKey = process.env.CE_HUB_HISTORICAL_API_KEY;

            if (!apiUrl || !apiKey) {
                console.log('Historical API config missing, using mock data');
                return NextResponse.json(await getMockData(type, lat, lng, startDate, endDate));
            }

            console.log(`Historical API config: ${apiUrl} ${apiKey}`);

            // For historical API, key goes in URL
            apiEndpoint = `${apiUrl}?apikey=${apiKey}`;
            requestMethod = 'POST';

            // Match Postman example for Historical API
            requestBody = {
                units: {
                    temperature: "C",
                    velocity: "km/h", // Changed from m/s to match Postman example
                    length: "metric",
                    energy: "watts"
                },
                geometry: {
                    type: "MultiPoint", // Changed from Point to match Postman
                    coordinates: [[parseFloat(lng), parseFloat(lat)]],
                    locationNames: ["Location"],
                    mode: "preferLandWithMatchingElevation"
                },
                format: "json",
                timeIntervals: [`${startDate}T+00:00/${endDate}T+00:00`],
                timeIntervalsAlignment: "none",
                queries: [
                    {
                        domain: "ERA5T", // Matches Postman example
                        gapFillDomain: "NEMSGLOBAL",
                        timeResolution: "daily",
                        codes: [
                            {
                                code: 11,
                                level: "2 m above gnd",
                                aggregation: "mean"
                            }
                        ]
                    },
                    {
                        domain: "ERA5T",
                        gapFillDomain: "NEMSGLOBAL",
                        timeResolution: "daily",
                        codes: [
                            {
                                code: 61,
                                level: "sfc",
                                aggregation: "sum"
                            }
                        ]
                    }
                ]
            };
        }
        else if (type === 'soil') {
            // SOIL API CONFIGURATION
            apiUrl = process.env.CE_HUB_HISTORICAL_API_URL;
            apiKey = process.env.CE_HUB_HISTORICAL_API_KEY;

            if (!apiUrl || !apiKey) {
                console.log('Soil API config missing, using mock data');
                return NextResponse.json(await getMockData(type, lat, lng, startDate, endDate));
            }

            console.log(`Soil API config: ${apiUrl} ${apiKey}`);

            // For soil API, key goes in URL
            apiEndpoint = `${apiUrl}?apikey=${apiKey}`;
            requestMethod = 'POST';

            // Match Postman example for Soil API exactly
            requestBody = {
                units: {
                    temperature: "C",
                    velocity: "km/h",
                    length: "metric",
                    energy: "watts"
                },
                geometry: {
                    type: "MultiPoint",
                    coordinates: [[parseFloat(lng), parseFloat(lat)]],
                    locationNames: ["Location"],
                    mode: "preferLandWithMatchingElevation"
                },
                format: "json",
                timeIntervals: [`${startDate}T+00:00/${endDate}T+00:00`],
                timeIntervalsAlignment: "none",
                queries: [
                    {
                        domain: "SOILGRIDS1000", // Critical: Correct domain from Postman
                        gapFillDomain: null,
                        timeResolution: "static",
                        codes: [
                            { code: 812, level: "5 cm" } // Specific soil code from Postman
                        ]
                    },
                    {
                        domain: "SOILGRIDS1000",
                        gapFillDomain: null,
                        timeResolution: "static",
                        codes: [
                            { code: 806, level: "0 cm" } // Specific soil code from Postman
                        ]
                    },
                    {
                        domain: "WISE30",
                        gapFillDomain: null,
                        timeResolution: "static",
                        codes: [
                            { code: 831, level: "0-20 cm" } // Additional soil property
                        ]
                    }
                ]
            };
        }
        else {
            return NextResponse.json(
                { error: `Unsupported data type: ${type}` },
                { status: 400 }
            );
        }

        // Make request to CE Hub API with enhanced logging
        console.log(`Making ${requestMethod} request to: ${apiEndpoint.split('?')[0]}`);

        const response = requestMethod === 'GET'
            ? await fetch(apiEndpoint, { headers })
            : await fetch(apiEndpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify(requestBody)
            });

        console.log(`CE Hub API response: ${response.status} ${response.statusText}`);

        // Handle different response statuses appropriately
        let responseData;

        if (response.status === 204) {
            // Handle No Content responses
            console.log('Received 204 No Content response - using empty data set');
            responseData = { data: [] };
        }
        else if (!response.ok) {
            // Try to get error details for better diagnostics
            let errorDetails = '';
            try {
                const errorText = await response.text();
                errorDetails = errorText.substring(0, 200);
                console.error(`API Error response details: ${errorDetails}`);
            } catch (readError) {
                console.error('Could not read error response body');
            }

            // Throw appropriate error based on status code
            if (response.status === 401 || response.status === 403) {
                throw new Error(`Authentication failed for CE Hub ${type} API: Invalid API key`);
            } else if (response.status === 400) {
                throw new Error(`Invalid request to CE Hub ${type} API: Bad Request - ${errorDetails || 'Check parameters'}`);
            } else if (response.status === 404) {
                throw new Error(`Endpoint not found for CE Hub ${type} API: Check URL configuration`);
            } else {
                throw new Error(`CE Hub API responded with ${response.status}: ${response.statusText}`);
            }
        }
        else {
            // Process successful responses
            try {
                const contentType = response.headers.get('content-type');
                if (contentType && contentType.includes('application/json')) {
                    responseData = await response.json();
                } else {
                    console.log(`Non-JSON response received: ${contentType}`);
                    const textResponse = await response.text();
                    console.log(`Response preview: ${textResponse.substring(0, 100)}...`);
                    responseData = { data: [] };
                }
            } catch (parseError) {
                console.error('Error parsing response:', parseError);
                responseData = { data: [] };
            }
        }

        // Process the data based on the type
        const processedData = processApiResponse(type, responseData);
        console.log(`Successfully processed ${type} data`);

        return NextResponse.json(processedData);
    } catch (error) {
        console.error('Error fetching environmental data:', error);

        // Return mock data if API request fails
        const mockData = await getMockData(type, lat, lng, startDate, endDate);
        return NextResponse.json(mockData);
    }
}

/**
 * Process the API response based on the type of data requested
 */
function processApiResponse(type: string, responseData: any) {
    // First check if we have valid data to process
    const hasValidData = responseData &&
        responseData.data &&
        Array.isArray(responseData.data) &&
        responseData.data.length > 0;

    if (!hasValidData) {
        console.log(`API returned empty or invalid data for ${type}, using mock data instead`);
        // Generate mock data based on type
        return getMockDataSync(type);
    }

    switch (type) {
        case 'forecast':
            // Extract and format forecast data from the response
            const dailyData = responseData.data.map((item: any) => ({
                date: item.date || new Date().toISOString().split('T')[0],
                temperature: {
                    max: item.TempAir_DailyMax ?? (20 + Math.random() * 10),
                    min: item.TempAir_DailyMin ?? (10 + Math.random() * 5),
                    avg: item.TempAir_DailyAvg ?? (15 + Math.random() * 7)
                },
                precipitation: item.Precip_DailySum ?? (Math.random() > 0.7 ? Math.random() * 10 : 0),
                humidity: item.HumidityRel_DailyAvg ?? (50 + Math.random() * 30),
                windSpeed: item.WindSpeed_DailyAvg ?? (2 + Math.random() * 6),
                globalRadiation: item.GlobalRadiation_DailySum ?? (5000 + Math.random() * 3000)
            }));

            // If mapped data is empty, fall back to mock
            if (dailyData.length === 0) {
                console.log('Mapped forecast data is empty, using mock data');
                return getMockDataSync('forecast');
            }

            return {
                forecast: {
                    daily: dailyData
                }
            };

        case 'historical':
        // [Similar implementation for historical data]
        // ...

        case 'soil':
        // [Similar implementation for soil data]
        // ...

        default:
            return responseData;
    }
}

/**
 * Synchronous version of getMockData for use within processApiResponse
 */
function getMockDataSync(type: string): any {
    const today = new Date();
    const startDate = today.toISOString().split('T')[0];
    const endDate = new Date(today.setDate(today.getDate() + 7)).toISOString().split('T')[0];

    switch (type) {
        case 'forecast':
            return generateMockForecast(startDate, endDate);
        case 'historical':
            return generateMockHistorical(startDate, endDate);
        case 'soil':
            // Use a default location when no coordinates are available
            return generateMockSoil('15', '75');
        default:
            return { error: "Unknown data type requested" };
    }
}

/**
 * Helper to get the first data value from a dataset
 */
/**
 * Helper to get the first data value from a dataset
 */
function getFirstDataValue(dataset: any): number | null {
    if (!dataset) {
        console.warn('Dataset not found in response, using randomized mock value');
        // Return a reasonable mock value instead of null
        return Math.random() * 10;
    }

    if (!dataset.data || !dataset.data.length) {
        console.warn(`Dataset ${dataset?.domain || 'unknown'}/${dataset?.code || 'unknown'} has no data points, using randomized mock value`);
        return Math.random() * 10;
    }

    // Handle the case where value might be null or not a number
    const value = dataset.data[0].value;
    if (value === null || value === undefined || typeof value !== 'number') {
        console.warn(`Invalid value type in dataset ${dataset.domain}/${dataset.code}, using randomized mock value`);
        return Math.random() * 10;
    }

    return value;
}

/**
 * Get the soil texture description based on the value
 */
function getSoilTextureDescription(textureValue: number | null): string {
    if (textureValue === null) return "Unknown";

    // Soil texture classification mapping
    const textureClassMap: { [key: number]: string } = {
        1: "Clay (Cl)",
        2: "Silty Clay (SiCl)",
        3: "Sandy Clay (SaCl)",
        4: "Clay Loam (ClLo)",
        5: "Silty Clay Loam (SiClLo)",
        6: "Sandy Clay Loam (SaClLo)",
        7: "Loam (Lo)",
        8: "Silty Loam (SiLo)",
        9: "Sandy Loam (SaLo)",
        10: "Silt (Si)",
        11: "Loamy Sand (LoSa)",
        12: "Sand (Sa)"
    };

    return textureClassMap[textureValue] || "Unknown";
}

/**
 * Get mock data for development and testing
 */
async function getMockData(type: string, lat: string, lng: string, startDate: string, endDate: string): Promise<any> {
    // Generate realistic mock data based on type and params
    switch (type) {
        case 'forecast':
            return generateMockForecast(startDate, endDate);
        case 'historical':
            return generateMockHistorical(startDate, endDate);
        case 'soil':
            return generateMockSoil(lat, lng);
        default:
            return { error: "Unknown data type requested" };
    }
}

/**
 * Generate mock forecast data
 */
function generateMockForecast(startDate: string, endDate: string) {
    const start = new Date(startDate);
    const end = new Date(endDate);
    const days = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));

    const dailyData = [];

    for (let i = 0; i < days; i++) {
        const currentDate = new Date(start);
        currentDate.setDate(start.getDate() + i);

        // Generate somewhat realistic weather data with some variability
        const baseTemp = 25 + Math.sin(i / 3) * 5; // Oscillating temperature pattern

        dailyData.push({
            date: currentDate.toISOString().split('T')[0],
            temperature: {
                max: baseTemp + Math.random() * 3,
                min: baseTemp - 10 + Math.random() * 3,
                avg: baseTemp - 5 + Math.random() * 2
            },
            precipitation: Math.random() > 0.7 ? Math.random() * 10 : 0, // 30% chance of rain
            humidity: 50 + Math.random() * 30,
            windSpeed: 2 + Math.random() * 6,
            globalRadiation: 5000 + Math.random() * 3000
        });
    }

    return {
        forecast: {
            daily: dailyData
        }
    };
}

/**
 * Generate mock historical data
 */
function generateMockHistorical(startDate: string, endDate: string) {
    // Simple mock historical data
    return {
        historical: {
            temperature: {
                avg: 24.5,
                max: 35.2,
                min: 15.1
            },
            precipitation: {
                annual: 850,
                monthly: [45, 60, 75, 90, 120, 65, 45, 35, 70, 95, 85, 65]
            }
        }
    };
}

/**
 * Generate mock soil data
 */
function generateMockSoil(lat: string, lng: string) {
    // Generate mock soil data based on coordinates
    // This is very simplified - real soil data would be much more complex
    const latNum = parseFloat(lat);
    const lngNum = parseFloat(lng);

    // Use coordinates to deterministically generate different soil types
    // This creates a simple pattern across different locations
    const soilTextureIndex = Math.floor((Math.abs(latNum * 10) + Math.abs(lngNum * 10)) % 12) + 1;

    const soilTextureMap: { [key: number]: string } = {
        1: "Clay (Cl)",
        2: "Silty Clay (SiCl)",
        3: "Sandy Clay (SaCl)",
        4: "Clay Loam (ClLo)",
        5: "Silty Clay Loam (SiClLo)",
        6: "Sandy Clay Loam (SaClLo)",
        7: "Loam (Lo)",
        8: "Silty Loam (SiLo)",
        9: "Sandy Loam (SaLo)",
        10: "Silt (Si)",
        11: "Loamy Sand (LoSa)",
        12: "Sand (Sa)"
    };

    return {
        soil: {
            texture: soilTextureMap[soilTextureIndex],
            properties: {
                bulkDensity: 1.2 + Math.random() * 0.4,
                organicMatter: 1 + Math.random() * 3,
                ph: 5.5 + Math.random() * 2.5,
                waterHoldingCapacity: 0.1 + Math.random() * 0.2,
                cationExchangeCapacity: 5 + Math.random() * 15
            }
        }
    };
}
</file>

<file path="app/api/products/route.ts">
import { NextRequest, NextResponse } from 'next/server';

// Import mock products data
import mockProductsData from '@/lib/data/products.json';

export async function GET(request: NextRequest) {
    try {
        // In a real implementation, we would fetch from a database or external API
        // For this hackathon, we're using our mock data

        // Let's add a small delay to simulate API latency
        await new Promise(resolve => setTimeout(resolve, 300));

        return NextResponse.json(mockProductsData);
    } catch (error) {
        console.error('Error fetching products:', error);
        return NextResponse.json(
            { error: 'Failed to fetch products' },
            { status: 500 }
        );
    }
}
</file>

<file path="app/simulation/components/SeasonTimelineControls.tsx">
// components/simulation/SeasonTimelineControls.tsx
'use client'

import React, { useState, useEffect } from 'react';

interface SeasonTimelineControlsProps {
    controller: any;
    totalDays: number;
    location: any;
}

const SeasonTimelineControls: React.FC<SeasonTimelineControlsProps> = ({
    controller,
    totalDays,
    location
}) => {
    const [currentDay, setCurrentDay] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const [dayInfo, setDayInfo] = useState<any>(null);
    const [speed, setSpeed] = useState(1);
    const [showWeatherPanel, setShowWeatherPanel] = useState(false);

    // Define the three seasons and their day positions
    const seasons = {
        early: { day: Math.floor(totalDays * 0.15), label: "Early Season" },
        middle: { day: Math.floor(totalDays * 0.5), label: "Mid Season" },
        late: { day: Math.floor(totalDays * 0.85), label: "Late Season" }
    };

    // Get current season based on day
    const getCurrentSeason = (day: number) => {
        if (day < Math.floor(totalDays * 0.33)) return 'early';
        if (day < Math.floor(totalDays * 0.67)) return 'middle';
        return 'late';
    };

    // Handle season selection
    const handleSeasonSelect = (seasonKey: string) => {
        const targetDay = seasons[seasonKey as keyof typeof seasons].day;
        setCurrentDay(targetDay);
        controller.setDay(targetDay);
    };

    // Play/pause toggle
    const togglePlayPause = () => {
        if (isPlaying) {
            controller.pause();
        } else {
            controller.play();
        }
        setIsPlaying(!isPlaying);
    };

    // Speed control
    const handleSpeedChange = (newSpeed: number) => {
        setSpeed(newSpeed);
        controller.setSpeed(newSpeed);
    };

    // Update state when controller changes day
    useEffect(() => {
        const updateTimelineState = () => {
            const dayIndex = controller.getCurrentDayIndex();
            setCurrentDay(dayIndex);
            setDayInfo(controller.getCurrentDay());
        };

        // Set initial state
        updateTimelineState();

        // Set up interval to check controller state
        const intervalId = setInterval(updateTimelineState, 200);

        return () => clearInterval(intervalId);
    }, [controller]);

    // Weather icon based on conditions
    const getWeatherIcon = (weather: string) => {
        switch (weather) {
            case 'sunny': return '☀️';
            case 'partly_cloudy': return '⛅';
            case 'cloudy': return '☁️';
            case 'rainy': return '🌧️';
            case 'stormy': return '⛈️';
            default: return '☁️';
        }
    };

    // Growth stage icon
    const getGrowthStageIcon = (stage: string) => {
        switch (stage) {
            case 'SEEDLING': return '🌱';
            case 'VEGETATIVE': return '🌿';
            case 'REPRODUCTIVE': return '🌾';
            case 'MATURE': return '🌽';
            default: return '🌱';
        }
    };

    // Format weather name for display
    const formatWeatherName = (weather: string) => {
        if (!weather) return '';
        return weather.split('_').map(word =>
            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
        ).join(' ');
    };

    const currentSeason = getCurrentSeason(currentDay);

    return (
        <div className="fixed left-0 top-0 h-full w-72 bg-green-800 text-white p-4 shadow-xl z-10 overflow-y-auto">
            <div className="flex flex-col space-y-6 h-full">
                {/* Header Section */}
                <div className="border-b border-green-700 pb-4">
                    <h2 className="text-xl font-bold mb-2">Growing Season</h2>
                    {dayInfo && (
                        <div className="space-y-1">
                            <p className="text-sm font-medium">Day {dayInfo.dayNumber}</p>
                            <p className="text-xs text-green-200">
                                {new Date(dayInfo.date).toLocaleDateString('en-US', {
                                    month: 'short',
                                    day: 'numeric',
                                    year: 'numeric'
                                })}
                            </p>
                        </div>
                    )}
                </div>

                {/* Season Navigation */}
                <div className="space-y-4">
                    <h3 className="text-sm font-semibold text-green-200">Season Navigation</h3>
                    <div className="flex flex-col space-y-3">
                        {Object.entries(seasons).map(([key, data]) => (
                            <button
                                key={key}
                                onClick={() => handleSeasonSelect(key)}
                                className={`w-full p-3 rounded-lg text-left transition-all ${currentSeason === key
                                    ? 'bg-green-600 border-2 border-green-500'
                                    : 'bg-green-700 hover:bg-green-600'
                                    }`}
                            >
                                <div className="font-medium">{data.label}</div>
                                <div className="text-xs mt-1 text-green-200">
                                    Days {data.day + 1}-{key === 'early' ?
                                        Math.floor(totalDays * 0.33) :
                                        key === 'middle' ?
                                            Math.floor(totalDays * 0.67) :
                                            totalDays}
                                </div>
                            </button>
                        ))}
                    </div>
                </div>

                {/* Crop Status */}
                {dayInfo && (
                    <div className="space-y-4">
                        <h3 className="text-sm font-semibold text-green-200">Crop Status</h3>
                        <div className="space-y-3">
                            <div className="flex items-center justify-between p-3 bg-green-700 rounded-lg">
                                <div className="flex items-center space-x-3">
                                    <span className="text-2xl">
                                        {getGrowthStageIcon(dayInfo.growthStage)}
                                    </span>
                                    <div>
                                        <div className="text-sm">{dayInfo.growthStage.toLowerCase()}</div>
                                        <div className="text-xs text-green-200">Growth Progress</div>
                                    </div>
                                </div>
                                <div className="text-lg font-semibold">
                                    {Math.round(dayInfo.growthPercent * 100)}%
                                </div>
                            </div>
                        </div>
                    </div>
                )}

                {/* Weather Conditions */}
                {dayInfo && (
                    <div className="space-y-4">
                        <h3 className="text-sm font-semibold text-green-200">Weather Conditions</h3>
                        <div className="space-y-3">
                            <div className="flex items-center justify-between p-3 bg-green-700 rounded-lg">
                                <div className="flex items-center space-x-3">
                                    <span className="text-2xl">{getWeatherIcon(dayInfo.weather)}</span>
                                    <div>
                                        <div className="text-sm">{formatWeatherName(dayInfo.weather)}</div>
                                        <div className="text-xs text-green-200">Current Conditions</div>
                                    </div>
                                </div>
                                <div className="text-lg font-semibold">{dayInfo.temperature}°C</div>
                            </div>
                            <div className="p-3 bg-green-700 rounded-lg">
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center space-x-2">
                                        <span className="text-xl">💧</span>
                                        <div>
                                            <div className="text-sm">Humidity</div>
                                            <div className="text-xs text-green-200">Relative</div>
                                        </div>
                                    </div>
                                    <div className="text-lg font-semibold">{dayInfo.humidity}%</div>
                                </div>
                            </div>
                        </div>
                    </div>
                )}

                <div className="mt-auto space-y-6">
                    {/* Speed Control */}
                    <div className="space-y-2">
                        <label className="text-sm font-semibold">Playback Speed</label>
                        <select
                            value={speed}
                            onChange={(e) => handleSpeedChange(Number(e.target.value))}
                            className="w-full bg-green-700 text-white rounded-lg p-2 text-sm"
                        >
                            <option value="0.5">0.5x</option>
                            <option value="1">1x</option>
                            <option value="2">2x</option>
                            <option value="5">5x</option>
                            <option value="10">10x</option>
                        </select>
                    </div>

                    {/* Day Slider Control */}
                    <div className="space-y-3">
                        <div className="flex justify-between items-center">
                            <label className="text-sm font-semibold">Simulation Progress</label>
                            <button
                                onClick={togglePlayPause}
                                className="bg-green-600 hover:bg-green-500 text-white p-1 px-2 rounded-md text-xs font-medium"
                            >
                                {isPlaying ? 'Pause' : 'Play'}
                            </button>
                        </div>

                        <input
                            type="range"
                            min="0"
                            max={totalDays - 1}
                            value={currentDay}
                            onChange={(e) => {
                                const newDay = parseInt(e.target.value);
                                setCurrentDay(newDay);
                                controller.setDay(newDay);
                                if (isPlaying) {
                                    controller.pause();
                                    setIsPlaying(false);
                                }
                            }}
                            className="w-full accent-green-500 bg-green-700 h-2 rounded-lg appearance-none cursor-pointer"
                        />

                        <div className="flex justify-between text-sm">
                            <span>Day {currentDay + 1}</span>
                            <span>of {totalDays}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default SeasonTimelineControls;
</file>

<file path="components/farm/CropSelector.tsx">
"use client";

import React, { useState } from 'react';
import { Crop, CropType } from '@/types/farm';
import { Button } from '@/components/ui/Button';

interface CropSelectorProps {
    crops: Crop[];
    onChange: (crops: Crop[]) => void;
    totalFarmSize: number;
    className?: string;
}

// Crop type options with metadata
const cropOptions: Array<{
    value: CropType;
    label: string;
    description: string;
    icon: string;
}> = [
        {
            value: 'rice',
            label: 'Rice',
            description: 'Thrives in warm, wet conditions with high rainfall',
            icon: '🌾',
        },
        {
            value: 'wheat',
            label: 'Wheat',
            description: 'Adaptable to various climates, requires moderate rainfall',
            icon: '🌿',
        },
        {
            value: 'corn',
            label: 'Corn',
            description: 'Needs warm soil and plenty of sunshine',
            icon: '🌽',
        },
        {
            value: 'soybean',
            label: 'Soybean',
            description: 'Fixes nitrogen, grows well in warm climates',
            icon: '🌱',
        },
        {
            value: 'cotton',
            label: 'Cotton',
            description: 'Requires long, frost-free periods and plenty of sunshine',
            icon: '🧶',
        },
        {
            value: 'vegetable',
            label: 'Vegetables',
            description: 'Various vegetable crops with different requirements',
            icon: '🥦',
        },
        {
            value: 'fruit',
            label: 'Fruit',
            description: 'Tree and shrub fruits typically requiring good drainage',
            icon: '🍎',
        },
    ];

export default function CropSelector({
    crops,
    onChange,
    totalFarmSize,
    className = '',
}: CropSelectorProps) {
    const [validationError, setValidationError] = useState<string | null>(null);

    // Calculate total acreage currently allocated
    const allocatedAcreage = crops.reduce((sum, crop) => sum + crop.acreage, 0);
    const remainingAcreage = totalFarmSize - allocatedAcreage;

    // Function to add a new crop
    const handleAddCrop = () => {
        // Default to first available crop type not yet selected
        const usedCropTypes = crops.map(crop => crop.type);
        const availableCropType = cropOptions.find(
            option => !usedCropTypes.includes(option.value)
        )?.value || cropOptions[0].value;

        const newCrop: Crop = {
            id: `crop_${Date.now()}`,
            name: `New ${cropOptions.find(c => c.value === availableCropType)?.label || 'Crop'}`,
            type: availableCropType,
            acreage: Math.min(1, remainingAcreage) // Use remaining acreage or 1, whichever is smaller
        };

        if (remainingAcreage <= 0) {
            setValidationError('Cannot add more crops. Increase farm size or reduce other crop acreages.');
            return;
        }

        onChange([...crops, newCrop]);
        setValidationError(null);
    };

    // Function to remove a crop
    const handleRemoveCrop = (cropId: string) => {
        onChange(crops.filter(crop => crop.id !== cropId));
        setValidationError(null);
    };

    // Function to update a crop
    const handleCropChange = (index: number, updatedCrop: Partial<Crop>) => {
        const newCrops = [...crops];
        newCrops[index] = { ...newCrops[index], ...updatedCrop };

        // Validate acreage
        const totalAcreage = newCrops.reduce((sum, crop) => sum + crop.acreage, 0);
        if (totalAcreage > totalFarmSize) {
            setValidationError(`Total acreage (${totalAcreage}) exceeds farm size (${totalFarmSize})`);
            // Still update the state, but with the validation error
        } else {
            setValidationError(null);
        }

        onChange(newCrops);
    };

    return (
        <div className={`space-y-4 ${className}`}>
            <div className="flex justify-between items-center">
                <h3 className="text-lg font-medium">Crops ({crops.length})</h3>
                <div className="text-sm text-gray-500">
                    Acreage: {allocatedAcreage} / {totalFarmSize}
                    ({remainingAcreage >= 0 ? `${remainingAcreage} available` : `${Math.abs(remainingAcreage)} over limit`})
                </div>
            </div>

            {validationError && (
                <div className="p-3 bg-red-50 border border-red-200 text-red-600 rounded-md text-sm">
                    {validationError}
                </div>
            )}

            <div className="space-y-3">
                {crops.map((crop, index) => (
                    <div
                        key={crop.id}
                        className="p-4 border rounded-lg bg-white shadow-sm flex flex-col sm:flex-row gap-4"
                    >
                        <div className="flex-1 space-y-4">
                            <div>
                                <label htmlFor={`crop-type-${index}`} className="block text-sm font-medium text-gray-700 mb-1">
                                    Crop Type
                                </label>
                                <select
                                    id={`crop-type-${index}`}
                                    value={crop.type}
                                    onChange={(e) => handleCropChange(index, { type: e.target.value as CropType })}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                                >
                                    {cropOptions.map(option => (
                                        <option key={option.value} value={option.value}>
                                            {option.icon} {option.label}
                                        </option>
                                    ))}
                                </select>
                                <p className="mt-1 text-xs text-gray-500">
                                    {cropOptions.find(c => c.value === crop.type)?.description}
                                </p>
                            </div>
                        </div>

                        <div className="flex flex-row sm:flex-col justify-between items-center sm:items-end space-y-0 sm:space-y-4">
                            <div className="w-full max-w-[120px]">
                                <label htmlFor={`crop-acreage-${index}`} className="block text-sm font-medium text-gray-700 mb-1">
                                    Acreage
                                </label>
                                <input
                                    id={`crop-acreage-${index}`}
                                    type="number"
                                    min="0.1"
                                    step="0.1"
                                    value={crop.acreage}
                                    onChange={(e) => handleCropChange(index, { acreage: parseFloat(e.target.value) || 0 })}
                                    className="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-green-500 focus:border-green-500"
                                />
                            </div>

                            <Button
                                variant="destructive"
                                size="sm"
                                onClick={() => handleRemoveCrop(crop.id)}
                                className="mt-4 sm:mt-0"
                                aria-label={`Remove ${crop.name}`}
                            >
                                Remove
                            </Button>
                        </div>
                    </div>
                ))}
            </div>

            <Button
                variant="outline"
                onClick={handleAddCrop}
                disabled={remainingAcreage <= 0}
                className="w-full"
            >
                + Add Crop
            </Button>

            {crops.length === 0 && (
                <div className="text-center p-8 border border-dashed rounded-lg">
                    <p className="text-gray-500">No crops added yet. Click the button above to add your first crop.</p>
                </div>
            )}
        </div>
    );
}
</file>

<file path="components/farm/FarmShapeStep.tsx">
// components/farm/FarmShapeStep.tsx
'use client'

import React, { useState, useEffect, useRef } from 'react';
import Image from 'next/image';

interface FarmShapeStepProps {
  farmLocation: { latitude: number; longitude: number; name: string };
  farmSize: number;
  onComplete: (polygonPoints: Array<{latitude: number; longitude: number}>) => void;
  onBack: () => void;
}

const FarmShapeStep: React.FC<FarmShapeStepProps> = ({
  farmLocation,
  farmSize,
  onComplete,
  onBack
}) => {
  const [satelliteImage, setSatelliteImage] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [polygonPoints, setPolygonPoints] = useState<Array<{x: number; y: number}>>([]);
  const [isDrawing, setIsDrawing] = useState(false);
  const [farmPolygon, setFarmPolygon] = useState<Array<{latitude: number; longitude: number}> | null>(null);
  
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imageRef = useRef<HTMLImageElement>(null);
  const imageContainerRef = useRef<HTMLDivElement>(null);
  
  // Fetch satellite image when component mounts or when location/size changes
  useEffect(() => {
    fetchSatelliteImage();
  }, [farmLocation, farmSize]);
  
  // Initialize canvas when image is loaded
  useEffect(() => {
    if (satelliteImage && canvasRef.current && imageRef.current) {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      
      if (ctx) {
        // Set the canvas size to match the image exactly
        // This is important for preventing scaling/zooming issues
        canvas.width = imageRef.current.width;
        canvas.height = imageRef.current.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw the satellite image on the canvas
        ctx.drawImage(imageRef.current, 0, 0);
      }
    }
  }, [satelliteImage]);
  
  // Draw the polygon points and lines
  useEffect(() => {
    if (canvasRef.current && polygonPoints.length > 0 && imageRef.current) {
      const canvas = canvasRef.current;
      const ctx = canvas.getContext('2d');
      
      if (ctx) {
        // Make sure canvas dimensions are correct
        canvas.width = imageRef.current.width;
        canvas.height = imageRef.current.height;
        
        // Redraw the image
        ctx.drawImage(imageRef.current, 0, 0);
        
        // Draw the polygon points
        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        
        // Draw lines between points
        if (polygonPoints.length > 1) {
          ctx.beginPath();
          ctx.moveTo(polygonPoints[0].x, polygonPoints[0].y);
          
          for (let i = 1; i < polygonPoints.length; i++) {
            ctx.lineTo(polygonPoints[i].x, polygonPoints[i].y);
          }
          
          // Close the polygon if we have more than 2 points
          if (polygonPoints.length > 2) {
            ctx.lineTo(polygonPoints[0].x, polygonPoints[0].y);
          }
          
          ctx.stroke();
          
          // Fill the polygon with a semi-transparent color
          if (polygonPoints.length > 2) {
            ctx.fillStyle = 'rgba(255, 165, 0, 0.3)';
            ctx.fill();
          }
        }
        
        // Draw points
        polygonPoints.forEach((point, index) => {
          ctx.beginPath();
          ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
          ctx.fill();
          
          // Label the points
          ctx.fillStyle = 'white';
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 1;
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.strokeText(String(index + 1), point.x, point.y);
          ctx.fillText(String(index + 1), point.x, point.y);
        });
      }
    }
  }, [polygonPoints, satelliteImage]);

  // Fetch satellite image from API
  const fetchSatelliteImage = async () => {
    if (!farmLocation || !farmSize) {
      setError("Location or farm size not specified");
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    // First, check if we're in development mode and should use a workaround
    const isDevelopment = process.env.NODE_ENV === 'development';
    
    try {
      // API endpoint based on your Python API
      const apiUrl = 'http://localhost:5032/satellite';
      const params = new URLSearchParams({
        latitude: farmLocation.latitude.toString(),
        longitude: farmLocation.longitude.toString(),
        hectares: farmSize.toString(),
        start_date: '2023-01-01',
        end_date: '2025-03-20'
      });
      
      let imageUrl: string;
      
      try {
        // Try the direct fetch first
        const response = await fetch(`${apiUrl}?${params}`);
        
        if (!response.ok) {
          throw new Error(`API request failed with status ${response.status}`);
        }
        
        // Convert response to blob and create URL
        const imageBlob = await response.blob();
        imageUrl = URL.createObjectURL(imageBlob);
      } catch (corsError: any) {
        // If we detect a CORS error, try the workaround
        if (corsError.message.includes('CORS') || corsError.name === 'TypeError') {
          console.warn('CORS error detected, using fallback method');
          
          if (isDevelopment) {
            // In development, use a Next.js API route proxy
            const proxyUrl = '/api/satellite-proxy';
            const proxyResponse = await fetch(proxyUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                latitude: farmLocation.latitude,
                longitude: farmLocation.longitude,
                hectares: farmSize,
                start_date: '2023-01-01',
                end_date: '2025-03-20'
              })
            });
            
            if (!proxyResponse.ok) {
              throw new Error(`Proxy request failed with status ${proxyResponse.status}`);
            }
            
            const imageBlob = await proxyResponse.blob();
            imageUrl = URL.createObjectURL(imageBlob);
          } else {
            // If proxy isn't available, fall back to a placeholder or demo image
            console.warn('Fallback to demo satellite image');
            // Using a placeholder image for demo purposes
            imageUrl = "/images/demo-satellite-image.jpg";
          }
        } else {
          // If it's not a CORS error, rethrow
          throw corsError;
        }
      }
      
      // Set the image URL
      setSatelliteImage(imageUrl);
      
      // Reset polygon data when loading a new image
      setPolygonPoints([]);
      setFarmPolygon(null);
      setIsLoading(false);
    } catch (err: any) {
      console.error('Error fetching satellite image:', err);
      
      // Provide more specific error messaging for common issues
      if (err.message?.includes('CORS')) {
        setError("CORS error: The satellite API server needs to allow requests from your frontend. Please add CORS headers to your Python API or use a proxy.");
      } else if (err.name === 'TypeError' && err.message?.includes('Failed to fetch')) {
        setError("Connection error: Cannot connect to the satellite API. Make sure the API server is running at http://localhost:5032");
      } else {
        setError(`Error fetching satellite image: ${err.message}`);
      }
      
      // Fall back to a demo image in development mode
      if (isDevelopment) {
        console.warn('Falling back to demo satellite image');
        setSatelliteImage("/images/demo-satellite-image.jpg");
      }
      
      setIsLoading(false);
    }
  };
  
  // Handle canvas click for adding polygon points
  const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    // Calculate the scale ratio between the canvas element size and its internal dimensions
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    // Get the click position in canvas coordinates
    const x = (event.clientX - rect.left) * scaleX;
    const y = (event.clientY - rect.top) * scaleY;
    
    setPolygonPoints([...polygonPoints, { x, y }]);
  };
  
  // Start drawing mode
  const startDrawing = () => {
    setIsDrawing(true);
    setPolygonPoints([]);
    setFarmPolygon(null);
  };
  
  // Complete the polygon
  const completePolygon = () => {
    if (polygonPoints.length < 3) {
      setError('You need at least 3 points to form a polygon.');
      return;
    }
    
    if (!imageRef.current) {
      setError('Image reference not available');
      return;
    }
    
    // Convert canvas coordinates to geo coordinates
    const imageWidth = imageRef.current.width;
    const imageHeight = imageRef.current.height;
    
    // This is a simplified conversion - in a real app you'd use proper geo-transformation
    const geoPolygon = polygonPoints.map(point => {
      // Convert canvas x,y to normalized 0-1 coordinates
      const normalizedX = point.x / imageWidth;
      const normalizedY = point.y / imageHeight;
      
      // Simple linear transformation from image space to geo space
      // This assumes the image covers a rectangular area centered on farmLocation
      // with a certain km per pixel resolution (derived from hectares)
      const bufferKm = Math.sqrt(farmSize * 0.01 / Math.PI) * 1.1; // Same calculation as in the API
      
      // Approximate degrees per km at the equator
      const degreesPerKm = 1 / 111;
      
      // Calculate lat/lon offset from center (very simplified)
      const lonOffset = (normalizedX - 0.5) * bufferKm * 2 * degreesPerKm;
      const latOffset = (0.5 - normalizedY) * bufferKm * 2 * degreesPerKm;
      
      return {
        latitude: farmLocation.latitude + latOffset,
        longitude: farmLocation.longitude + lonOffset
      };
    });
    
    setFarmPolygon(geoPolygon);
    setIsDrawing(false);
  };
  
  // Undo last point
  const undoLastPoint = () => {
    if (polygonPoints.length > 0) {
      setPolygonPoints(polygonPoints.slice(0, -1));
    }
  };
  
  // Reset polygon
  const resetPolygon = () => {
    setPolygonPoints([]);
    setFarmPolygon(null);
  };
  
  // Continue to next step
  const handleContinue = () => {
    if (farmPolygon) {
      onComplete(farmPolygon);
    } else {
      setError('Please complete the farm boundary before continuing.');
    }
  };

  return (
    <div className="bg-white p-6 rounded-lg shadow-md">
      <h2 className="text-2xl font-semibold mb-4 text-green-800">Define Your Farm Boundary</h2>
      <p className="text-gray-600 mb-6">
        Draw the boundary of your farm on the satellite image to create a precise polygon of your fields.
      </p>
      
      {isLoading ? (
        <div className="flex justify-center items-center h-64 bg-gray-100 rounded-lg">
          <div className="text-center">
            <div className="inline-block w-8 h-8 border-4 border-green-500 border-t-transparent rounded-full animate-spin"></div>
            <p className="mt-2 text-green-700">Loading satellite image...</p>
          </div>
        </div>
      ) : error ? (
        <div className="p-4 bg-red-50 text-red-700 rounded-lg mb-4">
          <p className="font-medium">Error:</p>
          <p>{error}</p>
          <button 
            onClick={fetchSatelliteImage}
            className="mt-2 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
          >
            Try Again
          </button>
        </div>
      ) : (
        <div>
          {/* Image and drawing canvas */}
          {satelliteImage && (
            <div className="mb-6">
              <div className="flex justify-between mb-3">
                <div className="text-sm text-gray-600">
                  <strong>Location:</strong> {farmLocation.name}
                </div>
                <div className="text-sm text-gray-600">
                  <strong>Farm Size:</strong> {farmSize} hectares
                </div>
              </div>
              
              <div className="flex space-x-2 mb-4">
                <button
                  onClick={startDrawing}
                  disabled={isDrawing}
                  className={`px-4 py-2 rounded-md font-medium ${
                    isDrawing 
                      ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                      : 'bg-green-600 text-white hover:bg-green-700'
                  }`}
                >
                  Start Drawing Farm Boundary
                </button>
                
                {isDrawing && (
                  <>
                    <button
                      onClick={completePolygon}
                      disabled={polygonPoints.length < 3}
                      className={`px-4 py-2 rounded-md font-medium ${
                        polygonPoints.length < 3 
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                          : 'bg-blue-600 text-white hover:bg-blue-700'
                      }`}
                    >
                      Complete Polygon
                    </button>
                    <button
                      onClick={undoLastPoint}
                      disabled={polygonPoints.length === 0}
                      className={`px-4 py-2 rounded-md font-medium ${
                        polygonPoints.length === 0 
                          ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                          : 'bg-yellow-600 text-white hover:bg-yellow-700'
                      }`}
                    >
                      Undo Last Point
                    </button>
                    <button
                      onClick={resetPolygon}
                      className="px-4 py-2 bg-red-600 text-white rounded-md font-medium hover:bg-red-700"
                    >
                      Reset
                    </button>
                  </>
                )}
              </div>
              
              <div className="relative border rounded-lg overflow-hidden bg-gray-100" ref={imageContainerRef}>
                {/* Image */}
                <div className="relative" style={{ width: '100%' }}>
                  <img
                    ref={imageRef}
                    src={satelliteImage}
                    alt="Satellite view of farm location"
                    className="w-full h-auto max-w-full"
                    style={{ display: 'block' }}
                    onLoad={() => {
                      // Ensure canvas matches image dimensions exactly when image loads
                      if (canvasRef.current && imageRef.current) {
                        canvasRef.current.width = imageRef.current.width;
                        canvasRef.current.height = imageRef.current.height;
                        
                        // Redraw if needed
                        if (polygonPoints.length > 0) {
                          const ctx = canvasRef.current.getContext('2d');
                          if (ctx) {
                            ctx.drawImage(imageRef.current, 0, 0);
                          }
                        }
                      }
                    }}
                  />
                  {/* Canvas overlay - position absolute and sized to match image exactly */}
                  <canvas
                    ref={canvasRef}
                    onClick={handleCanvasClick}
                    className="absolute top-0 left-0 cursor-crosshair"
                    style={{
                      width: '100%',
                      height: '100%',
                      pointerEvents: isDrawing ? 'auto' : 'none'
                    }}
                  ></canvas>
                </div>
                
                {isDrawing && (
                  <div className="absolute top-2 left-2 bg-white p-2 rounded shadow text-sm">
                    Click to add points. Add at least 3 points and click "Complete Polygon".
                  </div>
                )}
              </div>
            </div>
          )}
          
          {/* Farm polygon data and navigation buttons */}
          {farmPolygon && (
            <div className="bg-green-50 p-4 rounded-lg border border-green-200 mb-6">
              <h3 className="font-medium text-green-800 mb-2">Farm Boundary Defined!</h3>
              <p className="text-sm text-green-700 mb-2">
                You've successfully defined your farm boundary with {farmPolygon.length} points.
                This shape will be used for your simulation.
              </p>
            </div>
          )}
        </div>
      )}
      
      {/* Navigation buttons */}
      <div className="flex justify-between mt-6">
        <button
          onClick={onBack}
          className="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600"
        >
          Back
        </button>
        
        <button
          onClick={handleContinue}
          disabled={!farmPolygon}
          className={`px-6 py-2 rounded-md ${
            !farmPolygon 
              ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
              : 'bg-green-600 text-white hover:bg-green-700'
          }`}
        >
          Continue
        </button>
      </div>
    </div>
  );
};

export default FarmShapeStep;
</file>

<file path="components/farm/MapComponent.tsx">
// components/farm/MapComponent.tsx
'use client'

import React, { useEffect, useRef } from 'react';

interface MapComponentProps {
  latitude: number;
  longitude: number;
  hectares?: number;
  className?: string;
  showCircle?: boolean;
}

const MapComponent: React.FC<MapComponentProps> = ({
  latitude,
  longitude,
  hectares = 100,
  className = "w-full h-64",
  showCircle = true
}) => {
  const iframeRef = useRef<HTMLIFrameElement>(null);
  
  useEffect(() => {
    // Generate an approximation of radius in kilometers based on hectares
    // 1 hectare = 0.01 square kilometers
    // Area = π * r²
    // Solve for r: r = sqrt(Area / π)
    const areaKm2 = hectares * 0.01;
    const radiusKm = Math.sqrt(areaKm2 / Math.PI);
    
    // Calculate zoom level based on radius
    let zoomLevel = 14;
    if (radiusKm > 0.5) zoomLevel = 13;
    if (radiusKm > 1) zoomLevel = 12;
    if (radiusKm > 2) zoomLevel = 11;
    if (radiusKm > 5) zoomLevel = 10;
    if (radiusKm > 10) zoomLevel = 9;
    if (radiusKm > 20) zoomLevel = 8;
    if (radiusKm > 50) zoomLevel = 7;
    
    // Create the OpenStreetMap embed URL
    let url = `https://www.openstreetmap.org/export/embed.html?bbox=${longitude-0.1},${latitude-0.1},${longitude+0.1},${latitude+0.1}&layer=mapnik&marker=${latitude},${longitude}`;
    
    // Alternatively with zoom level
    url = `https://www.openstreetmap.org/export/embed.html?bbox=${longitude-0.2},${latitude-0.2},${longitude+0.2},${latitude+0.2}&layer=mapnik&marker=${latitude},${longitude}&zoom=${zoomLevel}`;
    
    // Set the iframe source
    if (iframeRef.current) {
      iframeRef.current.src = url;
    }
  }, [latitude, longitude, hectares]);

  return (
    <div className={`relative overflow-hidden rounded-md border border-gray-300 ${className}`}>
      <iframe
        ref={iframeRef}
        width="100%"
        height="100%"
        frameBorder="0"
        scrolling="no"
        className="absolute inset-0 w-full h-full"
        title="Farm location map"
      ></iframe>
      
      {/* We can't easily add a circle overlay on the iframe, but we could add explanatory text */}
      <div className="absolute bottom-0 left-0 right-0 bg-white bg-opacity-80 p-2 text-xs">
        Farm location: {latitude.toFixed(6)}, {longitude.toFixed(6)}
        {hectares && <span> • Approx. {hectares} hectares</span>}
      </div>
    </div>
  );
};

export default MapComponent;
</file>

<file path="components/ui/HeroSection.tsx">
"use client";

import React from 'react';
import Image from 'next/image';
import Navbar from './Navbar';

interface HeroSectionProps {
    onGetStarted: () => void;
}

export default function HeroSection({ onGetStarted }: HeroSectionProps) {
    return (
        <>
            {/* Full viewport background container */}
            <div className="fixed inset-0 z-0">
                <Image
                    src="/images/farm-hero.png"
                    alt="Sustainable farming landscape"
                    fill
                    priority
                    className="object-cover"
                />
                {/* Gradient overlay for text readability */}
                <div className="absolute inset-0 bg-black/20"></div>
            </div>

            {/* Header bar - positioned absolutely to maintain its position */}
            <Navbar />

            {/* Main content container - positioned absolutely to maintain layout */}
            <div className="fixed inset-0 z-5 flex items-center justify-center pt-16">
                <div className="text-center px-4 py-8 max-w-3xl mx-auto">
                    <h1 className="text-5xl font-bold text-white mb-6">
                        Nature helps nature
                    </h1>
                    <h2 className="text-2xl md:text-3xl text-white mb-8">
                        Use AI to improve global farming through nature-powered innovation
                    </h2>

                    <div className="backdrop-blur-sm bg-white/10 rounded-xl p-6 mb-10 border border-white/20">
                        <p className="text-lg text-white mb-8">
                            Our AI-powered Farm Bio-Boost Simulator helps you visualize environmental risks,
                            recommend biological products for your specific crops, and track outcomes to
                            improve yields sustainably.
                        </p>

                        {/* Get Started button */}
                        <button
                            onClick={onGetStarted}
                            className="inline-flex items-center bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full transition-all shadow-lg"
                        >
                            Get Started
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </>
    );
}
</file>

<file path="lib/crops/constants.ts">
// Constants for crop-related measurements and scaling
export const HECTARE_TO_SQUARE_METERS = 2000; // 1 hectare = 10,000 square meters
export const SCALE_FACTOR = 1.0; // Scale for visualization (1 meter = 1 unit in Three.js)

// Plant density per hectare (approximate real-world values)
export const PLANTS_PER_HECTARE = {
    corn: 80000,      // 80,000 plants per hectare
    wheat: 2500000,   // 2.5 million plants per hectare
    soybean: 400000,  // 400,000 plants per hectare
    cotton: 100000,   // 100,000 plants per hectare
    rice: 200000      // 200,000 plants per hectare
};

// Plant heights in meters (approximate real-world values)
export const PLANT_HEIGHTS = {
    corn: 2.5,      // 2.5 meters at full growth
    wheat: 0.8,     // 0.8 meters at full growth
    soybean: 1.0,   // 1.0 meters at full growth
    cotton: 1.2,    // 1.2 meters at full growth
    rice: 1.0       // 1.0 meters at full growth
};

// Plant row spacing in meters (typical agricultural practice)
export const PLANT_ROW_SPACING = {
    corn: 0.76,     // 76 cm between rows
    wheat: 0.15,    // 15 cm between rows
    soybean: 0.5,   // 50 cm between rows
    cotton: 1.0,    // 1 meter between rows
    rice: 0.3       // 30 cm between rows  
};

// Plant spacing within rows in meters (typical agricultural practice)
export const PLANT_SPACING_IN_ROW = {
    corn: 0.16,     // 16 cm between plants in a row
    wheat: 0.025,   // 2.5 cm between plants in a row
    soybean: 0.05,  // 5 cm between plants in a row
    cotton: 0.1,    // 10 cm between plants in a row
    rice: 0.15      // 15 cm between plants in a row
};

// Randomization factors for natural-looking variations
export const RANDOMIZATION_FACTORS = {
    position: 0.05,    // Random position variation (% of spacing)
    rotation: 0.5,     // Random rotation (radians)
    scale: 0.15        // Random scale variation (% of size)
};

// Returns a slightly varied height for natural variation
export const getRandomizedHeight = (baseHeight: number): number => {
    // Return between 85% and 115% of the base height
    return baseHeight * (0.85 + Math.random() * 0.3);
};

// Calculate grid dimensions for a given crop type and field size
export const calculateGridDimensions = (cropType: string, fieldWidthMeters: number, fieldHeightMeters: number) => {
    const rowSpacing = PLANT_ROW_SPACING[cropType] || 0.5;
    const plantSpacing = PLANT_SPACING_IN_ROW[cropType] || 0.1;

    // Calculate number of rows and plants per row
    const numRows = Math.floor(fieldHeightMeters / rowSpacing);
    const plantsPerRow = Math.floor(fieldWidthMeters / plantSpacing);

    return {
        numRows,
        plantsPerRow,
        rowSpacing,
        plantSpacing
    };
};
</file>

<file path="lib/crops/index.ts">
import { PLANT_HEIGHTS, SCALE_FACTOR, getRandomizedHeight } from './constants';
import { loadModel, getCropModelPaths } from '../services/modelLoader';
import * as THREE from 'three';

// Fallback creation methods if models fail to load
import createCornPlant from './corn';
import createWheatPlant from './wheat';
import createSoybeanPlant from './soybean';
import createCottonPlant from './cotton';
import createRicePlant from './rice';

// Get model paths
const cropModelPaths = getCropModelPaths();

// Track loading status
let modelsPreloaded = false;

/**
 * Preload all crop models - call this at app initialization
 */
export const preloadCropModels = async () => {
  try {
    const modelPaths = Object.values(cropModelPaths);
    for (const path of modelPaths) {
      await loadModel(path);
    }
    modelsPreloaded = true;
    console.log('All crop models preloaded successfully');
  } catch (error) {
    console.error('Error preloading crop models:', error);
  }
};

/**
 * Creates a plant based on type and positions it at the specified coordinates
 * Uses 3D models when available, falls back to geometry-based models if needed
 * @param {string} type - Type of crop
 * @param {number} x - X coordinate
 * @param {number} z - Z coordinate
 * @returns {THREE.Group} - The created plant 3D object
 */
export const createPlant = async (type: string, x: number, z: number): Promise<THREE.Group> => {
  // Get base height for the plant type and apply scale factor
  const baseHeight = PLANT_HEIGHTS[type] * SCALE_FACTOR;
  
  // Apply natural variation to the height
  const actualHeight = getRandomizedHeight(baseHeight);
  
  // Create a container group for the plant
  const plantGroup = new THREE.Group();
  plantGroup.position.set(x, 0, z);
  
  // Add random rotation for natural variation
  plantGroup.rotation.y = Math.random() * Math.PI * 2;
  
  // Mark as a plant for timeline animations
  plantGroup.userData.isPlant = true;
  plantGroup.userData.cropType = type;
  plantGroup.userData.baseHeight = baseHeight;
  
  try {
    // Try to load the 3D model for this crop type
    if (cropModelPaths[type]) {
      const model = await loadModel(cropModelPaths[type]);
      
      // Scale model appropriately based on desired height
      const modelHeight = getModelHeight(model);
      
      // Calculate scale based on desired height and add scaling factor
      // We multiply by 3 to make the models significantly larger
      const scaleRatio = (actualHeight / modelHeight) * 3.0;
      
      model.scale.set(scaleRatio, scaleRatio, scaleRatio);
      
      // Log scaling information for debugging
      console.log(`Model scaling for ${type}: Model height = ${modelHeight}, Desired height = ${actualHeight}, Scale ratio = ${scaleRatio}`);
      
      // Mark model components for growth animation
      model.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          // Store original scale for growth animations
          child.userData.originalScale = { 
            x: child.scale.x, 
            y: child.scale.y, 
            z: child.scale.z 
          };
        }
      });
      
      // Store original scale for the model
      model.userData.originalScale = { 
        x: model.scale.x, 
        y: model.scale.y, 
        z: model.scale.z 
      };

      // Add model to the plant group
      plantGroup.add(model);
      
      // Tag specific parts for growth animation
      tagPlantParts(plantGroup, type);
    } else {
      // Fallback to geometry-based plant if no model path exists
      throw new Error(`No model path defined for crop type: ${type}`);
    }
  } catch (error) {
    console.warn(`Failed to load 3D model for ${type}, falling back to geometry:`, error);
    
    // Fallback to geometry-based models
    let fallbackPlant;
    switch (type) {
      case 'corn':
        fallbackPlant = createCornPlant(actualHeight);
        break;
      case 'wheat':
        fallbackPlant = createWheatPlant(actualHeight);
        break;
      case 'soybean':
        fallbackPlant = createSoybeanPlant(actualHeight);
        break;
      case 'cotton':
        fallbackPlant = createCottonPlant(actualHeight);
        break;
      case 'rice':
        fallbackPlant = createRicePlant(actualHeight);
        break;
      default:
        // Create a simple default plant
        const defaultGeometry = new THREE.ConeGeometry(0.1, 0.5, 6);
        const defaultMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
        fallbackPlant = new THREE.Group();
        const defaultMesh = new THREE.Mesh(defaultGeometry, defaultMaterial);
        defaultMesh.position.y = 0.25;
        defaultMesh.castShadow = true;
        fallbackPlant.add(defaultMesh);
    }
    
    plantGroup.add(fallbackPlant);
  }
  
  return plantGroup;
};

/**
 * Helper function to get the height of a model by analyzing its bounding box
 */
function getModelHeight(model: THREE.Group): number {
  const boundingBox = new THREE.Box3().setFromObject(model);
  return boundingBox.max.y - boundingBox.min.y;
}

/**
 * Tag specific parts of the plant model for growth animation
 * This helps identify which parts to show/hide at different growth stages
 */
function tagPlantParts(plantGroup: THREE.Group, cropType: string) {
  // Traverse the model to find and tag specific parts
  plantGroup.traverse((child) => {
    // Skip non-meshes
    if (!(child instanceof THREE.Mesh)) return;
    
    const name = child.name.toLowerCase();
    
    // Tag parts by their names in the 3D model
    if (name.includes('fruit') || name.includes('cob') || name.includes('grain') || 
        name.includes('pod') || name.includes('boll') || name.includes('head')) {
      child.userData.isFruit = true;
    }
    
    if (name.includes('leaf')) {
      child.userData.isLeaf = true;
    }
    
    if (name.includes('stalk') || name.includes('stem') || name.includes('trunk')) {
      child.userData.isStalk = true;
    }
    
    if (name.includes('flower')) {
      child.userData.isFlower = true;
    }
    
    // Additional crop-specific tags
    if (cropType === 'corn' && (name.includes('cob') || name.includes('ear'))) {
      child.userData.isCob = true;
    }
    
    if (cropType === 'wheat' && name.includes('head')) {
      child.userData.isWheatHead = true;
    }
    
    if (cropType === 'cotton' && name.includes('boll')) {
      child.userData.isCottonBoll = true;
    }
  });
}

// Create a synchronous version for the simulation setup
// This will use a placeholder if the model isn't loaded yet
export const createPlantSync = (type: string, x: number, z: number): THREE.Group => {
  const plantGroup = new THREE.Group();
  plantGroup.position.set(x, 0, z);
  plantGroup.rotation.y = Math.random() * Math.PI * 2;
  plantGroup.userData.isPlant = true;
  plantGroup.userData.cropType = type;
  plantGroup.userData.baseHeight = PLANT_HEIGHTS[type] * SCALE_FACTOR;
  plantGroup.userData.pendingModelLoad = true;
  
  // Create a simple placeholder
  const placeholderGeometry = new THREE.CylinderGeometry(0.03, 0.05, 0.3, 6);
  const placeholderMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
  const placeholder = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
  placeholder.position.y = 0.15;
  placeholder.castShadow = true;
  plantGroup.add(placeholder);
  
  // Schedule async replacement with the real model
  createPlant(type, 0, 0).then(realPlant => {
    // Remove the placeholder
    while (plantGroup.children.length > 0) {
      plantGroup.remove(plantGroup.children[0]);
    }
    
    // Transfer the loaded model to this group
    while (realPlant.children.length > 0) {
      plantGroup.add(realPlant.children[0]);
    }
    
    // Copy relevant userData
    Object.assign(plantGroup.userData, realPlant.userData);
    plantGroup.userData.pendingModelLoad = false;
  }).catch(error => {
    console.error(`Error loading model for ${type}:`, error);
    plantGroup.userData.pendingModelLoad = false;
  });
  
  return plantGroup;
};

// Export other constants for use elsewhere
export * from './constants';
</file>

<file path="lib/simulation/fieldUtils.ts">
import * as THREE from 'three';
import { HECTARE_TO_SQUARE_METERS, SCALE_FACTOR, PLANT_ROW_SPACING, PLANT_SPACING_IN_ROW, RANDOMIZATION_FACTORS } from '../crops';

/**
 * Calculate the area of a polygon in square units
 * @param {Array} vertices - Array of vertices defining the polygon
 * @returns {number} - Area of the polygon
 */
export const calculatePolygonArea = (vertices) => {
  let area = 0;
  for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
    area += (vertices[i][0] * vertices[j][2]) - (vertices[j][0] * vertices[i][2]);
  }
  return Math.abs(area) / 2;
};

/**
 * Calculate the dimensions of a polygon
 * @param {Array} vertices - Array of vertices defining the polygon
 * @returns {Object} - Object containing width, height, and center of the polygon
 */
export const calculatePolygonDimensions = (vertices) => {
  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
  
  vertices.forEach(vertex => {
    minX = Math.min(minX, vertex[0]);
    maxX = Math.max(maxX, vertex[0]);
    minZ = Math.min(minZ, vertex[2]);
    maxZ = Math.max(maxZ, vertex[2]);
  });
  
  return {
    width: maxX - minX,
    height: maxZ - minZ,
    center: {
      x: (minX + maxX) / 2,
      z: (minZ + maxZ) / 2
    },
    bounds: {
      minX, maxX, minZ, maxZ
    }
  };
};

/**
 * Scale polygon to match the specified hectare size
 * @param {Array} polygon - Array of vertices defining the polygon
 * @param {number} hectares - Target size in hectares
 * @returns {Array} - Scaled polygon vertices
 */
export const scalePolygonToHectares = (polygon, hectares) => {
  const targetArea = hectares * HECTARE_TO_SQUARE_METERS * SCALE_FACTOR * SCALE_FACTOR;
  const currentArea = calculatePolygonArea(polygon);
  const scaleFactor = Math.sqrt(targetArea / currentArea);
  
  // Calculate centroid
  let centroidX = 0, centroidZ = 0;
  polygon.forEach(point => {
    centroidX += point[0];
    centroidZ += point[2];
  });
  centroidX /= polygon.length;
  centroidZ /= polygon.length;
  
  // Scale points relative to centroid - ensure field stays within boundaries
  const maxDimension = 150; // Maximum size for any dimension to prevent going outside view
  
  const scaled = polygon.map(point => [
    centroidX + (point[0] - centroidX) * scaleFactor,
    0, // y-coordinate stays at 0
    centroidZ + (point[2] - centroidZ) * scaleFactor
  ]);
  
  // Check if any dimension exceeds our max limits
  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
  
  scaled.forEach(point => {
    minX = Math.min(minX, point[0]);
    maxX = Math.max(maxX, point[0]);
    minZ = Math.min(minZ, point[2]);
    maxZ = Math.max(maxZ, point[2]);
  });
  
  const width = maxX - minX;
  const height = maxZ - minZ;
  
  // If either dimension is too large, apply additional scaling
  if (width > maxDimension || height > maxDimension) {
    const additionalScaleFactor = Math.min(maxDimension / width, maxDimension / height);
    
    return scaled.map(point => [
      centroidX + (point[0] - centroidX) * additionalScaleFactor,
      0,
      centroidZ + (point[2] - centroidZ) * additionalScaleFactor
    ]);
  }
  
  // Ensure minimum field size for visibility - no fields smaller than 40x40
  const minDimension = 40;
  if (width < minDimension || height < minDimension) {
    const minScaleFactor = Math.max(minDimension / width, minDimension / height);
    
    return scaled.map(point => [
      centroidX + (point[0] - centroidX) * minScaleFactor,
      0,
      centroidZ + (point[2] - centroidZ) * minScaleFactor
    ]);
  }
  
  return scaled;
};

/**
 * Triangulate a polygon for plant placement
 * @param {Array} polygon - Array of vertices defining the polygon
 * @returns {Array} - Array of triangles (each triangle is an array of 3 vertices)
 */
export const triangulatePolygon = (polygon) => {
  const triangles = [];
  // Simple ear-clipping triangulation (for convex polygons)
  for (let i = 1; i < polygon.length - 1; i++) {
    triangles.push([
      polygon[0],
      polygon[i],
      polygon[i + 1]
    ]);
  }
  return triangles;
};

/**
 * Generate a random point within a triangle using barycentric coordinates
 * @param {Array} triangle - Array of 3 vertices defining the triangle
 * @returns {Object} - Random point {x, z} within the triangle
 */
export const getRandomPointInTriangle = (triangle) => {
  // Create barycentric coordinates
  let a = Math.random();
  let b = Math.random();
  
  // Ensure the point is within the triangle
  if (a + b > 1) {
    a = 1 - a;
    b = 1 - b;
  }
  
  const c = 1 - a - b;
  
  // Calculate the position
  const x = a * triangle[0][0] + b * triangle[1][0] + c * triangle[2][0];
  const z = a * triangle[0][2] + b * triangle[1][2] + c * triangle[2][2];
  
  return { x, z };
};

/**
 * Check if a point is inside the polygon
 * @param {Object} point - Point {x, z} to check
 * @param {Array} polygon - Array of vertices defining the polygon
 * @returns {boolean} - True if the point is inside the polygon
 */
export const isPointInPolygon = (point, polygon) => {
  const { x, z } = point;
  let inside = false;
  
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0], zi = polygon[i][2];
    const xj = polygon[j][0], zj = polygon[j][2];
    
    const intersect = ((zi > z) !== (zj > z)) && 
      (x < (xj - xi) * (z - zi) / (zj - zi) + xi);
    
    if (intersect) inside = !inside;
  }
  
  return inside;
};

/**
 * Generate grid-based plant positions for a field
 * @param {Array} polygon - Array of vertices defining the polygon
 * @param {string} cropType - Type of crop
 * @param {number} density - Density percentage (0-100)
 * @returns {Array} - Array of plant positions {x, z}
 */
export const generateGridPlantPositions = (polygon, cropType, density) => {
  // Get field dimensions
  const dimensions = calculatePolygonDimensions(polygon);
  const { width, height, bounds } = dimensions;
  
  // Get spacing for this crop type
  const rowSpacing = PLANT_ROW_SPACING[cropType] || 0.5;
  const plantSpacing = PLANT_SPACING_IN_ROW[cropType] || 0.1;
  
  // Apply density adjustment - increase spacing when density is lower
  const densityFactor = density / 100;
  const adjustedRowSpacing = rowSpacing / Math.sqrt(densityFactor);
  const adjustedPlantSpacing = plantSpacing / Math.sqrt(densityFactor);
  
  // Calculate rows and columns based on adjusted spacing
  const numRows = Math.ceil(height / adjustedRowSpacing);
  const plantsPerRow = Math.ceil(width / adjustedPlantSpacing);
  
  // Scale to Three.js coordinates
  const scaledRowSpacing = adjustedRowSpacing * SCALE_FACTOR;
  const scaledPlantSpacing = adjustedPlantSpacing * SCALE_FACTOR;
  
  console.log(`Grid setup for ${cropType}: ${numRows} rows with ${plantsPerRow} plants per row`);
  console.log(`Row spacing: ${scaledRowSpacing}, Plant spacing: ${scaledPlantSpacing}`);
  
  const positions = [];
  
  // Generate grid starting from the bottom-left of the field
  for (let row = 0; row < numRows; row++) {
    // Offset every other row for staggered planting (common in some crops)
    const rowOffset = (cropType === 'corn' || cropType === 'soybean') && row % 2 === 1 
      ? scaledPlantSpacing / 2 
      : 0;
    
    for (let col = 0; col < plantsPerRow; col++) {
      // Calculate base position
      const x = bounds.minX + (col * scaledPlantSpacing) + rowOffset;
      const z = bounds.minZ + (row * scaledRowSpacing);
      
      // Add small random variation for natural look
      const randomX = x + (Math.random() * 2 - 1) * scaledPlantSpacing * RANDOMIZATION_FACTORS.position;
      const randomZ = z + (Math.random() * 2 - 1) * scaledRowSpacing * RANDOMIZATION_FACTORS.position;
      
      const position = { x: randomX, z: randomZ };
      
      // Only add the position if it's inside the polygon
      if (isPointInPolygon(position, polygon)) {
        positions.push(position);
      }
    }
  }
  
  return positions;
};

/**
 * Creates a field information sign at the centroid of the field
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {Object} simulation - Simulation parameters
 * @param {Array} scaledPolygon - Scaled polygon vertices
 * @returns {Array} - Array of created objects
 */
export const createFieldInfoSign = (scene, simulation, scaledPolygon) => {
  const createdObjects = [];
  const { type, hectares, density } = simulation;
  
  // Calculate centroid of the field for sign placement
  let centroidX = 0, centroidZ = 0;
  scaledPolygon.forEach(point => {
    centroidX += point[0];
    centroidZ += point[2];
  });
  centroidX /= scaledPolygon.length;
  centroidZ /= scaledPolygon.length;
  
  // Create sign post
  const postGeometry = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
  const postMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const post = new THREE.Mesh(postGeometry, postMaterial);
  post.position.set(centroidX, 1, centroidZ);
  post.castShadow = true;
  scene.add(post);
  createdObjects.push(post);
  
  // Create sign
  const signGeometry = new THREE.PlaneGeometry(2, 1);
  
  // Create canvas for sign text
  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 128;
  const ctx = canvas.getContext('2d');
  
  // Fill background
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, 256, 128);
  
  // Add border
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 5;
  ctx.strokeRect(5, 5, 246, 118);
  
  // Add text
  ctx.fillStyle = 'black';
  ctx.font = 'bold 20px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(`Crop Simulation`, 128, 30);
  
  ctx.font = '16px Arial';
  ctx.fillText(`Crop: ${type.charAt(0).toUpperCase() + type.slice(1)}`, 128, 55);
  ctx.fillText(`Area: ${hectares.toFixed(1)} hectares`, 128, 80);
  ctx.fillText(`Density: ${density}%`, 128, 105);
  
  // Create texture from canvas
  const texture = new THREE.CanvasTexture(canvas);
  const signMaterial = new THREE.MeshStandardMaterial({
    map: texture,
    side: THREE.DoubleSide
  });
  
  const sign = new THREE.Mesh(signGeometry, signMaterial);
  sign.position.set(centroidX, 2, centroidZ);
  sign.castShadow = true;
  scene.add(sign);
  createdObjects.push(sign);
  
  return createdObjects;
};
</file>

<file path="lib/simulation/index.ts">
import * as THREE from 'three';
import { createPlantSync, preloadCropModels, PLANTS_PER_HECTARE } from '../crops';
import { createFieldSoil, createFieldBoundary } from '../environment';
import {
    scalePolygonToHectares,
    triangulatePolygon,
    getRandomPointInTriangle,
    createFieldInfoSign,
    generateGridPlantPositions
} from './fieldUtils';
import { adjustCameraView } from './cameraUtils';
import { getCropModelPaths, preloadModels, setLoadingCallbacks } from '../services/modelLoader';

// Track loading status
let modelsLoaded = false;
let loadingProgress = 0;

/**
 * Preload all crop models for the simulation
 * @returns {Promise<void>}
 */
export const preloadSimulationModels = async (): Promise<void> => {
    if (modelsLoaded) return;

    try {
        // Preload all crop models
        const modelPaths = Object.values(getCropModelPaths());

        // Set loading callbacks
        setLoadingCallbacks(
            (progress) => {
                loadingProgress = progress;
                console.log(`Model loading progress: ${Math.round(progress * 100)}%`);
            },
            () => {
                modelsLoaded = true;
                console.log('All models loaded successfully');
            }
        );

        await preloadModels(modelPaths);
    } catch (error) {
        console.error('Error preloading models:', error);
    }
};

/**
 * Get current model loading progress
 * @returns {number} - Loading progress from 0 to 1
 */
export const getModelLoadingProgress = (): number => {
    return loadingProgress;
};

/**
 * Check if all models are loaded
 * @returns {boolean} - True if all models are loaded
 */
export const areModelsLoaded = (): boolean => {
    return modelsLoaded;
};

/**
 * Creates a crop field simulation
 * @param {Object} simulation - Simulation parameters
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {THREE.PerspectiveCamera} camera - The THREE.js camera
 * @param {OrbitControls} controls - The OrbitControls instance
 * @returns {Object} - Created simulation objects
 */
export const createCropFieldSimulation = (simulation, scene, camera, controls) => {
    console.log("Creating simulation with params:", simulation);
    console.log("Scene, camera, controls available:", !!scene, !!camera, !!controls);

    const { type, hectares, density, polygon } = simulation;
    const simulationObjects = [];

    try {
        if (!scene) throw new Error("Scene is not initialized");
        if (!camera) throw new Error("Camera is not initialized");
        if (!controls) throw new Error("Controls are not initialized");

        // Start preloading models in the background if not already loaded
        if (!modelsLoaded) {
            preloadSimulationModels().catch(console.error);
        }

        // Scale the polygon based on hectares
        const scaledPolygon = scalePolygonToHectares(polygon, hectares);
        console.log("Scaled polygon vertices:", scaledPolygon);

        // Create field boundary
        const boundary = createFieldBoundary(scene, scaledPolygon);
        simulationObjects.push(boundary);

        // Create soil
        const soil = createFieldSoil(scene, scaledPolygon);
        simulationObjects.push(soil);

        // Triangulate the polygon for plant placement
        const triangles = triangulatePolygon(scaledPolygon);
        console.log(`Created ${triangles.length} triangles for plant placement`);

        // Generate grid-based plant positions
        console.log(`Generating grid-based plant positions for ${type} with ${density}% density`);
        const plantPositions = generateGridPlantPositions(scaledPolygon, type, density);
        console.log(`Generated ${plantPositions.length} plant positions`);

        // Determine maximum number of plants to render based on performance considerations
        // We'll use a higher limit since we're using 3D models with proper scaling
        const maxPlantsToRender = 500;

        // Calculate sample rate if we have too many plants
        let sampleRate = 1;
        if (plantPositions.length > maxPlantsToRender) {
            sampleRate = Math.ceil(plantPositions.length / maxPlantsToRender);
            console.log(`Sampling plants at 1/${sampleRate} rate for performance (${Math.floor(plantPositions.length / sampleRate)} plants)`);
        }

        // Create plants at grid positions with sampling
        let plantsCreated = 0;
        for (let i = 0; i < plantPositions.length; i += sampleRate) {
            const { x, z } = plantPositions[i];

            // Create plant using the sync version for initial setup
            const plant = createPlantSync(type, x, z);

            // Add random rotation for natural variation
            plant.rotation.y = Math.random() * Math.PI * 2;

            scene.add(plant);
            simulationObjects.push(plant);
            plantsCreated++;
        }

        console.log(`Created ${plantsCreated} ${type} plants`);


        // Add information sign - DISABLED per user request
        // const signObjects = createFieldInfoSign(scene, simulation, scaledPolygon);
        // simulationObjects.push(...signObjects);

        // Adjust camera to view the entire field
        adjustCameraView(scaledPolygon, camera, controls);

        console.log(`Successfully created simulation with ${simulationObjects.length} objects`);
        return { success: true, objects: simulationObjects };
    } catch (error) {
        console.error('Error creating simulation:', error);
        return { success: false, error: error.message, objects: simulationObjects };
    }
};

// Export other utilities
export * from './fieldUtils';
export * from './cameraUtils';
export * from './sceneSetup';
</file>

<file path="lib/simulation/plantGrowth.ts">
import { PLANT_HEIGHTS, SCALE_FACTOR } from '../crops';
import * as THREE from 'three';

// Growth stage modifiers (0-1) for different growth phases
export const GROWTH_STAGES = {
    SEEDLING: 0.2,      // Initial growth
    VEGETATIVE: 0.6,    // Main growth phase
    REPRODUCTIVE: 0.9,  // Flowering/fruiting phase
    MATURE: 1.0         // Fully mature
};

/**
 * Update plants in the scene based on growth stage and actual crop heights
 * Supports both geometry-based plants and 3D models
 * @param {Object} timelineDay - The current day's data
 * @param {Array} plants - Array of plant objects in the scene
 * @param {string} cropType - Type of crop
 */
export const updatePlantsForGrowthStage = (timelineDay, plants, cropType) => {
    if (!plants || plants.length === 0) return;

    const { growthFactor, growthStage } = timelineDay;

    // Get the actual base height from crop constants (in meters)
    const baseHeight = PLANT_HEIGHTS[cropType] || 1.0;

    // Scale factor applied to match the 3D scene scale
    const scaledBaseHeight = baseHeight * SCALE_FACTOR;

    console.log(`Updating ${plants.length} ${cropType} plants for growth stage: ${growthStage}`);
    console.log(`Growth progress: ${(growthFactor * 100).toFixed(1)}%`);

    // Update each plant
    plants.forEach(plant => {
        // Skip non-plant objects
        if (!plant.userData || !plant.userData.isPlant) return;

        // Skip plants that are still loading their models
        if (plant.userData.pendingModelLoad) return;

        // Apply growth stage-specific scaling
        const plantScale = calculatePlantScale(growthFactor, growthStage);

        // Determine if this is a 3D model or a geometry-based plant
        const isModel = plant.userData.cropType && !plant.userData.isLegacyGeometry;

        if (isModel) {
            // Update 3D model plant
            updateModelPlant(plant, plantScale, growthStage, cropType);
        } else {
            // Update geometry-based plant (legacy)
            updateGeometryPlant(plant, plantScale, growthStage, cropType);
        }
    });
};

/**
 * Calculate plant scale based on growth factor and stage
 */
function calculatePlantScale(growthFactor, growthStage) {
    let plantScale;

    switch (growthStage) {
        case 'SEEDLING':
            // Small plants in seedling stage (10-30% of full size)
            plantScale = 0.1 + (0.2 * Math.min(1, growthFactor / 0.2));
            break;

        case 'VEGETATIVE':
            // Rapid growth in vegetative stage (30-70% of full size)
            plantScale = 0.3 + (0.4 * Math.min(1, (growthFactor - 0.2) / 0.4));
            break;

        case 'REPRODUCTIVE':
            // Slower growth in reproductive stage (70-90% of full size)
            plantScale = 0.7 + (0.2 * Math.min(1, (growthFactor - 0.6) / 0.3));
            break;

        case 'MATURE':
            // Full size in mature stage (90-100% of full size)
            plantScale = 0.9 + (0.1 * Math.min(1, (growthFactor - 0.9) / 0.1));
            break;

        default:
            // Fallback to direct percent if stage not recognized
            plantScale = Math.max(0.1, growthFactor);
    }

    // Ensure scale is within reasonable bounds
    return Math.max(0.1, Math.min(1.0, plantScale));
}

/**
 * Update a plant based on 3D model approach
 */
function updateModelPlant(plant, plantScale, growthStage, cropType) {
    // If the plant has an originalScale stored, use that as a reference
    const baseScale = plant.userData.originalScale || { x: 1, y: 1, z: 1 };

    // Apply plant-wide scaling (may be refined for particular plant components)
    plant.scale.set(
        baseScale.x * plantScale,
        baseScale.y * plantScale,
        baseScale.z * plantScale
    );

    // Handle visibility of different plant parts based on growth stage
    plant.traverse((child) => {
        // Skip non-meshes
        if (!(child instanceof THREE.Mesh)) return;

        // Handle fruit/grain visibility based on growth stage
        if (child.userData.isFruit || child.userData.isCob ||
            child.userData.isWheatHead || child.userData.isCottonBoll) {
            // Fruits only appear in reproductive and mature stages
            child.visible = (growthStage === 'REPRODUCTIVE' || growthStage === 'MATURE');

            // Enhance fruits in mature stage
            if (growthStage === 'MATURE' && child.userData.originalScale) {
                const fruitScale = 1.2; // Slightly larger fruits when mature
                child.scale.set(
                    child.userData.originalScale.x * fruitScale,
                    child.userData.originalScale.y * fruitScale,
                    child.userData.originalScale.z * fruitScale
                );
            }
        }

        // Handle flowers which appear in reproductive stage then become fruit
        if (child.userData.isFlower) {
            // Flowers appear in early reproductive stage and may disappear in mature
            child.visible = (growthStage === 'REPRODUCTIVE' && plantScale < 0.85);
        }

        // Apply crop-specific visual effects
        applyCropSpecificEffects(child, cropType, growthStage, plantScale);
    });
}

/**
 * Apply crop-specific visual effects for 3D models
 */
function applyCropSpecificEffects(meshNode, cropType, growthStage, plantScale) {
    switch (cropType) {
        case 'corn':
            // For corn specifically, enhance cob visibility based on growth
            if (meshNode.userData.isCob) {
                // Primary cob - show only in reproductive and mature stages
                meshNode.visible = growthStage === 'REPRODUCTIVE' || growthStage === 'MATURE';

                // Determine which cob this is (primary or secondary)
                const isPrimaryCob = meshNode.position.y > meshNode.parent.position.y * 0.6;
                const isSecondaryCob = !isPrimaryCob;

                // Secondary cobs only appear in mature stage with healthy plants
                if (isSecondaryCob) {
                    meshNode.visible = growthStage === 'MATURE' && plantScale > 0.9;
                }
            }
            break;

        case 'wheat':
            // Wheat heads gradually change color as they mature
            if (meshNode.userData.isWheatHead && meshNode.material) {
                if (growthStage === 'REPRODUCTIVE') {
                    // Transition from green to golden
                    const greenToGold = Math.min(1, (plantScale - 0.7) / 0.2);
                    meshNode.material.color.setRGB(
                        0.5 + (0.5 * greenToGold),  // R: 0.5 to 1.0
                        0.5 + (0.3 * greenToGold),  // G: 0.5 to 0.8
                        0.2                         // B: constant low value
                    );
                } else if (growthStage === 'MATURE') {
                    // Golden when mature
                    meshNode.material.color.setRGB(0.95, 0.85, 0.2);
                }
            }
            break;

        case 'cotton':
            // Cotton bolls gradually open as they mature
            if (meshNode.userData.isCottonBoll) {
                if (growthStage === 'REPRODUCTIVE') {
                    // Bolls are green and closed in early reproductive stage
                    if (plantScale < 0.8 && meshNode.material) {
                        meshNode.material.color.setRGB(0.2, 0.7, 0.3);
                    } else {
                        // Start to open/whiten in late reproductive
                        if (meshNode.material) {
                            const openingFactor = (plantScale - 0.8) / 0.1;
                            meshNode.material.color.setRGB(
                                0.3 + (0.7 * openingFactor),
                                0.7 + (0.3 * openingFactor),
                                0.3 + (0.7 * openingFactor)
                            );
                        }

                        // Slightly increase scale to show "opening"
                        if (meshNode.userData.originalScale) {
                            const openScale = 1 + ((plantScale - 0.8) / 0.1) * 0.3;
                            meshNode.scale.set(
                                meshNode.userData.originalScale.x * openScale,
                                meshNode.userData.originalScale.y * openScale,
                                meshNode.userData.originalScale.z * openScale
                            );
                        }
                    }
                } else if (growthStage === 'MATURE') {
                    // Fully white and open in mature stage
                    if (meshNode.material) {
                        meshNode.material.color.setRGB(1, 1, 1);
                    }

                    // Expanded scale for fully open bolls
                    if (meshNode.userData.originalScale) {
                        meshNode.scale.set(
                            meshNode.userData.originalScale.x * 1.3,
                            meshNode.userData.originalScale.y * 1.3,
                            meshNode.userData.originalScale.z * 1.3
                        );
                    }
                }
            }
            break;
    }
}

/**
 * Update a plant based on the legacy geometry approach
 */
function updateGeometryPlant(plant, plantScale, growthStage, cropType) {
    // Set scale of the plant to match the growth progress
    plant.scale.set(
        plantScale,
        plantScale,
        plantScale
    );

    // Handle crop-specific visual changes based on growth stage
    switch (cropType) {
        case 'corn':
            // For corn specifically, show/hide cobs based on growth stage
            if (plant.children && plant.children.length > 2) {
                // Primary cob - show only in reproductive and mature stages
                if (plant.children[2]) {
                    plant.children[2].visible = growthStage === 'REPRODUCTIVE' || growthStage === 'MATURE';
                }

                // Secondary cob (if exists) - show only in mature stage
                if (plant.children[3]) {
                    plant.children[3].visible = growthStage === 'MATURE';
                }
            }
            break;

        case 'soybean':
            // For soybean, show pods only in reproductive and mature stages
            if (plant.children) {
                for (let i = 0; i < plant.children.length; i++) {
                    // Identify pod elements in the soybean model (typically these are positioned higher up)
                    const child = plant.children[i];
                    if (child.position && child.position.y > 0.5 && child.geometry &&
                        (child.geometry.type === 'CapsuleGeometry' || child.geometry.type === 'SphereGeometry')) {
                        child.visible = growthStage === 'REPRODUCTIVE' || growthStage === 'MATURE';
                    }
                }
            }
            break;

        case 'wheat':
            // For wheat, show wheat heads only in reproductive and mature stages
            if (plant.children && plant.children.length > 1) {
                // Wheat head is typically the second child in our model
                if (plant.children[1]) {
                    plant.children[1].visible = growthStage === 'REPRODUCTIVE' || growthStage === 'MATURE';
                }
            }
            break;

        case 'cotton':
            // For cotton, show cotton bolls only in reproductive and mature stages
            if (plant.children) {
                for (let i = 0; i < plant.children.length; i++) {
                    const child = plant.children[i];
                    // Cotton bolls are typically white sphere geometries
                    if (child.material && child.material.color &&
                        child.material.color.r > 0.8 && child.material.color.g > 0.8 && child.material.color.b > 0.8) {
                        child.visible = growthStage === 'REPRODUCTIVE' || growthStage === 'MATURE';

                        // Make bolls more visible in mature stage
                        if (growthStage === 'MATURE') {
                            child.scale.set(1.2, 1.2, 1.2);
                        }
                    }
                }
            }
            break;

        case 'rice':
            // For rice, show grains only in reproductive and mature stages
            if (plant.children) {
                for (let i = 0; i < plant.children.length; i++) {
                    const child = plant.children[i];
                    // Rice grains are typically at the top and have cone geometries
                    if (child.geometry && child.geometry.type === 'ConeGeometry') {
                        child.visible = growthStage === 'REPRODUCTIVE' || growthStage === 'MATURE';
                    }
                }
            }
            break;
    }
}

/**
 * Determine growth stage based on growth percentage
 * @param {number} growthFactor - Growth percentage (0-1)
 * @returns {string} Growth stage
 */
export const determineGrowthStage = (growthFactor) => {
    if (growthFactor < GROWTH_STAGES.SEEDLING) {
        return 'SEEDLING';
    } else if (growthFactor < GROWTH_STAGES.VEGETATIVE) {
        return 'VEGETATIVE';
    } else if (growthFactor < GROWTH_STAGES.REPRODUCTIVE) {
        return 'REPRODUCTIVE';
    } else {
        return 'MATURE';
    }
};
</file>

<file path="lib/weather/weatherService.tsx">
// lib/weather/weatherService.ts

// List of standardized weather types
export const WEATHER_TYPES = {
    SUNNY: 'sunny',
    PARTLY_CLOUDY: 'partly_cloudy',
    CLOUDY: 'cloudy',
    RAINY: 'rainy',
    STORMY: 'stormy'
  };
  
  // Weather effects settings
  export const WEATHER_SETTINGS = {
    [WEATHER_TYPES.SUNNY]: {
      skyColor: 0x87ceeb,
      fogColor: 0xd7f0ff,
      fogDensity: 0.0025,
      lightIntensity: 1.0,
      ambientIntensity: 0.6,
      rainParticles: 0,
      cloudOpacity: 0.8,
      cloudCount: 10
    },
    [WEATHER_TYPES.PARTLY_CLOUDY]: {
      skyColor: 0x87ceeb,
      fogColor: 0xd7f0ff,
      fogDensity: 0.003,
      lightIntensity: 0.8,
      ambientIntensity: 0.5,
      rainParticles: 0,
      cloudOpacity: 0.9,
      cloudCount: 20
    },
    [WEATHER_TYPES.CLOUDY]: {
      skyColor: 0xa3b5c7,
      fogColor: 0xc7c7c7,
      fogDensity: 0.004,
      lightIntensity: 0.6,
      ambientIntensity: 0.4,
      rainParticles: 0,
      cloudOpacity: 1.0,
      cloudCount: 30
    },
    [WEATHER_TYPES.RAINY]: {
      skyColor: 0x708090,
      fogColor: 0xa3a3a3,
      fogDensity: 0.006,
      lightIntensity: 0.5,
      ambientIntensity: 0.3,
      rainParticles: 1000,
      cloudOpacity: 1.0,
      cloudCount: 35
    },
    [WEATHER_TYPES.STORMY]: {
      skyColor: 0x4a5259,
      fogColor: 0x7a7a7a,
      fogDensity: 0.008,
      lightIntensity: 0.4,
      ambientIntensity: 0.2,
      rainParticles: 2000,
      cloudOpacity: 1.0,
      cloudCount: 40
    }
  };
  
  // Interface for weather data from API
  export interface WeatherApiResponse {
    main: {
      temp: number;
      humidity: number;
    };
    weather: {
      id: number;
      main: string;
      description: string;
    }[];
    wind: {
      speed: number;
    };
    dt: number; // Unix timestamp
  }
  
  // Interface for historical weather data
  export interface HistoricalWeatherDay {
    date: string;
    temperature: number;
    humidity: number;
    weatherType: string;
    windSpeed: number;
  }
  
  // Interface for simulation weather day
  export interface SimulationWeatherDay {
    date: Date;
    dayNumber: number;
    dateString: string;
    weather: string;
    temperature: number;
    humidity: number;
    growthFactor: number;
    settings: any;
  }
  
  // Map OpenWeatherMap condition codes to our weather types
  export function mapWeatherCodeToType(code: number): string {
    // Thunderstorm: 200-299
    if (code >= 200 && code < 300) {
      return WEATHER_TYPES.STORMY;
    }
    // Drizzle and Rain: 300-599
    else if (code >= 300 && code < 600) {
      return WEATHER_TYPES.RAINY;
    }
    // Snow: 600-699 - we'll map to rainy for now
    else if (code >= 600 && code < 700) {
      return WEATHER_TYPES.RAINY;
    }
    // Atmosphere (fog, mist, etc): 700-799
    else if (code >= 700 && code < 800) {
      return WEATHER_TYPES.CLOUDY;
    }
    // Clear: 800
    else if (code === 800) {
      return WEATHER_TYPES.SUNNY;
    }
    // Clouds: 801-899
    else if (code > 800 && code < 900) {
      // Few clouds (801) or scattered clouds (802) maps to partly cloudy
      return code <= 802 ? WEATHER_TYPES.PARTLY_CLOUDY : WEATHER_TYPES.CLOUDY;
    }
    // Default
    return WEATHER_TYPES.PARTLY_CLOUDY;
  }
  
  // Calculate growth factor based on weather conditions
  export function calculateGrowthFactor(temperature: number, weatherType: string, humidity: number): number {
    // Optimal temperature range for most crops is around 15-25°C (59-77°F)
    const tempFactor = 1 - Math.abs(20 - temperature) / 20;
    console.log('tempFactor')
    console.log(tempFactor)
    
    // Plants like sunlight but need some water too
    const sunFactor = weatherType === WEATHER_TYPES.SUNNY ? 1.0 : 
                    weatherType === WEATHER_TYPES.PARTLY_CLOUDY ? 0.8 : 
                    weatherType === WEATHER_TYPES.CLOUDY ? 0.6 : 
                    weatherType === WEATHER_TYPES.RAINY ? 0.4 : 0.3;
    
    // Optimal humidity range is around 60-70%
    console.log('sunFactor')
    console.log(sunFactor)
    const moistureFactor = Math.min(1.0, humidity / 70) * (humidity <= 85 ? 1 : 0.8);
    console.log('moistureFactor')
    console.log(moistureFactor)
    
    // Combine factors with different weights
    const growthFactor = Math.max(0, Math.min(1, (tempFactor * 0.4 + sunFactor * 0.3 + moistureFactor * 0.3)))
    console.log('growthFactor')
    console.log(growthFactor)
    return growthFactor;
  }
  
  // Generate random historical weather for a location based on climate patterns
  export function generateHistoricalWeather(
    latitude: number, 
    longitude: number, 
    startDate: Date, 
    days: number
  ): HistoricalWeatherDay[] {
    const weatherData: HistoricalWeatherDay[] = [];
    const currentDate = new Date(startDate);
    
    // Determine hemisphere and adjust seasonal patterns
    const isNorthernHemisphere = latitude > 0;
    
    for (let i = 0; i < days; i++) {
      const date = new Date(currentDate);
      
      // Get month to determine season
      const month = date.getMonth();
      
      // Determine season based on hemisphere
      let season;
      if (isNorthernHemisphere) {
        if (month >= 2 && month <= 4) season = 'spring';
        else if (month >= 5 && month <= 7) season = 'summer';
        else if (month >= 8 && month <= 10) season = 'fall';
        else season = 'winter';
      } else {
        if (month >= 2 && month <= 4) season = 'fall';
        else if (month >= 5 && month <= 7) season = 'winter';
        else if (month >= 8 && month <= 10) season = 'spring';
        else season = 'summer';
      }
      
      // Adjust base temperature based on latitude (equator is hotter)
      let baseTemp = 20 - Math.abs(latitude) * 0.4;
      
      // Seasonal adjustments
      switch (season) {
        case 'spring': baseTemp += 5; break;
        case 'summer': baseTemp += 10; break;
        case 'fall': baseTemp += 2; break;
        case 'winter': baseTemp -= 5; break;
      }
      
      // Weather determination - weather patterns are more consistent
      // and influenced by previous day
      let weatherType;
      if (i === 0 || Math.random() < 0.3) {
        // New weather pattern
        const rand = Math.random();
        if (rand < 0.4) weatherType = WEATHER_TYPES.SUNNY;
        else if (rand < 0.7) weatherType = WEATHER_TYPES.PARTLY_CLOUDY;
        else if (rand < 0.85) weatherType = WEATHER_TYPES.CLOUDY;
        else if (rand < 0.95) weatherType = WEATHER_TYPES.RAINY;
        else weatherType = WEATHER_TYPES.STORMY;
        
        // Seasonal adjustments to weather probability
        if (season === 'summer' && weatherType === WEATHER_TYPES.SUNNY) weatherType = WEATHER_TYPES.SUNNY;
        if (season === 'winter' && weatherType === WEATHER_TYPES.SUNNY && Math.random() < 0.5) weatherType = WEATHER_TYPES.CLOUDY;
        if (season === 'spring' && weatherType === WEATHER_TYPES.PARTLY_CLOUDY && Math.random() < 0.4) weatherType = WEATHER_TYPES.RAINY;
      } else {
        // Continue previous weather pattern
        weatherType = weatherData[i - 1].weatherType;
        
        // Some chance of change
        if (Math.random() < 0.2) {
          const options = [WEATHER_TYPES.SUNNY, WEATHER_TYPES.PARTLY_CLOUDY, WEATHER_TYPES.CLOUDY, WEATHER_TYPES.RAINY];
          weatherType = options[Math.floor(Math.random() * options.length)];
        }
      }
      
      // Adjust temperature based on weather
      let tempModifier = 0;
      switch (weatherType) {
        case WEATHER_TYPES.SUNNY: tempModifier = 3; break;
        case WEATHER_TYPES.PARTLY_CLOUDY: tempModifier = 1; break;
        case WEATHER_TYPES.CLOUDY: tempModifier = -1; break;
        case WEATHER_TYPES.RAINY: tempModifier = -3; break;
        case WEATHER_TYPES.STORMY: tempModifier = -5; break;
      }
      
      // Add some random variation
      const tempVariance = (Math.random() * 4) - 2; // -2 to +2 degrees
      
      // Calculate humidity based on weather type and location
      let baseHumidity = 60; // Default humidity
      
      // Adjust humidity based on weather
      switch (weatherType) {
        case WEATHER_TYPES.SUNNY: baseHumidity -= 20; break;
        case WEATHER_TYPES.PARTLY_CLOUDY: baseHumidity -= 10; break;
        case WEATHER_TYPES.CLOUDY: baseHumidity += 5; break;
        case WEATHER_TYPES.RAINY: baseHumidity += 20; break;
        case WEATHER_TYPES.STORMY: baseHumidity += 30; break;
      }
      
      // Add some random variation to humidity
      const humidityVariance = (Math.random() * 10) - 5; // -5 to +5 percent
      
      // Generate wind speed based on weather and location
      let baseWindSpeed = 2 + Math.random() * 3; // Base wind speed in m/s
      
      // Adjust wind speed based on weather
      switch (weatherType) {
        case WEATHER_TYPES.SUNNY: baseWindSpeed *= 0.8; break;
        case WEATHER_TYPES.PARTLY_CLOUDY: baseWindSpeed *= 1.0; break;
        case WEATHER_TYPES.CLOUDY: baseWindSpeed *= 1.2; break;
        case WEATHER_TYPES.RAINY: baseWindSpeed *= 1.5; break;
        case WEATHER_TYPES.STORMY: baseWindSpeed *= 2.5; break;
      }
      
      // Add to weather data array
      weatherData.push({
        date: date.toISOString().split('T')[0],
        temperature: Math.round((baseTemp + tempModifier + tempVariance) * 10) / 10,
        humidity: Math.min(100, Math.max(10, Math.round(baseHumidity + humidityVariance))),
        weatherType: weatherType,
        windSpeed: Math.round(baseWindSpeed * 10) / 10
      });
      
      // Move to next day
      currentDate.setDate(currentDate.getDate() + 1);
    }
    
    return weatherData;
  }
  
  // Convert historical weather data to simulation weather days
  export function convertToSimulationWeatherDays(
    historicalData: HistoricalWeatherDay[]
  ): SimulationWeatherDay[] {
    return historicalData.map((day, index) => {
      const growthFactor = calculateGrowthFactor(
        day.temperature,
        day.weatherType,
        day.humidity
      );

      console.log('growthFactor2')
      console.log(growthFactor)
      
      return {
        date: new Date(day.date),
        dayNumber: index + 1,
        dateString: new Date(day.date).toLocaleDateString(),
        weather: day.weatherType,
        temperature: day.temperature,
        humidity: day.humidity,
        growthFactor: growthFactor,
        settings: WEATHER_SETTINGS[day.weatherType]
      };
    });
  }
  
  // Fetch current weather data from OpenWeatherMap API
  export async function fetchCurrentWeather(
    latitude: number,
    longitude: number,
    apiKey: string
  ): Promise<WeatherApiResponse> {
    try {
      const response = await fetch(
        `https://api.openweathermap.org/data/2.5/weather?lat=${latitude}&lon=${longitude}&units=metric&appid=${apiKey}`
      );
      
      if (!response.ok) {
        throw new Error(`Weather API responded with status: ${response.status}`);
      }
      
      return await response.json();
    } catch (error) {
      console.error('Error fetching weather data:', error);
      throw error;
    }
  }
  
  // Convert API response to our weather format
  export function processWeatherApiResponse(
    apiResponse: WeatherApiResponse
  ): {
    temperature: number;
    humidity: number;
    weatherType: string;
    windSpeed: number;
  } {
    // Get weather code from the first weather item
    const weatherCode = apiResponse.weather[0].id;
    
    return {
      temperature: apiResponse.main.temp,
      humidity: apiResponse.main.humidity,
      weatherType: mapWeatherCodeToType(weatherCode),
      windSpeed: apiResponse.wind.speed
    };
  }
</file>

<file path="components/farm/FarmSetupWizard.tsx">
// components/farm/FarmSetupWizard.tsx
'use client'

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import LocationInput from '@/app/simulation/components/LocationInput';
import LocationInputWithMap from './LocationInputWithMap';
import FarmShapeStep from './FarmShapeStep';
import FarmSizeStep from './FarmSizeStep';
import FarmReviewStep from './FarmReviewStep';

// Import additional components as needed

enum SetupStep {
  LOCATION = 0,
  FARM_SIZE = 1,
  FARM_SHAPE = 2,
  CROP_SELECTION = 3,
  REVIEW = 4
}

const FarmSetupWizard = () => {
  const router = useRouter();
  
  // Wizard state
  const [currentStep, setCurrentStep] = useState<SetupStep>(SetupStep.LOCATION);
  const [isLoading, setIsLoading] = useState(false);
  
  // Farm configuration state
  const [farmLocation, setFarmLocation] = useState<{
    latitude: number;
    longitude: number;
    name: string;
  }>({
    latitude: -12.915559,
    longitude: -55.314216,
    name: 'Mato Grosso, Brazil'
  });
  
  const [farmSize, setFarmSize] = useState<number>(350); // Set default to 350 hectares
  const [farmShape, setFarmShape] = useState<Array<{latitude: number; longitude: number}>>([
    // Default polygon points based on the farm center and size
    { latitude: farmLocation.latitude + 0.01, longitude: farmLocation.longitude - 0.01 },
    { latitude: farmLocation.latitude + 0.01, longitude: farmLocation.longitude + 0.01 },
    { latitude: farmLocation.latitude - 0.01, longitude: farmLocation.longitude + 0.01 },
    { latitude: farmLocation.latitude - 0.01, longitude: farmLocation.longitude - 0.01 }
  ]);
  const [cropType, setCropType] = useState<string>('corn');
  
  // Handle location change from LocationInput component
  const handleLocationChange = (latitude: number, longitude: number, locationName: string) => {
    setFarmLocation({
      latitude,
      longitude,
      name: locationName
    });
  };
  
  // Handle farm size change
  const handleFarmSizeChange = (size: number) => {
    setFarmSize(size);
  };
  
  // Handle farm shape completion
  const handleFarmShapeComplete = (polygonPoints: Array<{latitude: number; longitude: number}>) => {
    setFarmShape(polygonPoints);
    nextStep();
  };
  
  // Handle crop type selection
  const handleCropSelection = (crop: string) => {
    setCropType(crop);
    nextStep();
  };
  
  // Navigate to next step
  const nextStep = () => {
    if (currentStep < SetupStep.REVIEW) {
      setCurrentStep(currentStep + 1);
    } else {
      startSimulation();
    }
  };
  
  // Navigate to previous step
  const prevStep = () => {
    if (currentStep > SetupStep.LOCATION) {
      setCurrentStep(currentStep - 1);
    }
  };
  
  // Start the simulation with collected data
  const startSimulation = () => {
    setIsLoading(true);
    
    // In a real application, you might want to save this data to a backend
    // or pass it via state management to the simulation page
    
    // For now, we'll pass basic parameters through the URL
    const params = new URLSearchParams({
      lat: farmLocation.latitude.toString(),
      lng: farmLocation.longitude.toString(),
      hectares: farmSize.toString(),
      crop: cropType,
      // We'll need a more sophisticated way to pass the polygon data in a real app
      // This is just a placeholder
      polygon: JSON.stringify(farmShape)
    });
    
    // Navigate to simulation page
    setTimeout(() => {
      router.push(`/simulation?${params.toString()}`);
    }, 1000);
  };
  
  // Determine which step to render
  const renderStep = () => {
    switch (currentStep) {
      case SetupStep.LOCATION:
        return (
          <div className="bg-white p-6 rounded-lg shadow-md">
            <h2 className="text-2xl font-semibold mb-4 text-green-800">Select Your Farm Location</h2>
            <p className="text-gray-600 mb-6">
              Select your farm's location by clicking on the map, searching by name, or entering coordinates.
              This will be used to fetch weather and satellite data for your simulation.
            </p>
            
            <LocationInputWithMap 
              onLocationChange={handleLocationChange} 
              initialLocation={farmLocation}
            />
            
            <div className="flex justify-end mt-6">
              <button
                onClick={nextStep}
                className="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
              >
                Continue
              </button>
            </div>
          </div>
        );
        
      case SetupStep.FARM_SIZE:
        return (
          <FarmSizeStep
            farmLocation={farmLocation}
            farmSize={farmSize}
            onFarmSizeChange={handleFarmSizeChange}
            onContinue={nextStep}
            onBack={prevStep}
          />
        );
        
      case SetupStep.FARM_SHAPE:
        return (
          <FarmShapeStep
            farmLocation={farmLocation}
            farmSize={farmSize}
            onComplete={handleFarmShapeComplete}
            onBack={prevStep}
          />
        );
        
      case SetupStep.CROP_SELECTION:
        return (
          <div className="bg-white p-6 rounded-lg shadow-md">
            <h2 className="text-2xl font-semibold mb-4 text-green-800">Select Your Crop</h2>
            <p className="text-gray-600 mb-6">
              Choose the crop type you want to simulate on your farm.
            </p>
            
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              {['corn', 'soybean', 'wheat'].map((crop) => (
                <div
                  key={crop}
                  onClick={() => handleCropSelection(crop)}
                  className={`p-4 border rounded-lg cursor-pointer transition-all ${
                    cropType === crop 
                      ? 'border-green-500 bg-green-50 shadow-md' 
                      : 'border-gray-200 hover:border-green-300 hover:bg-green-50'
                  }`}
                >
                  <div className="text-center">
                    <div className="text-3xl mb-2">
                      {crop === 'corn' ? '🌽' : crop === 'soybean' ? '🌱' : '🌾'}
                    </div>
                    <div className="font-medium capitalize">{crop}</div>
                  </div>
                </div>
              ))}
            </div>
            
            <div className="flex justify-between mt-6">
              <button
                onClick={prevStep}
                className="px-6 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600"
              >
                Back
              </button>
              <button
                onClick={nextStep}
                className="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
              >
                Continue
              </button>
            </div>
          </div>
        );
        
      case SetupStep.REVIEW:
        return (
          <FarmReviewStep
            farmLocation={farmLocation}
            farmSize={farmSize}
            farmPolygon={farmShape}
            cropType={cropType}
            onStartSimulation={startSimulation}
            onBack={prevStep}
          />
        );
        
      default:
        return (
          <div className="bg-white p-6 rounded-lg shadow-md">
            <h2 className="text-2xl font-semibold mb-4 text-green-800">Something went wrong</h2>
            <p className="text-gray-600 mb-6">
              We couldn't determine which step to display. Please try again.
            </p>
            <button
              onClick={() => setCurrentStep(SetupStep.LOCATION)}
              className="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700"
            >
              Start Over
            </button>
          </div>
        );
    }
  };
  
  // Progress bar calculation
  const progressPercentage = ((currentStep + 1) / (Object.keys(SetupStep).length / 2)) * 100;
  
  // Get current step name
  const getCurrentStepName = () => {
    switch (currentStep) {
      case SetupStep.LOCATION:
        return 'Location';
      case SetupStep.FARM_SIZE:
        return 'Farm Size';
      case SetupStep.FARM_SHAPE:
        return 'Farm Shape';
      case SetupStep.CROP_SELECTION:
        return 'Crop Selection';
      case SetupStep.REVIEW:
        return 'Review';
      default:
        return '';
    }
  };
  
  return (
    <div className="max-w-4xl mx-auto">
      {/* Loading overlay */}
      {isLoading && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-lg text-center">
            <div className="inline-block w-10 h-10 border-4 border-green-500 border-t-transparent rounded-full animate-spin mb-4"></div>
            <p className="text-lg font-medium">Preparing your simulation...</p>
          </div>
        </div>
      )}
      
      {/* Progress bar */}
      <div className="mb-6">
        <div className="flex justify-between text-sm text-gray-600 mb-2">
          <div>Step {currentStep + 1} of {Object.keys(SetupStep).length / 2}</div>
          <div>{getCurrentStepName()}</div>
        </div>
        <div className="h-2 bg-gray-200 rounded-full overflow-hidden">
          <div 
            className="h-full bg-green-600 transition-all duration-300 ease-in-out"
            style={{ width: `${progressPercentage}%` }}
          ></div>
        </div>
      </div>
      
      {/* Current step content */}
      {renderStep()}
    </div>
  );
};

export default FarmSetupWizard;
</file>

<file path="package.json">
{
  "name": "start-hack",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "leaflet": "^1.9.4",
    "next": "15.2.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-leaflet": "5.0.0-rc.2",
    "three": "^0.174.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/leaflet": "^1.9.16",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.174.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

body {
  background: var(--background);
  color: var(--foreground);
}

button,
a,
select {
  cursor: pointer;
}

@layer base {
  h1 {
    @apply text-3xl font-bold;
  }
  h2 {
    @apply text-2xl font-bold;
  }
  h3 {
    @apply text-xl font-bold;
  }
}

@keyframes shine {
  from {
    left: -100%;
  }
  to {
    left: 200%;
  }
}

.animate-shine {
  animation: shine 1.5s ease-in-out infinite;
}

main {
  background-image: src("images/farm-hero.png");
}

@keyframes grow {
  0% {
    transform: scale(0.1);
    opacity: 0;
  }
  100% {
    transform: scale(1);
    opacity: 1;
  }
}

@keyframes sway {
  0% {
    transform: rotate(0deg);
  }
  25% {
    transform: rotate(2deg);
  }
  75% {
    transform: rotate(-2deg);
  }
  100% {
    transform: rotate(0deg);
  }
}

@keyframes fall {
  0% {
    transform: translateY(-10px);
    opacity: 0;
  }
  50% {
    opacity: 1;
  }
  100% {
    transform: translateY(100px);
    opacity: 0;
  }
}

@keyframes float {
  0% {
    transform: translateY(0px);
  }
  50% {
    transform: translateY(-10px);
  }
  100% {
    transform: translateY(0px);
  }
}

@keyframes pulse {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.05);
  }
  100% {
    transform: scale(1);
  }
}

.crop-seedling {
  animation: grow 2s ease-out forwards;
}

.crop-growing {
  animation: sway 4s ease-in-out infinite;
}

.crop-mature {
  animation: sway 6s ease-in-out infinite;
}

.crop-harvesting {
  animation: pulse 2s ease-in-out infinite;
}

.weather-rain {
  animation: fall 1.5s linear infinite;
}

.notification {
  animation: float 2s ease-in-out;
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import Navbar from '@/components/ui/Navbar';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
    title: 'Farm Bio-Boost Simulator',
    description: 'Simulate the effects of biological products on crop performance',
};

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="en">
            <body className={`${inter.className} bg-gray-50 min-h-screen`}>
                <main className="max-w-full mx-auto">{children}</main>
            </body>
        </html>
    );
}
</file>

<file path="lib/simulation/timeline.ts">
// lib/simulation/timeline.ts - Updated version with location-based weather

import * as THREE from 'three';
import {
    generateHistoricalWeather,
    convertToSimulationWeatherDays,
    WEATHER_TYPES
} from '../weather/weatherService';
import { applyWeatherToScene, RainSystem } from '../weather';
import { PLANT_HEIGHTS } from '../crops';



// Growth stage modifiers (0-1) for different growth phases
const GROWTH_STAGES = {
    SEEDLING: 0.2,      // Initial growth
    VEGETATIVE: 0.6,    // Main growth phase
    REPRODUCTIVE: 0.9,  // Flowering/fruiting phase
    MATURE: 1.0         // Fully mature
};

/**
 * Creates a timeline for crop growth and weather simulation
 * @param {Object} cropData - Crop type and initial parameters
 * @param {Date} startDate - Start date of simulation
 * @param {number} days - Number of days to simulate
 * @returns {Object} Timeline data
 */
export const createCropTimeline = (cropData, startDate = new Date(), days = 90) => {
    const { type, hectares, density, location } = cropData;

    // Generate weather data based on location
    let weatherData;
    if (location && location.latitude !== undefined && location.longitude !== undefined) {
        const historicalWeather = generateHistoricalWeather(
            location.latitude,
            location.longitude,
            startDate,
            days
        );
        weatherData = convertToSimulationWeatherDays(historicalWeather);
    } else {
        // Fallback to generic weather data if location is not provided
        weatherData = generateGenericWeatherData(days, startDate);
    }

    return {
        type,
        hectares,
        density,
        location: location || null,
        days: weatherData
    };
};

// Fallback function to generate generic weather data
const generateGenericWeatherData = (days, startDate = new Date()) => {
    const weatherData = [];
    const currentDate = new Date(startDate);

    for (let i = 0; i < days; i++) {
        const date = new Date(currentDate);

        // Get month to determine season
        const month = date.getMonth();

        // Determine season
        let season;
        if (month >= 2 && month <= 4) season = 'spring';
        else if (month >= 5 && month <= 7) season = 'summer';
        else if (month >= 8 && month <= 10) season = 'fall';
        else season = 'winter';

        // Base temperature
        let baseTemp = 0;
        switch (season) {
            case 'spring': baseTemp = 15; break; // ~60°F
            case 'summer': baseTemp = 25; break; // ~77°F
            case 'fall': baseTemp = 18; break;   // ~64°F
            case 'winter': baseTemp = 5; break;  // ~41°F
        }

        // Random weather with seasonal influence
        let weather;
        const rand = Math.random();

        if (season === 'summer') {
            if (rand < 0.5) weather = WEATHER_TYPES.SUNNY;
            else if (rand < 0.8) weather = WEATHER_TYPES.PARTLY_CLOUDY;
            else if (rand < 0.9) weather = WEATHER_TYPES.CLOUDY;
            else weather = WEATHER_TYPES.RAINY;
        } else if (season === 'winter') {
            if (rand < 0.2) weather = WEATHER_TYPES.SUNNY;
            else if (rand < 0.4) weather = WEATHER_TYPES.PARTLY_CLOUDY;
            else if (rand < 0.7) weather = WEATHER_TYPES.CLOUDY;
            else if (rand < 0.9) weather = WEATHER_TYPES.RAINY;
            else weather = WEATHER_TYPES.STORMY;
        } else {
            // Spring and fall
            if (rand < 0.3) weather = WEATHER_TYPES.SUNNY;
            else if (rand < 0.6) weather = WEATHER_TYPES.PARTLY_CLOUDY;
            else if (rand < 0.8) weather = WEATHER_TYPES.CLOUDY;
            else if (rand < 0.95) weather = WEATHER_TYPES.RAINY;
            else weather = WEATHER_TYPES.STORMY;
        }

        // Adjust temp based on weather
        let tempModifier = 0;
        switch (weather) {
            case WEATHER_TYPES.SUNNY: tempModifier = 5; break;
            case WEATHER_TYPES.PARTLY_CLOUDY: tempModifier = 2; break;
            case WEATHER_TYPES.CLOUDY: tempModifier = 0; break;
            case WEATHER_TYPES.RAINY: tempModifier = -3; break;
            case WEATHER_TYPES.STORMY: tempModifier = -5; break;
        }

        // Random variation
        const tempVariance = (Math.random() * 4) - 2; // -2 to +2 degrees

        // Generate humidity based on weather
        let baseHumidity = 0;
        switch (weather) {
            case WEATHER_TYPES.SUNNY: baseHumidity = 30; break;
            case WEATHER_TYPES.PARTLY_CLOUDY: baseHumidity = 45; break;
            case WEATHER_TYPES.CLOUDY: baseHumidity = 60; break;
            case WEATHER_TYPES.RAINY: baseHumidity = 80; break;
            case WEATHER_TYPES.STORMY: baseHumidity = 90; break;
        }

        // Add random variation to humidity
        const humidityVariance = (Math.random() * 10) - 5; // -5 to +5 percent

        // Calculate growth factor based on conditions
        const tempFactor = 1 - Math.abs(22 - (baseTemp + tempModifier + tempVariance)) / 22;
        const sunFactor = weather === WEATHER_TYPES.SUNNY ? 1.0 :
            weather === WEATHER_TYPES.PARTLY_CLOUDY ? 0.8 :
                weather === WEATHER_TYPES.CLOUDY ? 0.6 :
                    weather === WEATHER_TYPES.RAINY ? 0.4 : 0.3;
        const moistureFactor = Math.min(1.0, (baseHumidity + humidityVariance) / 70);
        console.log('tempFactor')
        console.log(tempFactor)
        console.log('sunFactor')
        console.log(sunFactor)
        console.log('moistureFactor')
        console.log(moistureFactor)

        // Calculate final growth factor
        const growthFactor = (tempFactor * 0.4 + sunFactor * 0.3 + moistureFactor * 0.3);
        console.log('GrowthFactor')
        console.log(growthFactor)

        // Get weather settings
        const settings = {
            [WEATHER_TYPES.SUNNY]: {
                skyColor: 0x87ceeb,
                fogColor: 0xd7f0ff,
                fogDensity: 0.0025,
                lightIntensity: 1.0,
                ambientIntensity: 0.6,
                rainParticles: 0,
                cloudOpacity: 0.8,
                cloudCount: 10
            },
            [WEATHER_TYPES.PARTLY_CLOUDY]: {
                skyColor: 0x87ceeb,
                fogColor: 0xd7f0ff,
                fogDensity: 0.003,
                lightIntensity: 0.8,
                ambientIntensity: 0.5,
                rainParticles: 0,
                cloudOpacity: 0.9,
                cloudCount: 20
            },
            [WEATHER_TYPES.CLOUDY]: {
                skyColor: 0xa3b5c7,
                fogColor: 0xc7c7c7,
                fogDensity: 0.004,
                lightIntensity: 0.6,
                ambientIntensity: 0.4,
                rainParticles: 0,
                cloudOpacity: 1.0,
                cloudCount: 30
            },
            [WEATHER_TYPES.RAINY]: {
                skyColor: 0x708090,
                fogColor: 0xa3a3a3,
                fogDensity: 0.006,
                lightIntensity: 0.5,
                ambientIntensity: 0.3,
                rainParticles: 1000,
                cloudOpacity: 1.0,
                cloudCount: 35
            },
            [WEATHER_TYPES.STORMY]: {
                skyColor: 0x4a5259,
                fogColor: 0x7a7a7a,
                fogDensity: 0.008,
                lightIntensity: 0.4,
                ambientIntensity: 0.2,
                rainParticles: 2000,
                cloudOpacity: 1.0,
                cloudCount: 40
            }
        };

        weatherData.push({
            date,
            dayNumber: i + 1,
            dateString: date.toLocaleDateString(),
            weather,
            temperature: Math.round((baseTemp + tempModifier + tempVariance) * 10) / 10,
            humidity: Math.round(baseHumidity + humidityVariance),
            growthFactor: Math.max(0, Math.min(1, growthFactor)),
            settings: settings[weather]
        });

        // Increment date by one day
        currentDate.setDate(currentDate.getDate() + 1);
    }

    return weatherData;
};

/**
 * Update plants in the scene based on growth stage
 * @param {Object} timelineDay - The current day's data
 * @param {Array} plants - Array of plant objects in the scene
 * @param {string} cropType - Type of crop
 */
export const updatePlantsForGrowthStage = (timelineDay, plants, cropType) => {
    if (!plants || plants.length === 0) return;

    const { growthFactor } = timelineDay;
    const baseHeight = PLANT_HEIGHTS[cropType] || 1.0;

    console.log(`Updating ${plants.length} plants for growth stage: ${timelineDay.growthStage}, percent: ${growthFactor}`);

    // Update each plant
    plants.forEach(plant => {
        // Skip non-plant objects
        if (!plant.userData || !plant.userData.isPlant) return;

        // Adjust plant height based on growth
        const targetHeight = baseHeight * growthFactor;


        // Ensure minimum scale to avoid invisible plants
        const plantScale = Math.max(0.2, growthFactor);

        // Set the scale to match the growth percentage
        plant.scale.set(
            plantScale,
            plantScale,
            plantScale
        );

        // For corn specifically, show/hide cobs based on growth stage
        if (cropType === 'corn') {
            // Find cobs (usually the 3rd and possibly 4th child in the corn plant)
            if (plant.children && plant.children.length > 2) {
                // Primary cob - show in reproductive and mature stages
                if (plant.children[2]) {
                    plant.children[2].visible = growthFactor >= 0.6;
                }

                // Secondary cob (if exists) - show only in mature stage
                if (plant.children[3]) {
                    plant.children[3].visible = growthFactor >= 0.85;
                }
            }
        }
    });
};

/**
 * Determine growth stage based on growth percentage
 * @param {number} growthFactor - Growth percentage (0-1)
 * @returns {string} Growth stage
 */
export const determineGrowthStage = (growthFactor) => {
    if (growthFactor < GROWTH_STAGES.SEEDLING) {
        return 'SEEDLING';
    } else if (growthFactor < GROWTH_STAGES.VEGETATIVE) {
        return 'VEGETATIVE';
    } else if (growthFactor < GROWTH_STAGES.REPRODUCTIVE) {
        return 'REPRODUCTIVE';
    } else {
        return 'MATURE';
    }
};

/**
 * Initialize timeline controls for the scene
 * @param {Object} timeline - Timeline data
 * @param {THREE.Scene} scene - The scene
 * @param {Object} sceneObjects - Object containing references to scene objects
 * @param {Function} setDayInfo - Function to update UI with day information
 * @returns {Object} Timeline controller
 */
export const initializeTimelineController = (timeline, scene, sceneObjects, setDayInfo) => {
    let currentDayIndex = 0;
    let paused = true;
    let autoAdvanceInterval = null;
    let rainSystem = null;

    // Initialize rain system
    rainSystem = new RainSystem(scene, 0);

    // Update the scene for a specific day
    const updateSceneForDay = (dayIndex) => {
        if (dayIndex < 0 || dayIndex >= timeline.days.length) return;

        const dayData = timeline.days[dayIndex];

        console.log('dayData')
        console.log(dayData)
        // Determine growth stage if not already set
        if (!dayData.growthStage) {
            dayData.growthStage = determineGrowthStage(dayData.growthFactor);
        }

        // Update plants
        if (sceneObjects.plants && sceneObjects.plants.length > 0) {
            updatePlantsForGrowthStage(dayData, sceneObjects.plants, timeline.type);
        }

        // Update weather effects
        applyWeatherToScene(
            dayData,
            scene,
            {
                directional: sceneObjects.directionalLight,
                ambient: sceneObjects.ambientLight
            },
            sceneObjects.clouds,
            rainSystem
        );

        // Update UI
        if (setDayInfo) {
            setDayInfo(dayData);
        }

        currentDayIndex = dayIndex;
    };

    // Set up auto-advance
    const setAutoAdvance = (enabled, intervalMs = 1000) => {
        clearInterval(autoAdvanceInterval);
        paused = !enabled;

        if (enabled) {
            autoAdvanceInterval = setInterval(() => {
                const nextDay = currentDayIndex + 1;
                if (nextDay < timeline.days.length) {
                    updateSceneForDay(nextDay);
                } else {
                    // Stop at the end
                    clearInterval(autoAdvanceInterval);
                    paused = true;
                }
            }, intervalMs);
        }
    };

    // Start with day 0
    updateSceneForDay(0);

    return {
        getCurrentDay: () => timeline.days[currentDayIndex],
        getCurrentDayIndex: () => currentDayIndex,
        getTotalDays: () => timeline.days.length,
        setDay: (dayIndex) => {
            updateSceneForDay(dayIndex);
        },
        nextDay: () => {
            if (currentDayIndex < timeline.days.length - 1) {
                updateSceneForDay(currentDayIndex + 1);
            }
        },
        prevDay: () => {
            if (currentDayIndex > 0) {
                updateSceneForDay(currentDayIndex - 1);
            }
        },
        isPaused: () => paused,
        play: () => setAutoAdvance(true),
        pause: () => setAutoAdvance(false),
        setSpeed: (speedFactor) => {
            const wasPlaying = !paused;
            if (wasPlaying) {
                setAutoAdvance(false);
                setAutoAdvance(true, 1000 / speedFactor);
            }
        },
    cleanup: () => {
            clearInterval(autoAdvanceInterval);
            if (rainSystem) {
                rainSystem.dispose();
            }
        }
    };
};
</file>

<file path="app/simulation/page.tsx">
'use client'

import React, { useState, useEffect, useRef } from 'react';
import { useSearchParams } from 'next/navigation';
import { setupScene } from '@/lib/simulation/sceneSetup';
import { createSkybox, createTerrain, createClouds, animateClouds } from '@/lib/environment';
import {
    createCropFieldSimulation,
    preloadSimulationModels,
    getModelLoadingProgress,
    areModelsLoaded
} from '@/lib/simulation';
import { createCropTimeline, initializeTimelineController } from '@/lib/simulation/timeline';
import { updatePlantsForGrowthStage } from '@/lib/simulation/plantGrowth';
import { convertGeoPolygonTo3D, parsePolygonFromUrl } from '@/lib/utils/coordinateUtils';
import SeasonTimelineControls from './components/SeasonTimelineControls';
import * as THREE from 'three';
import Image from 'next/image';

export default function SimulationPage() {
    // Get URL params
    const searchParams = useSearchParams();
    
    // Reference to the 3D container
    const mountRef = useRef(null);
    const fileInputRef = useRef(null);

    // Refs to hold three.js objects
    const sceneRef = useRef(null);
    const cameraRef = useRef(null);
    const controlsRef = useRef(null);
    const rendererRef = useRef(null);
    const cloudsRef = useRef([]);
    const simulationObjectsRef = useRef([]);
    const lightRefs = useRef({
        directional: null,
        ambient: null
    });

    // Current simulation state
    const [currentSimulation, setCurrentSimulation] = useState(null);
    const [errorMessage, setErrorMessage] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [showSidebar, setShowSidebar] = useState(false);

    // Model loading state
    const [modelLoadingProgress, setModelLoadingProgress] = useState(0);
    const [modelsLoaded, setModelsLoaded] = useState(false);

    // Timeline state
    const [timelineController, setTimelineController] = useState(null);
    const [dayInfo, setDayInfo] = useState(null);
    const [totalDays, setTotalDays] = useState(90); // Default 3 months

    // Location state
    const [location, setLocation] = useState(null);

    // Track model loading progress
    useEffect(() => {
        if (!modelsLoaded) {
            const checkProgress = () => {
                const progress = getModelLoadingProgress();
                setModelLoadingProgress(progress);

                const loaded = areModelsLoaded();
                setModelsLoaded(loaded);

                if (!loaded) {
                    // Continue checking until loaded
                    setTimeout(checkProgress, 500);
                }
            };

            checkProgress();

            // Start preloading models
            preloadSimulationModels().catch(console.error);
        }
    }, [modelsLoaded]);

    // Initialize the scene
    useEffect(() => {
        if (!mountRef.current) return;

        // Setup THREE.js scene
        const { scene, camera, renderer, controls, dispose } = setupScene(mountRef.current);

        // Store references
        sceneRef.current = scene;
        cameraRef.current = camera;
        rendererRef.current = renderer;
        controlsRef.current = controls;

        // Setup lights and store references
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(100, 200, 100);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        lightRefs.current = {
            directional: directionalLight,
            ambient: ambientLight
        };

        // Create environment
        createSkybox(scene);
        createTerrain(scene);

        // Create clouds
        cloudsRef.current = createClouds(scene, 20);

        // Animation loop
        const animate = () => {
            requestAnimationFrame(animate);

            // Animate clouds
            animateClouds(cloudsRef.current);

            // Update rain if active
            if (timelineController &&
                timelineController.getCurrentDay &&
                timelineController.getCurrentDay().settings &&
                timelineController.getCurrentDay().settings.rainSystem) {
                timelineController.getCurrentDay().settings.rainSystem.update();
            }

            // Update controls
            controls.update();

            // Render scene
            renderer.render(scene, camera);
        };

        // Start animation loop
        animate();

        // Load simulation based on URL params if available
        const latitude = parseFloat(searchParams.get('lat')) || -12.915559;
        const longitude = parseFloat(searchParams.get('lng')) || -55.314216;
        const hectares = parseFloat(searchParams.get('hectares')) || 350;
        const crop = searchParams.get('crop') || 'corn';
        const polygonParam = searchParams.get('polygon');
        
        // Parse the polygon from URL
        const geoPolygon = parsePolygonFromUrl(polygonParam);
        
        // Create the farm location object
        const farmLocation = {
            latitude,
            longitude,
            name: searchParams.get('locationName') || 'Mato Grosso (Brazil)'
        };
        
        // Convert the geo polygon to 3D coordinates
        const polygon3D = convertGeoPolygonTo3D(geoPolygon, farmLocation);
        
        // Create the simulation parameters
        const simParams = {
            type: crop,
            hectares: Math.min(hectares, 1000), // Cap at 1000 hectares for performance
            density: hectares > 100 ? 50 : hectares > 50 ? 75 : 100, // Adjust density based on farm size
            polygon: polygon3D,
            location: farmLocation,
            weatherSettings: {
                useRealWeather: true
            }
        };

        console.log("Creating simulation with parameters:", simParams);
        console.log("Using 3D polygon:", polygon3D);

        // This will trigger the simulation effect
        setCurrentSimulation(simParams);
        setLocation(farmLocation);

        // Cleanup on unmount
        return () => {
            // Clean up timeline controller if exists
            if (timelineController) {
                timelineController.cleanup();
            }

            dispose();

            // Clean up Three.js resources
            scene.traverse((object) => {
                if (object instanceof THREE.Mesh) {
                    object.geometry.dispose();
                    if (object.material.map) object.material.map.dispose();
                    object.material.dispose();
                }
            });
        };
    }, [searchParams]);

    // Clear existing simulation and start a new one when parameters change
    useEffect(() => {
        if (!currentSimulation || !sceneRef.current || !cameraRef.current || !controlsRef.current) return;

        setIsLoading(true);

        // Small delay to ensure all references are properly set up
        setTimeout(() => {
            try {
                // Remove all existing simulation objects
                simulationObjectsRef.current.forEach(object => {
                    sceneRef.current.remove(object);
                });
                simulationObjectsRef.current = [];

                // Clean up previous timeline controller
                if (timelineController) {
                    timelineController.cleanup();
                }

                // Create new simulation
                console.log("Creating simulation with params:", currentSimulation);
                const { success, objects, error } = createCropFieldSimulation(
                    currentSimulation,
                    sceneRef.current,
                    cameraRef.current,
                    controlsRef.current
                );

                if (success) {
                    console.log(`Created ${objects.length} simulation objects`);
                    simulationObjectsRef.current = objects;

                    // Separate plants from other objects for growth animation
                    const plants = objects.filter(obj => {
                        // Use isPlant flag set during creation
                        return obj.userData && obj.userData.isPlant === true;
                    });

                    console.log(`Identified ${plants.length} plant objects for growth animation`);

                    // Create timeline starting March 20th
                    const startDate = new Date('2025-03-20');
                    const timeline = createCropTimeline(
                        currentSimulation,
                        startDate,
                        totalDays
                    );

                    // Initialize timeline controller with our custom plant growth logic
                    const controller = initializeTimelineController(
                        timeline,
                        sceneRef.current,
                        {
                            directionalLight: lightRefs.current.directional,
                            ambientLight: lightRefs.current.ambient,
                            clouds: cloudsRef.current,
                            plants: plants,
                            updatePlantsFunction: updatePlantsForGrowthStage // Use our improved function
                        },
                        setDayInfo
                    );

                    setTimelineController(controller);
                    setErrorMessage('');
                } else {
                    console.error('Simulation error:', error);
                    setErrorMessage(`Error creating simulation: ${error}`);
                }
            } catch (err) {
                console.error('Unexpected error in simulation creation:', err);
                setErrorMessage(`Unexpected error: ${err.message}`);
            } finally {
                setIsLoading(false);
            }
        }, 500);
    }, [currentSimulation]);

    return (
        <div className="flex flex-col">

            {/* Header Bar */}
            <div className="bg-green-500 py-3 px-4">
                <div className="container mx-auto max-w-5xl flex justify-between items-center">
                    <div className="flex items-center">
                        <span className="text-white font-bold text-xl">Farm Bio-Boost</span>
                        <span className="text-white ml-2">Simulator</span>
                    </div>
                    {/* Powered by Syngenta */}
                    <div className="flex items-center text-sm text-gray-600">
                        <span className="mr-2">Powered by</span>
                        <Image
                            src="/images/syngenta-logo.png"
                            alt="Syngenta"
                            width={100}
                            height={30}
                            className="w-auto"
                        />
                    </div>
                </div>
            </div>

            {/* Timeline Controls */}
            {timelineController && (
                <SeasonTimelineControls
                    controller={timelineController}
                    totalDays={totalDays}
                    location={location}
                />
            )}

            {/* Main content */}
            <div className="flex-1 relative">
                {/* 3D View */}
                <div className="w-full h-full">
                    <div ref={mountRef} className="w-full h-screen" />
                </div>

                {/* Model Loading Progress */}
                {!modelsLoaded && modelLoadingProgress > 0 && (
                    <div className="absolute top-4 left-1/2 transform -translate-x-1/2 p-4 bg-white bg-opacity-90 rounded-lg shadow-lg z-20">
                        <div className="text-center">
                            <h3 className="font-medium mb-2">Loading 3D Models</h3>
                            <div className="w-64 h-2 bg-gray-200 rounded-full overflow-hidden">
                                <div
                                    className="h-full bg-green-500 transition-all duration-300"
                                    style={{ width: `${modelLoadingProgress * 100}%` }}
                                ></div>
                            </div>
                            <p className="mt-1 text-sm text-gray-600">
                                {Math.round(modelLoadingProgress * 100)}% Complete
                            </p>
                        </div>
                    </div>
                )}

                {/* Error message */}
                {errorMessage && (
                    <div className="absolute top-20 right-4 p-3 bg-red-600 text-white rounded shadow-lg max-w-md z-20">
                        <strong>Error:</strong> {errorMessage}
                        <button
                            className="ml-3 text-white font-bold"
                            onClick={() => setErrorMessage('')}
                        >
                            ×
                        </button>
                    </div>
                )}

                {/* Loading indicator */}
                {isLoading && (
                    <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-30 z-30">
                        <div className="p-4 bg-white rounded shadow-lg">
                            <p className="text-lg font-bold">Loading simulation...</p>
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
}
</file>

<file path="app/page.tsx">
"use client";

import React, { useState } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/Button';
import HeroSection from '@/components/ui/HeroSection';
import FarmSetupWizard from '@/components/farm/FarmSetupWizard';
import Image from 'next/image';

export default function HomePage() {
    const [showWizard, setShowWizard] = useState(false);

    const handleGetStarted = () => {
        setShowWizard(true);
        // Smooth scroll to the wizard section
        setTimeout(() => {
            document.getElementById('setup-wizard')?.scrollIntoView({
                behavior: 'smooth'
            });
        }, 100);
    };

    return (
        <div className="relative min-h-screen">
            {/* Persistent Background Container */}
            <div className="fixed inset-0 z-0">
                <Image
                    src="/images/farm-hero.png"
                    alt="Sustainable farming landscape"
                    fill
                    priority
                    className="object-cover"
                />
                {/* Gradient overlay for text readability */}
                <div className="absolute inset-0 bg-black/40"></div>
            </div>

            {/* Header Bar */}
            <div className="fixed top-0 left-0 right-0 z-10 bg-green-500 py-3 px-4">
                <div className="container mx-auto max-w-5xl flex justify-between items-center">
                    <div className="flex items-center">
                        <span className="text-white font-bold text-xl">Farm Bio-Boost</span>
                        <span className="text-white ml-2">Simulator</span>
                    </div>
                    {/* Powered by Syngenta */}
                    <div className="flex items-center text-sm text-gray-600">
                        <span className="mr-2">Powered by</span>
                        <Image
                            src="/images/syngenta-logo.png"
                            alt="Syngenta"
                            width={100}
                            height={30}
                            className="w-auto"
                        />
                    </div>
                </div>
            </div>

            {/* Content Container */}
            <div className="relative z-5 pt-16 min-h-screen">
                <div className="container mx-auto max-w-5xl">
                    {/* Show the hero section if we're not in wizard mode */}
                    {!showWizard && (
                        <div className="flex items-center justify-center min-h-[calc(100vh-4rem)]">
                            <HeroSection onGetStarted={handleGetStarted} />
                        </div>
                    )}

                    {/* Show the wizard when the user clicks "Get Started" */}
                    {showWizard && (
                        <div id="setup-wizard" className="pt-4 pb-12">
                            <FarmSetupWizard />

                            <div className="text-center mt-8">
                                <button
                                    onClick={() => setShowWizard(false)}
                                    className="text-white hover:text-gray-200 text-sm underline"
                                >
                                    Return to home page
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
}
</file>

</files>
