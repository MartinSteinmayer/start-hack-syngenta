This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  api/
    drought-risk/
      route.ts
    environmental-data/
      route.ts
    growth-rate/
      route.ts
    products/
      route.ts
    satellite-proxy/
      route.ts
  simulation/
    components/
      LocationInput.tsx
      ProductsPopup.tsx
      SeasonTimelineControls.tsx
      WeatherInfo.tsx
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  farm/
    CropSelector.tsx
    CropStressAnalysis.tsx
    FarmReviewStep.tsx
    FarmSetupWizard.tsx
    FarmShapeStep.tsx
    FarmSizeStep.tsx
    LocationInputWithMap.tsx
    LocationPicker.tsx
    MapComponent.tsx
  styles/
    Navbar.css
  ui/
    Button.tsx
    Card.tsx
    HeroSection.tsx
    Navbar.tsx
lib/
  crops/
    constants.ts
    corn.ts
    cotton.ts
    index.ts
    rice.ts
    soybean.ts
    wheat.ts
  data/
    products.json
  environment/
    clouds.ts
    index.ts
    skybox.ts
    terrain.ts
  hooks/
    useFarmData.ts
    useProducts.ts
  services/
    farmEnvironmentService.ts
    modelLoader.ts
  simulation/
    cameraUtils.ts
    fieldUtils.ts
    index.ts
    plantGrowth.ts
    sceneSetup.ts
    timeline.ts
    timelineControler.ts
  utils/
    coordinateUtils.ts
  weather/
    index.ts
    weatherService.tsx
public/
  data/
    markdown/
      nue.md
      product_crop_fit.md
      stress_buster.md
      weather_based_algorithms.md
      yield_booster.md
    crop_gdd_data.csv
    crop_optimal_data.csv
    mock-environment.json
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
types/
  farm.ts
  products.ts
  simulation.ts
.gitignore
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/api/drought-risk/route.ts">
import { NextRequest, NextResponse } from 'next/server';
⋮----
interface DroughtRiskRequest {
    rainfall: number;
    evaporation: number;
    soilMoisture: number;
    temperature: number;
}
⋮----
interface DroughtRiskResponse {
    success: boolean;
    data: {
        droughtIndex: number;
        riskLevel: string;
        recommendation: string;
        inputs: {
            rainfall: number;
            evaporation: number;
            soilMoisture: number;
            temperature: number;
        };
    };
    error?: string;
}
⋮----
export async function POST(request: NextRequest)
</file>

<file path="app/api/satellite-proxy/route.ts">
import { NextRequest, NextResponse } from 'next/server';
⋮----
/**
 * Satellite image proxy API route
 * This proxies requests to the Python satellite API to avoid CORS issues
 */
export async function POST(request: NextRequest)
⋮----
// Get parameters from the request body
⋮----
// Validate required parameters
⋮----
// Construct the API endpoint URL with query parameters
⋮----
// Make the request to the Python API
⋮----
// We're in node.js context here, so CORS doesn't apply
⋮----
// Get the content type to forward it correctly
⋮----
// Get the image data as an array buffer
⋮----
// Return the image with appropriate headers
⋮----
/**
 * Handle OPTIONS requests for CORS preflight
 */
export async function OPTIONS()
</file>

<file path="app/simulation/components/LocationInput.tsx">
// components/LocationInput.tsx
⋮----
import React, { useState, useEffect } from 'react';
⋮----
interface LocationInputProps {
    onLocationChange: (latitude: number, longitude: number, locationName: string) => void;
    disabled?: boolean;
}
⋮----
interface GeocodeResult {
    name: string;
    country: string;
    state?: string;
    lat: number;
    lon: number;
}
⋮----
// Optional: Get user's current location when component mounts
⋮----
// Reverse geocode to get location name
⋮----
// Set default location (e.g., Central USA)
⋮----
// Geolocation not available, set default
⋮----
// Reverse geocode to get location name from coordinates
const reverseGeocode = async (lat: number, lon: number) =>
⋮----
// Search for location by name
const searchLocation = async () =>
⋮----
// Handle location selection from search results
const selectLocation = (result: GeocodeResult) =>
⋮----
// Notify parent component
⋮----
// Handle manual entry of coordinates
const handleManualCoordinates = () =>
⋮----
{/* Search by place name */}
⋮----
onChange=
⋮----
{/* Search results dropdown */}
⋮----
{/* Or enter coordinates manually */}
⋮----
{/* Display current location */}
</file>

<file path="app/simulation/components/ProductsPopup.tsx">
import React, { useState } from 'react';
import productsData from '@/lib/data/products.json';
⋮----
interface ProductsPopupProps {
    isOpen: boolean;
    onClose: () => void;
    onSelectProduct: (product: any) => void;
}
⋮----
interface ProductTabProps {
    product: any;
    activeTab: string;
}
⋮----
// Get products from the imported data
⋮----
// Function to get appropriate icon for each product category
const getCategoryIcon = (category: string) =>
⋮----
// Function to format crop-specific application rates
⋮----
switch (activeTab)
⋮----

⋮----
{/* Transcriptomics */}
⋮----
{/* Phenomics */}
⋮----
{/* Metabolomics */}
⋮----
{/* Trial Results */}
⋮----
{/* Crop Performance */}
⋮----
<h6 className="text-sm font-medium capitalize mb-1">
⋮----
{/* Stress Conditions */}
⋮----
{/* Trial Notes */}
⋮----
{/* Additional Trials Info */}
⋮----
{/* Backdrop with blur effect */}
⋮----
{/* Popup content */}
⋮----
{/* Product Header - Always visible */}
⋮----
{/* Short description visible when collapsed */}
⋮----
{/* Expanded Content */}
⋮----
{/* Tabs */}
⋮----
onClick={() => setActiveTab('overview')}
                                            >
                                                Overview
                                            </button>
                                            <button
                                                className={`py-3 border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === 'application'
                                                        ? 'border-green-500 text-green-600'
                                                        : 'border-transparent text-gray-500 hover:text-gray-700'
                                                    }`}
                                                onClick={() => setActiveTab('application')}
                                            >
                                                Application
                                            </button>
                                            <button
                                                className={`py-3 border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === 'evidence'
                                                        ? 'border-green-500 text-green-600'
                                                        : 'border-transparent text-gray-500 hover:text-gray-700'
                                                    }`}
                                                onClick={() => setActiveTab('evidence')}
                                            >
                                                Scientific Evidence
                                            </button>
                                            <button
                                                className={`py-3 border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === 'results'
                                                        ? 'border-green-500 text-green-600'
                                                        : 'border-transparent text-gray-500 hover:text-gray-700'
                                                    }`}
                                                onClick={() => setActiveTab('results')}
                                            >
                                                Field Results
                                            </button>
                                        </div>
                                    </div>

                                    {/* Tab Content */}
                                    <div className="p-5">
                                        {renderProductDetailTabs({ product, activeTab })}
                                    </div>

                                    {/* Action Button */}
                                    <div className="p-5 bg-gray-50 flex justify-end">
                                        <button
                                            className="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition-colors"
onClick=
⋮----
onClick={() => setActiveTab('application')}
                                            >
                                                Application
                                            </button>
                                            <button
                                                className={`py-3 border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === 'evidence'
                                                        ? 'border-green-500 text-green-600'
                                                        : 'border-transparent text-gray-500 hover:text-gray-700'
                                                    }`}
                                                onClick={() => setActiveTab('evidence')}
                                            >
                                                Scientific Evidence
                                            </button>
                                            <button
                                                className={`py-3 border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === 'results'
                                                        ? 'border-green-500 text-green-600'
                                                        : 'border-transparent text-gray-500 hover:text-gray-700'
                                                    }`}
                                                onClick={() => setActiveTab('results')}
                                            >
                                                Field Results
                                            </button>
                                        </div>
                                    </div>

                                    {/* Tab Content */}
                                    <div className="p-5">
                                        {renderProductDetailTabs({ product, activeTab })}
                                    </div>

                                    {/* Action Button */}
                                    <div className="p-5 bg-gray-50 flex justify-end">
                                        <button
                                            className="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition-colors"
onClick=
⋮----
onClick={() => setActiveTab('evidence')}
                                            >
                                                Scientific Evidence
                                            </button>
                                            <button
                                                className={`py-3 border-b-2 font-medium text-sm whitespace-nowrap ${activeTab === 'results'
                                                        ? 'border-green-500 text-green-600'
                                                        : 'border-transparent text-gray-500 hover:text-gray-700'
                                                    }`}
                                                onClick={() => setActiveTab('results')}
                                            >
                                                Field Results
                                            </button>
                                        </div>
                                    </div>

                                    {/* Tab Content */}
                                    <div className="p-5">
                                        {renderProductDetailTabs({ product, activeTab })}
                                    </div>

                                    {/* Action Button */}
                                    <div className="p-5 bg-gray-50 flex justify-end">
                                        <button
                                            className="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition-colors"
onClick=
⋮----
onClick={() => setActiveTab('results')}
                                            >
                                                Field Results
                                            </button>
                                        </div>
                                    </div>

                                    {/* Tab Content */}
                                    <div className="p-5">
                                        {renderProductDetailTabs({ product, activeTab })}
                                    </div>

                                    {/* Action Button */}
                                    <div className="p-5 bg-gray-50 flex justify-end">
                                        <button
                                            className="bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg transition-colors"
onClick=
⋮----
{/* Tab Content */}
⋮----
{/* Action Button */}
</file>

<file path="app/simulation/components/WeatherInfo.tsx">
// components/WeatherInfo.tsx
⋮----
import React from 'react';
⋮----
interface WeatherInfoProps {
    dayInfo: {
        date: Date;
        dateString: string;
        dayNumber: number;
        temperature: number;
        humidity: number;
        weather: string;
        growthPercent: number;
        growthStage: string;
    } | null;
    location?: {
        name: string;
        latitude: number;
        longitude: number;
    };
}
⋮----
const WeatherInfo: React.FC<WeatherInfoProps> = (
⋮----
// Helper function to get weather icon
const getWeatherIcon = (weather: string) =>
⋮----
// Helper function to get growth stage icon
const getGrowthStageIcon = (stage: string) =>
⋮----
// Helper function to get formatted weather name
const getWeatherName = (weather: string) =>
⋮----
// No data available
⋮----
{/* Location information */}
⋮----
{/* Weather information */}
⋮----
{/* Date information */}
</file>

<file path="components/farm/CropStressAnalysis.tsx">
import React, { useState, useEffect } from 'react';
import { Card } from '@/components/ui/Card';
import { Button } from '@/components/ui/Button';
import { Crop, GeoLocation } from '@/types/farm';
import { analyzeCropSuitability } from '@/lib/services/farmEnvironmentService';
⋮----
interface CropStressAnalysisProps {
    crops: Crop[];
    location: GeoLocation;
    className?: string;
    onSelectProduct?: (cropId: string, stressType: string) => void;
}
⋮----
interface StressResult {
    cropId: string;
    cropName: string;
    cropType: string;
    temperature: { stress: number };
    water: { stress: number };
    soil: { stress: number };
    overall: { stress: number };
    loading: boolean;
    error: string | null;
}
⋮----
async function analyzeStress()
⋮----
// Initialize stress results with loading state
⋮----
// Fetch environmental data
⋮----
// Fetch soil data
⋮----
// Combine environmental data
⋮----
// Analyze each crop
⋮----
// Helper to render stress indicator
⋮----
// Helper function to get appropriate recommendation based on stress type
⋮----
{/* Overall Stress */}
⋮----

⋮----
{/* Detailed Stress Factors */}
⋮----
{/* Temperature Stress */}
⋮----
{/* Water Stress */}
⋮----
{/* Soil Stress */}
</file>

<file path="components/farm/FarmSizeStep.tsx">
// components/farm/FarmSizeStep.tsx
⋮----
import React, { useState, useEffect } from 'react';
import Image from 'next/image';
import MapComponent from './MapComponent';
⋮----
interface FarmSizeStepProps {
  farmLocation: { latitude: number; longitude: number; name: string };
  farmSize: number;
  onFarmSizeChange: (size: number) => void;
  onContinue: () => void;
  onBack: () => void;
}
⋮----
// Update map when location or size changes
⋮----
// Generate map preview using OpenStreetMap
const updateMapPreview = () =>
⋮----
// Calculate radius in km based on hectares
// Area = π × r²
// 1 hectare = 0.01 km²
// r = √(area ÷ π)
⋮----
// Use OpenStreetMap static map API
// We'll use the OpenStreetMap Static Maps API via Thunderforest
// You'll need to create an account and get an API key at https://www.thunderforest.com/
// For demo purposes, we'll use a placeholder API key - replace with your own
⋮----
// Calculate zoom level based on farm size
// This is an approximation - smaller hectares need higher zoom
⋮----
// Create the map URL
⋮----
// For development without an API key, fall back to a screenshot or embedded iframe
⋮----
// Use a fallback map approach
⋮----
// Format hectares for display
const formatHectares = (value: number): string =>
⋮----
onChange=
⋮----
{/* Map preview */}
⋮----
// Using our MapComponent
</file>

<file path="components/styles/Navbar.css">
.navbar-link {
⋮----
.navbar-link::after {
⋮----
background-color: rgba(16, 185, 129, 0.7); /* Green color for Farm Bio-Boost theme */
⋮----
.navbar-link:hover {
⋮----
.navbar-link:hover::after {
⋮----
/* Mobile menu styling */
.navbar-menu {
⋮----
/* For screens smaller than 768px (md breakpoint in Tailwind) */
⋮----
.hamburger-button {
⋮----
/* For screens larger than 768px */
⋮----
/* Add a backdrop for the mobile menu when open */
.navbar-menu-backdrop {
</file>

<file path="components/ui/Button.tsx">
import React from 'react';
⋮----
type ButtonVariant = 'primary' | 'secondary' | 'outline' | 'destructive';
type ButtonSize = 'sm' | 'md' | 'lg';
⋮----
interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
    variant?: ButtonVariant;
    size?: ButtonSize;
    children: React.ReactNode;
}
⋮----
export const Button: React.FC<ButtonProps> = ({
    variant = 'primary',
    size = 'md',
    children,
    className = '',
    ...props
}) =>
⋮----
// Variant styles
⋮----
// Size styles
</file>

<file path="components/ui/Card.tsx">
import React from 'react';
⋮----
interface CardProps {
    children: React.ReactNode;
    className?: string;
}
⋮----
export const Card: React.FC<CardProps> = (
</file>

<file path="components/ui/Navbar.tsx">
import Link from 'next/link';
import Image from 'next/image';
⋮----
{/* Project Name */}
⋮----
{/* Powered by Syngenta */}
</file>

<file path="lib/crops/corn.ts">
const createCornPlant = (plantHeight) =>
⋮----
// Corn stalk
⋮----
// Corn leaves
⋮----
// Corn cob
⋮----
// Optional second cob on larger plants
</file>

<file path="lib/crops/cotton.ts">
const createCottonPlant = (plantHeight) =>
⋮----
// Cotton stem
⋮----
// Cotton leaves
⋮----
// Cotton bolls
</file>

<file path="lib/crops/rice.ts">
const createRicePlant = (plantHeight) =>
⋮----
// Rice stem
⋮----
// Rice grains
⋮----
// Rice leaves
</file>

<file path="lib/crops/soybean.ts">
const createSoybeanPlant = (plantHeight) =>
⋮----
// Soybean stem
⋮----
// Soybean leaves
⋮----
// Soybean pods
</file>

<file path="lib/crops/wheat.ts">
const createWheatPlant = (plantHeight) =>
⋮----
// Wheat stalk
⋮----
// Wheat head
</file>

<file path="lib/data/products.json">
{
  "products": [
    {
      "name": "Stress Buster",
      "category": "Biostimulant",
      "type": "Anti-stress and growth activator",
      "application_method": "Foliar application",
      "timing": "As soon as a stress event is predicted",
      "composition": "Complex of selected vegetal extracts derived from selected plants",
      "description": "When applied in case of abiotic stresses, its synergistic action of different active ingredients allows plants to tolerate and quickly overcome the stress, preserving yield. Applied regularly in normal condition, optimizes plant growth.",
      "directions_for_use": {
        "fruit_crops": {
          "dose": "2-3 l/ha",
          "period": "pre-flowering, post-setting, fruit development and in all cases of plant growth stop"
        },
        "vegetable": {
          "dose": "2-3 l/ha",
          "period": "in open field and greenhouses after transplant every 10-15 days"
        },
        "row_crops": {
          "dose": "2-3 l/ha (150-250 mL/hL)",
          "period": "1-2 applications during growth cycle in case of abiotic stresses"
        }
      },
      "scientific_evidence": {
        "transcriptomics": {
          "non_stressed_plants": "Treated plants show activation of >100 genes (FC >3) vs. Control, mainly involved in: i) abiotic stress response/tolerance (\"hardening effect\" against abiotic stress), ii) activation of plant metabolism (thus better growth)",
          "drought_stressed_plants": "Pre-treated with stress buster show a decreased expression of stress-related marker genes during stress conditions, showing a lower perception of the stress itself (\"acclimated plants\"; Petrozza et al., 2014)"
        },
        "phenomics": {
          "improvements": [
            "Digital Biovolume/Biomass",
            "Health Index (less Stress Index)",
            "Water content",
            "Other indexes: Green/Yellow Index, etc"
          ]
        },
        "metabolomics": "METABOLOMICS has also been used recently, to highlight the action of Stress Buster in stress conditions. It has been observed that the product is capable of modulating specific classes of metabolites, connected to the response to abiotic stress."
      },
      "field_trial_results": {
        "crop_performance": {
          "row_crops": {
            "yield_increase": "+ 0,30 t/ha",
            "roi": "3,9:1"
          },
          "vegetable": {
            "yield_increase": "+ 2,3 t/ha",
            "roi": "11,6:1"
          },
          "fruit_crops": {
            "yield_increase": "+ 1,2 t/ha",
            "roi": "10,5:1"
          }
        },
        "stress_conditions": {
          "cold": {
            "evidences": 10,
            "win_rate": "70%",
            "yield_increase": "+5%"
          },
          "heat": {
            "evidences": 26,
            "win_rate": "76,9%",
            "yield_increase": "+8,2%"
          },
          "drought": {
            "evidences": 433,
            "win_rate": "70,7%",
            "yield_increase": "+5,1%"
          }
        },
        "notes": "850 selected trials for the summary, of which 68% were carried out under abiotic stress conditions."
      }
    },
    {
      "name": "Yield Booster",
      "category": "Biostimulant",
      "type": "Crop productivity enhancer",
      "application_method": "Foliar application",
      "timing": "Decision taken before the growing season based on historical data and upcoming season prediction",
      "description": "In our portfolio we have a biostimulant for row crops able to ensure highest productivity and return for farmers. This solution is able to increase plant productivity through better transport of sugars and nutrients, promotion of cell division, and fatty acids biosynthesis and transport.",
      "value_proposition": "Highest crop productivity, Highest return for farmers",
      "directions_for_use": {
        "wheat": {
          "dose": "2 l/ha",
          "period": "1 application at flag leaf growth stage"
        },
        "soybean": {
          "dose": "1-2 l/ha",
          "period": "2 applications: the 1st at Vn/Ri growth stage, the 2nd at R3/R5 growth stage"
        },
        "corn": {
          "dose": "2 l/ha",
          "period": "1 application at V4-V6 growth stage"
        },
        "rice": {
          "dose": "1-2 l/ha",
          "period": "2 applications: the 1st at the beginning of booting, the 2nd at heading growth stage"
        },
        "cotton": {
          "dose": "2 l/ha",
          "period": "2 applications: the 1st before squares appear and 2nd after 3-4 weeks"
        },
        "sunflower": {
          "dose": "2 l/ha",
          "period": "1 application at 4-6 leaf growth stage"
        }
      },
      "scientific_evidence": {
        "transcriptomics": {
          "description": "Next Generation Sequencing (NGS) experiment on corn and soybean: plants treated with Yield Booster showed activation of genes involved in:",
          "activities": [
            "Transport of sugars and nutrients: Zn and Fe uptake and transport, ammoniun and nitrogen assimilation, phosphate homeostasis (uptake, sensing), phloem loading",
            "Promotion of cell division: the coordination of specific hormonal processes, including the establishment of an optimal auxin/cytokinin balance",
            "Fatty acids biosynthesis/transport: lipid transport, photosynthesis"
          ]
        },
        "phenomics": {
          "description": "Experiments on corn and soybean, where Yield Booster improved:",
          "improvements": [
            "Digital Biovolume and height",
            "Plant compactness",
            "Green Index"
          ]
        }
      },
      "field_trial_results": {
        "crop_performance": {
          "bean": {"yield_increase_percentage": 12},
          "cotton": {"yield_increase_percentage": 11},
          "sunflower": {"yield_increase_percentage": 10},
          "rice": {"yield_increase_percentage": 9},
          "soft_wheat": {"yield_increase_percentage": 6},
          "corn": {"yield_increase_percentage": 5, "yield_increase": "+0,64 t/ha", "roi": "7:1"},
          "soybean": {"yield_increase_percentage": 4, "yield_increase": "+0,27 t/ha", "roi": "5:1"},
          "oilseed_rape": {"yield_increase_percentage": 4},
          "barley": {"yield_increase_percentage": 2},
          "wheat": {"yield_increase": "+0,30 t/ha", "roi": "5:1"},
          "rice_detailed": {"yield_increase": "+0,66 t/ha", "roi": "14:1"}
        },
        "trials": {
          "rice_trials": "2017-2022 Rice Trials showed 7.4% Average Yield Increase worldwide",
          "corn_trials": "64 corn trials in 2022 with YieldB application resulted in positive yield response in 83% of trials with an average bu/A increase of 6.8 Bu/A"
        }
      }
    },
    {
      "name": "Nutrient Use Efficiency (NUE) Product",
      "category": "Biofertilizer",
      "application_method": "Seed treatment and foliar application",
      "composition": "Based on 3 strains of endophytic bacteria (Sphingobium salicis, Pseudomonas siliginis, Curtobacterium salicis)",
      "description": "New innovative product concept with dual effect on N and P use efficiency and mineral nutrient uptakes",
      "functionality": {
        "nitrogen_sources": [
          "Air – N2",
          "Soil – NO, NO3, NH3/NH4",
          "Soil – Organic, C-NP"
        ],
        "phosphate_management": [
          "Enhanced P-solubilization",
          "P and K uptake root to shoot transport",
          "Organic acid"
        ],
        "nutrient_availability": [
          "Siderophore production solubilization of micronutrients Fe, Mg, Cu, Zn, Mn, Mo"
        ]
      },
      "application_rates": {
        "foliar_application": {
          "wheat": "10-50 g/ha",
          "barley": "10-50 g/ha",
          "corn": "10-50 g/ha",
          "osr": "10-50 g/ha",
          "rice": "10-50 g/ha"
        },
        "seed_treatment": {
          "wheat": "10-50 g/T seeds",
          "barley": "10-50 g/T seeds",
          "corn": "50-150 g/T seeds",
          "osr": "100-250 g/T seeds",
          "sugarbeet": "500-1050 g/T seeds"
        }
      },
      "scientific_evidence": {
        "trials": "38 trials in corn (US, EU) 2023, 40-unit N reduction scenario - FOLIAR",
        "results": {
          "win_rate": "68% (positive response)",
          "yield_increase_percentage": "2.6%",
          "yield_increase_kg_ha": "250 kg/ha"
        }
      },
      "key_benefits": [
        "Product acts as a \"back up generator\" for plants when nutrients become limiting",
        "Versatile and easy to apply: seed treatment or foliar application",
        "Up to 2 years of shelf life",
        "High compatibility with tank mixtures(F, I, H, F)",
        "Trial data in key field crops"
      ],
      "notes": "Liquid formulation ≈ Solid formulation (1.2 L/ha = 30 g/ha). 10% difference in N regime is not assumed to generate differences within the system."
    }
  ]
}
</file>

<file path="lib/environment/clouds.ts">
/**
 * Creates cloud objects in the scene
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {number} count - Number of clouds to create
 * @returns {Array} - Array of cloud objects
 */
export const createClouds = (scene, count = 20) =>
⋮----
// Random position and size
⋮----
// Create cloud parts
⋮----
// Position cloud parts
⋮----
// Set cloud position and speed
⋮----
// Add cloud to scene and collection
⋮----
/**
 * Updates cloud positions for animation
 * @param {Array} clouds - Array of cloud objects
 */
export const animateClouds = (clouds) =>
</file>

<file path="lib/environment/index.ts">
import { createSkybox } from './skybox';
import { createTerrain, createFieldSoil, createFieldBoundary } from './terrain';
import { createClouds, animateClouds } from './clouds';
</file>

<file path="lib/environment/skybox.ts">
/**
 * Creates skybox with distant horizons
 * @param {THREE.Scene} scene - The THREE.js scene
 */
export const createSkybox = (scene) =>
⋮----
// Sky dome
⋮----
// Distant horizon
⋮----
// Create canvas for horizon texture
⋮----
// Draw gradient sky
⋮----
// Draw green hills
⋮----
// Draw random hills
⋮----
// Create texture from canvas
</file>

<file path="lib/hooks/useFarmData.ts">
import { useState, useEffect } from 'react';
import { FarmData, Crop, GeoLocation } from '@/types/farm';
⋮----
// Default India (Karnataka) location
⋮----
interface UseFarmDataReturn {
    farmData: FarmData;
    isLoading: boolean;
    updateFarmData: (data: Partial<FarmData>) => void;
    updateFarmLocation: (location: GeoLocation) => void;
    updateFarmCrops: (crops: Crop[]) => void;
    updateFarmName: (name: string) => void;
    updateFarmSize: (acreage: number) => void;
    saveFarm: () => void;
    resetFarm: () => void;
    error: string | null;
}
⋮----
export function useFarmData(): UseFarmDataReturn
⋮----
// Load saved farm data on initial mount
⋮----
const loadFarmData = () =>
⋮----
// Update entire farm data object
const updateFarmData = (data: Partial<FarmData>) =>
⋮----
// Update farm location
const updateFarmLocation = (location: GeoLocation) =>
⋮----
// Update farm crops
const updateFarmCrops = (crops: Crop[]) =>
⋮----
// Validate crops
⋮----
// Update farm name
const updateFarmName = (name: string) =>
⋮----
// Update farm size/acreage
const updateFarmSize = (acreage: number) =>
⋮----
// Validate that new size is sufficient for existing crops
⋮----
// Save farm data to localStorage
const saveFarm = () =>
⋮----
// Reset farm to default
const resetFarm = () =>
</file>

<file path="lib/hooks/useProducts.ts">
import { useState, useEffect } from 'react';
import { Product } from '@/types/products';
⋮----
interface UseProductsReturn {
    products: Product[];
    isLoading: boolean;
    error: string | null;
    filterProductsByCategory: (category: string | null) => Product[];
    filterProductsByCrop: (cropType: string | null) => Product[];
    getProductById: (id: string) => Product | undefined;
}
⋮----
export function useProducts(): UseProductsReturn
⋮----
const fetchProducts = async () =>
⋮----
// Filter products by category
const filterProductsByCategory = (category: string | null): Product[] =>
⋮----
// Filter products by crop compatibility
const filterProductsByCrop = (cropType: string | null): Product[] =>
⋮----
// Get a specific product by ID
const getProductById = (id: string): Product | undefined =>
</file>

<file path="lib/services/farmEnvironmentService.ts">
import { FarmData, Crop, GeoLocation } from '@/types/farm';
⋮----
interface EnvironmentalData {
    forecast?: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: {
        texture: string;
        properties: {
            bulkDensity: number;
            organicMatter: number;
            ph: number;
            waterHoldingCapacity: number;
            cationExchangeCapacity: number;
        };
    };
    stress_factors?: {
        current: {
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        };
        forecast: Array<{
            date: string;
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        }>;
    };
}
⋮----
interface CropRequirements {
    temperature: {
        min: number;
        optimal: number;
        max: number;
    };
    water: {
        min: number;    // mm/day
        optimal: number;
        max: number;
    };
    soil: {
        ph: {
            min: number;
            optimal: number;
            max: number;
        };
        preferredTextures: string[];
    };
}
⋮----
min: number;    // mm/day
⋮----
// Crop requirements database (simplified)
⋮----
/**
 * Fetches environmental data for a farm location
 */
export async function fetchEnvironmentalData(location: GeoLocation): Promise<EnvironmentalData>
⋮----
// Calculate dates for API query
⋮----
// Fetch forecast data
⋮----
// Fetch soil data
⋮----
// Combine the data
⋮----
/**
 * Analyzes environmental conditions for a specific crop
 */
export function analyzeCropSuitability(crop: Crop, environmentalData: EnvironmentalData)
⋮----
// Temperature analysis
⋮----
// Calculate temperature suitability (0-1 scale)
⋮----
// Calculate temperature stress
⋮----
tempStress = (min - avgTemp) / min * 0.5; // Cold stress
⋮----
tempStress = (avgTemp - max) / max * 0.5; // Heat stress
⋮----
// Water/precipitation analysis
⋮----
// Calculate water suitability (0-1 scale)
⋮----
// Calculate water stress
⋮----
waterStress = (min - precip) / min; // Drought stress
⋮----
waterStress = (precip - max * 1.5) / (max * 1.5); // Excess water stress
⋮----
// Soil analysis
⋮----
// Calculate pH suitability
⋮----
// Calculate texture suitability
⋮----
// Calculate overall suitability and stress
⋮----
/**
 * Generates crop yield estimations based on environmental factors
 */
export function estimateCropYield(crop: Crop, environmentalData: EnvironmentalData)
⋮----
// Base yield potential per acre for each crop (tons)
⋮----
// Calculate estimated yield
⋮----
// Calculate potential improvement with bio-products
⋮----
/**
 * Analyzes a farm's environmental conditions and crop suitability
 */
export async function analyzeFarm(farmData: FarmData)
⋮----
// Fetch environmental data for farm location
⋮----
// Analyze each crop
⋮----
// Calculate farm-wide metrics
</file>

<file path="lib/services/modelLoader.ts">
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
⋮----
// Cache for already loaded models to avoid duplicate loading
⋮----
// Loading manager to track overall loading progress
⋮----
// Loading progress callback handlers
⋮----
// Configure loading manager
⋮----
/**
 * Set callbacks for loading progress and completion
 */
export const setLoadingCallbacks = (
  onProgress: (progress: number) => void,
  onComplete: () => void
) =>
⋮----
/**
 * Load a GLB model and return a clone of it
 * @param {string} path - Path to the GLB file
 * @returns {Promise<THREE.Group>} - Promise that resolves to the loaded model
 */
export const loadModel = async (path: string): Promise<THREE.Group> =>
⋮----
// Check if model is already in cache
⋮----
// Clone the cached model to avoid modifying the original
⋮----
// Load the model
⋮----
// Process the model
⋮----
// Normalize model size and position
⋮----
// Enable shadows for all meshes in the model
⋮----
// Cache the original model
⋮----
/**
 * Preload models to ensure they're available when needed
 * @param {Array<string>} paths - Array of paths to GLB files
 * @returns {Promise<void>}
 */
export const preloadModels = async (paths: string[]): Promise<void> =>
⋮----
// Only load if not already in cache
⋮----
/**
 * Get paths to crop models for different types
 * @returns {Object} - Object with crop types as keys and model paths as values
 */
export const getCropModelPaths = () =>
⋮----
/**
 * Normalize a loaded model to ensure consistent scaling and positioning
 * @param {THREE.Group} model - The model to normalize
 */
const normalizeModel = (model: THREE.Group): void =>
⋮----
// Calculate the model's bounding box
⋮----
// Get the model's height (usually the Y dimension)
⋮----
// Move model so its base is at y=0
⋮----
// Apply a consistent scale to make models usable with our growth system
// We don't adjust scale here - instead we'll let the createPlant function handle scaling
// based on the actual model size and desired plant height
⋮----
/**
 * Get the dimensions of a model
 * @param {THREE.Group} model - The model to measure
 * @returns {Object} - Object containing width, height, and depth of the model
 */
export const getModelDimensions = (model: THREE.Group):
⋮----
/**
 * Clear the model cache
 */
export const clearModelCache = () =>
</file>

<file path="lib/simulation/cameraUtils.ts">
/**
 * Adjusts camera to view the entire field
 * @param {Array} scaledPolygon - Scaled polygon vertices defining the field
 * @param {THREE.PerspectiveCamera} camera - The THREE.js camera
 * @param {OrbitControls} controls - The OrbitControls instance
 */
export const adjustCameraView = (scaledPolygon, camera, controls) =>
⋮----
// Find bounding box
⋮----
// Calculate center and size
⋮----
// Position camera to see the entire field, adjusted for the sidebar
</file>

<file path="lib/simulation/sceneSetup.ts">
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
⋮----
/**
 * Sets up the THREE.js scene, camera, renderer, and lighting
 * @param {HTMLElement} container - DOM element to attach the renderer to
 * @returns {Object} - Scene setup objects
 */
export const setupScene = (container) =>
⋮----
// Create scene
⋮----
// Create camera
⋮----
// Create renderer
⋮----
// Setup lighting
⋮----
// Setup controls
⋮----
// Setup resize handler
const handleResize = () =>
⋮----
/**
 * Sets up lighting for the scene
 * @param {THREE.Scene} scene - The THREE.js scene
 * @returns {Object} - Created lights
 */
export const setupLighting = (scene) =>
⋮----
// Ambient light
⋮----
// Directional light (sun)
</file>

<file path="lib/simulation/timelineControler.ts">
// lib/simulation/timelineController.ts
⋮----
import { RainSystem, applyWeatherToScene } from '../weather';
import { updatePlantsForGrowthStage } from './plantGrowth';
⋮----
/**
 * Initialize timeline controls for the scene
 * @param {Object} timeline - Timeline data
 * @param {THREE.Scene} scene - The scene
 * @param {Object} sceneObjects - Object containing references to scene objects
 * @param {Function} setDayInfo - Function to update UI with day information
 * @returns {Object} Timeline controller
 */
export const initializeTimelineController = (timeline, scene, sceneObjects, setDayInfo) =>
⋮----
// Initialize rain system
⋮----
// Update the scene for a specific day
const updateSceneForDay = (dayIndex) =>
⋮----
// Update plants with improved growth logic
⋮----
// Update weather effects
⋮----
// Update UI
⋮----
// Set up auto-advance
const setAutoAdvance = (enabled, intervalMs = 1000) =>
⋮----
// Stop at the end
⋮----
// Start with day 0
</file>

<file path="lib/utils/coordinateUtils.ts">
/**
 * Utility functions for working with geo coordinates and polygon conversions
 */
⋮----
/**
 * Converts geo coordinates (latitude, longitude) to normalized 3D coordinates
 * suitable for use in Three.js. This keeps the scale consistent with the existing
 * polygon format [-30, 0, -30], [30, 0, 30] etc.
 * 
 * @param farmPolygon Array of lat/long points
 * @param farmLocation Center point of the farm
 * @param scale Scale factor to normalize the coordinates (default: 60)
 * @returns Array of 3D points [x, y, z] for Three.js
 */
export function convertGeoPolygonTo3D(
    farmPolygon: Array<{latitude: number; longitude: number}>,
    farmLocation: {latitude: number; longitude: number},
    scale: number = 60
): Array<[number, number, number]>
⋮----
// If we don't have a valid polygon, return a default square
⋮----
// Calculate the max distance from center to normalize
⋮----
// Calculate distance from center
⋮----
// Prevent division by zero
⋮----
// Normalize factor to keep within our scale
⋮----
// Convert each point
⋮----
// Calculate normalized differences - note we invert latitude for z-axis
⋮----
// y is always 0 for flat terrain
⋮----
/**
   * Converts a URL parameters polygon string to the geo polygon format
   * 
   * @param polygonString The URL-encoded polygon string
   * @returns Array of latitude/longitude points
   */
export function parsePolygonFromUrl(polygonString: string | null): Array<
</file>

<file path="lib/weather/index.ts">
// Weather constants
⋮----
// Weather probabilities (can be adjusted seasonally)
⋮----
// Weather effects settings
⋮----
/**
 * Generate weather data for a specified number of days
 * @param {number} days - Number of days to generate weather for
 * @param {Date} startDate - Starting date
 * @returns {Array} - Array of day objects with weather data
 */
export const generateWeatherData = (days, startDate = new Date('2025-03-20')) =>
⋮----
// Get the proper month for seasonality
const getSeasonalFactor = (date) =>
⋮----
// Northern hemisphere seasons (adjust if needed)
if (month >= 2 && month <= 4) return 'spring'; // March-May
if (month >= 5 && month <= 7) return 'summer'; // June-August
if (month >= 8 && month <= 10) return 'fall';  // September-November
return 'winter'; // December-February
⋮----
// Adjust weather probabilities based on season
const getSeasonalProbabilities = (season) =>
⋮----
// Create a coherent sequence of weather (not too random)
⋮----
// Weather tends to persist (we'll use this to create more realistic sequences)
⋮----
// 70% chance weather is similar to previous day
⋮----
// Get a weather that's at most one step away from the previous
⋮----
// Completely random weather based on probabilities
⋮----
// Generate temperature based on season and weather
⋮----
case 'spring': baseTemp = 15; break; // ~60°F
case 'summer': baseTemp = 25; break; // ~77°F
case 'fall': baseTemp = 18; break;   // ~64°F
case 'winter': baseTemp = 5; break;  // ~41°F
⋮----
// Adjust for weather conditions
⋮----
// Add some randomness
const tempVariance = (Math.random() * 4) - 2; // -2 to +2 degrees
⋮----
// Generate humidity based on weather
⋮----
// Add some randomness to humidity
const humidityVariance = (Math.random() * 10) - 5; // -5 to +5 percent
⋮----
// Generate a daily growth factor based on conditions
// Plants like moderate temperature, good sunlight, and adequate moisture
⋮----
// Calculate growth factor (ideally between 0 and 1)
⋮----
// Increment the date by one day
⋮----
// Rain particle system
export class RainSystem
⋮----
constructor(scene, count)
⋮----
createRain()
⋮----
// Create rain particles
⋮----
const limit = 100; // Area limit
⋮----
// Random positions within a reasonable area
⋮----
// Velocity vector (falling down with slight angle)
⋮----
update()
⋮----
// Update position based on velocity
positions.array[i * 3 + 0] += velocity.array[i * 3 + 0]; // x
positions.array[i * 3 + 1] += velocity.array[i * 3 + 1]; // y
positions.array[i * 3 + 2] += velocity.array[i * 3 + 2]; // z
⋮----
// Reset particles that go below ground level
⋮----
positions.array[i * 3 + 0] = (Math.random() * 2 - 1) * limit; // x
positions.array[i * 3 + 1] = 100 + Math.random() * 20; // y
positions.array[i * 3 + 2] = (Math.random() * 2 - 1) * limit; // z
⋮----
setCount(count)
⋮----
dispose()
⋮----
/**
 * Apply weather settings to the scene
 * @param {Object} weather - Weather data object
 * @param {THREE.Scene} scene - The scene to apply weather to
 * @param {Object} lightRefs - Object containing references to lights
 * @param {Array} cloudRefs - Array of cloud objects
 * @param {RainSystem} rainSystem - Rain particle system
 */
export const applyWeatherToScene = (weather, scene, lightRefs, cloudRefs, rainSystem) =>
⋮----
return { rainSystem }; // Return early to prevent error
⋮----
// Update fog
⋮----
// Update sky color
⋮----
// Update lights
⋮----
// Update cloud opacity and count
⋮----
// Set visibility for all clouds
⋮----
// Hide excess clouds if we need fewer
⋮----
// Update rain
</file>

<file path="public/data/markdown/nue.md">
# Nutrient use efficiency (NUE) products

This product decision is taken before the growing season based on the historical data and upcoming season prediction.

## Different factors influence that can limit the availability of Nitrogen, Phosphorus and other nutrients:

* ammonia volatilization, nitrification, denitrification, immobilization.
* Leaching, runoff, temperature, soil pH, soil texture, rainfall and irrigation, soil salinity, tillage, weeds, pests, diseases, nutrients loss from plants, crop rotation, crop nutrition, crop varieties.
* Nutritional management (right time, right source, right place, and right rate/amount).

## Nutrient Use Efficiency (NUE) products

are biological products that are used for **fixing Nitrogen**, Phosphorus solubilization, improving nutrient availability and uptake, and promoting plant growth and soil health.

Our NUE product for seed treatment and foliar application

*Seed treatment & Foliar application*

## Value proposition

New innovative product concept based on 3 strains endophytic bacteria (*Sphingobium salicis, Pseudomonas siliginis, Curtobacterium salicis*) with dual effect on N and P use efficiency and mineral nutrient uptakes.

### Plant available N from multiple sources:
- Air – N2
- Soil – NO, NO3, NH3/NH4
- Soil – Organic, C-NP

### Enhanced phosphate mobilization and uptake
- Enhanced P-solubilization
- P and K uptake root to shoot transport
- Organic acid

### Enhanced macronutrient + micronutrient availability
- Siderophore production solubilization of micronutrients Fe, Mg, Cu, Zn, Mn, Mo.

## CROPS – APPLICATION MODALITY – DRY FORMULATION

### Foliar application

| Crops | RATE (g/ha) |
|-------|-------------|
| Wheat | 10-50 |
| Barley | 10-50 |
| Corn | 10-50 |
| OSR | 10-50 |
| Rice | 10-50 |

### Seed treatment

| Crops | RATE (g/t/seeds) |
|-------|-----------------|
| Wheat | 10-50 |
| Barley | 10-50 |
| Corn | 50-150 |
| OSR | 100-250 |
| Sugarbeet | 500-1050 |

## Science behind

**38 trials in corn (US, EU) 2023. 40-unit N reduction scenario - FOLIAR**

- 68%-win rate (positive response)
- Average 2.6% yield increase
- Average 250 kg/ha increase

## KEY BENEFITS

- Product acts as a «back up generator» for plants when nutrients become limiting
- Versatile and easy to apply: seed treatment or foliar application.
- Up to 2 years of shelf life.
- High compatibility with tank mixtures(F, I, H, F).
- Trial data in key field crops.

*Note: (1) Liquid formulation = Solid formulation (1.2 L/ha = 30 g/ha); +10%difference in N regime is not assumed to generate differences within the system.*

*12 | Classification: Internal Use Only*

*Syngenta Biologicals*
</file>

<file path="public/data/markdown/product_crop_fit.md">
# For Brazil

| Product | Product Description | Type of crop applicable |
|---------|---------------------|-------------------------|
| Stress Buster | Aboitic stress, allows the plants to tolerate and quickly overcome the stress, preserving yield under Cold, Heat, drought, wounding | Soybean, Corn, Cotton |
| Nutrient Booster | Increases the efficiency of plants nutrient use. | Soybean, Corn |
| Yield Booster | guarantees maximum productivity | Soybean, corn, cotton |
</file>

<file path="public/data/markdown/stress_buster.md">
# The Stress Buster product card

The Stress Buster - Abiotic stress Recovery

This product can be applied as soon as a stress event is predicted.

*Foliar application*

## Value proposition

### Anti-stress and growth activator

Our comprehensive portfolio include biostimulant that contains a complex of selected vegetal extracts derived from selected plants.

- When applied in case of abiotic stresses, its synergistic action of different active ingredients, allows the plants to tolerate and quickly overcome the stress, preserving yield.
- Applied regularly in normal condition, optimizes plant growth.

## DIRECTIONS FOR USE

| Crop | Dose | Period of application |
|------|------|------------------------|
| Fruit crops | 2-3 l/ha | pre-flowering, post-setting fruit development and in all cases of plant growth stop |
| Vegetable | 2-3 l/ha | in open field and greenhouses after transplant every 10-15 days |
| Row crops | 2-3 l/ha 150-250ml/hl | 1-2 applications during growth cycle in case of abiotic stresses |

## Science behind

### TRANSCRIPTOMICS

**Non-stressed plants** treated will show activation of >100 genes (FC >3) vs. Control, mainly involved in: i) abiotic stress response/tolerance ("hardening effect" against abiotic stress), ii) activation of plant metabolism (thus better growth)

**Drought-stressed plants** pre-treated with stress buster show a decreased expression of stress-related marker genes during stress conditions, showing a lower perception of the stress itself ("acclimated plants"; Petrozza et al., 2014)

### PHENOMICS

Under normal and stress conditions (drought, cold, heat-shock, flooding, simulated hail), Megafol improved:
- "Digital Biovolume/Biomass"
- Health index (less Stress Index)
- Water content
- Other indexes: Green/Yellow Index, etc

### METABOLOMICS

METABOLOMICS has also been used recently, to highlight the action of Stress Buster in stress conditions. It has been observed that the product is capable of modulating specific classes of metabolites, connected to the response to abiotic stress.

Clear benefit of application on Arabidopsis plants under normal and drought stress conditions. These results were confirmed by metabolomics data.

## Our Field Trials

### Performances on crop groups (ROI*)

Total average yield increase on all crops refers to selected trials done with The Stress Buster

#### Row crops
- \+ 0,30 t/ha
- **3,9:1**

#### Vegetable
- \+ 2,3 t/ha
- **11,6:1**

#### Fruit crops
- \+ 1,2 t/ha
- **10,5:1**

*\*Return on investment (ROI) is calculated by dividing the profit by the related investment, based on an average value in the European market.*

*\*\*850 selected trials for the summary, of which 68% were carried out under abiotic stress conditions.*

### Results on main stress conditions

#### COLD
- N. OF EVIDENCES: **10**
- Win rate vs UTC: **70%**
- YIELD INCREASE: **+5%**

#### HEAT
- N. OF EVIDENCES: **26**
- Win rate vs UTC: **76,9%**
- YIELD INCREASE: **+8,2%**

#### DROUGHT
- N. OF EVIDENCES: **483**
- Win rate vs UTC: **70,7%**
- YIELD INCREASE: **+5,1%**

---


*Syngenta Biologicals*
</file>

<file path="public/data/markdown/weather_based_algorithms.md">
# Algorithm Logic Document

## **Stress Buster**

### **1. Day time heat stress risk (algorithm based on maximum temperatures)**
Each crop has specific cardinal temperatures that define limits of growth and development.
The scale will be from 0 to 9, zero means no stress, and 9 is the maximum diurnal heat stress.

**Logic**
---
### **Equation**
- Diurnal heat stress = 0 for (TMAX <= TMaxOptimum)
- Diurnal heat stress = 9 * [(TMAX - TMaxOptimum) / (TMaxLimit - TMaxOptimum)] for (TMaxOptimum < TMAX < TMaxLimit)
- Diurnal heat stress = 9 for (TMAX >= TMaxLimit)
---
Where,
- TMAX = daily maximum air temperature (ºC)
- TMaxOptimum is defined as the maximum temperature for optimum growth
- TMaxLimit is defined as the temperature when the crop does not grow anymore (zero growth)
| **Crop**  | **TMaxOptimum** | **TmaxLimit** |
|-----------|-----------------|---------------|
| Soybean   | 32              | 45            |
| Corn      | 33              | 44            |
| Cotton    | 32              | 38            |
| Rice      | 32              | 38            |
| Wheat     | 25              | 32            |
Diurnal heat stress for soybean = 9 * [(TMAX - 32) / (45 - 32)]
---
### **2. Nighttime heat stress risk (algorithm based on minimum temperatures)**
Warm night temperatures during the flowering and other growth stages lead to yield reductions due to a high rate of cellular respiration and accelerated phenological development.
The scale will be from 0 to 9, zero means no stress, and 9 is the maximum diurnal Night stress.
---
### **Equation**
- Nighttime heat stress = 0 for (TMIN < TMinOptimum)
- Nighttime heat stress = 9 * [(TMIN - TMinOptimum) / (TMinLimit - TMinOptimum)] for (TMinOptimum ≤ TMIN < TMinLimit)
- Nighttime heat stress = 9 for (TMIN ≥ TMinLimit)
---
Where,
- TMIN = daily minimum air temperature (ºC) (Variable obtained from the WTH file)
- TMinOptimum is defined as the maximum daily minimum temperature for optimum growth
- TMinLimit is the minimum temperature at which the crop is significantly affected by night heat stress
| **Crop**  | **TMinOptimum** | **TminLimit** |
|-----------|-----------------|---------------|
| Soybean   | 22              | 28            |
| Corn      | 22              | 28            |
| Cotton    | 20              | 25            |
| Rice      | 22              | 28            |
| Wheat     | 15              | 20            |

Diurnal Night stress for soybean = 9*[(TMAX - 32)/(45-32)]

- If the "Nighttime heat stress" is >9, then use 9.

### **3.Frost stress (algorithm based on minimum temperatures)**

Freezing temperatures prior to maturity can result in yield losses. A killing freeze occurs when temperatures dip to zero degrees Celsius for four hours or 2.2 degrees Celsius for minutes. A killing freeze can still happen with temperatures above zero degrees Celsius, especially in low and unprotected areas when there's no wind.

Calculate frost stress when TMIN is < = 4 °C. If TMIN is more than 4 °C, then there is no frost, frost is zero.

Frost stress = 0 for (TMIN >= TMinNoFrost)

Frost stress = 9*[ABS(TMIN - TMinNoFrost) / ABS(TminFrost - TMinNoFrost)] for (TMIN < TMinNoFrost)

Frost stress = 9 for (TMIN <= TMinFrost)

| **Crop**  | **TMinNoFrost** | **TminFrost** |
|-----------|-----------------|---------------|
| Soyabean  | 4               | -3            |
| Corn      | 4               | -3            |
| Cotton    | 4               | -3            |
| Rice      | NA              | NA            |
| Wheat     | NA              | NA            |

Where,

TMIN= daily minimum air temperature (°C)

TMinNoFrost = is the minimum temperature at which the crop is not affected by Frost stress.

TminFrost = is the minimum temperature at which the crop is significantly affected by Frost stress.

The final equation with the temperatures listed above is,

Frost stress = 9*[ABS(TMIN - 4) / ABS(-3 - 4)]

### **4.Drought risk**

Drought risk can be computed for the previous season and predict whether the current season will be, predict whether the current season will be a Drought risk, in a Drought risk and recommend the biosimulate.

A simplified drought index (DI) can be expressed as:

DI = (P - E) + SM / T

Where:

- (P) = Cumulative rainfall (mm) over a specific period (e.g., growing season).
- (E) = Cumulative evaporation (mm) over the same period. (e.g., growing season).
- (SM) = Soil moisture content (mm or %). (average over the growing season)
- (T) = Average temperature (°C) over the period.

- Rainfall (P):
  - Rainfall is the primary source of water for crops. Insufficient rainfall leads to drought conditions.
- Evaporation(E):
  - Evaporation represents water loss from the soil and crop surface. High evaporation rates increase water stress.
  - Use evapotranspiration (ET) data.

- Soil Moisture (SM):
  - Soil moisture indicates the available water in the root zone. Low soil moisture levels indicate drought stress.
  - Measure soil moisture as volumetric water content (VWC) or as a percentage.

- Temperature (T):
  - High temperatures increase evaporation and transpiration rates, exacerbating drought conditions.
  - Use average daily
- Interpretation of the Drought Index (DI)
  - *DI > 1: No risk
  - *DI = 1: Medium risk
  - DI < 1: Medium risk

## **Yield Booster**

### **5. Yield risk**

For Yield risk, you can have two approaches

1. Gather the yield from the grower for past years and identify if the field is at risk and recommend the biosimulate to increase the yield.

2. Compute the yield risk using the formulae below and recommend the biosimulate.

Yield risk can be calculated based on nitrogen, temperature, rainfall, and the soil's pH. The duration of the growing seasons will be different for different crops.

Typically you can compute the yield risk for the historical periods and decide the recommendation of the biosimulation.

The simple formula is

YR=w1·(GDD– GDD_opt)2+w2·(P–Popt)2+w3·(pH–pHopt)2+w4·(N–Nopt)2

Where:

- (GDD) = Actual Growing Degree Days
- (GDD_opt) = Optimal Growing Degree Days
- (P) = Actual rainfall (mm)
- (P_opt) = Optimal rainfall for growth (mm)
- (pH) = Actual soil pH
- (pH_opt) = Optimal soil pH• (N) = Actual available nitrogen in the soil (kg/ha)
- (N_opt) = Optimal nitrogen availability for soybean (kg/ha)
- (w_1, w_2, w_3, w_4 \) = Weighting factors for each variable, reflecting their relative importance.

Example weighting factors: Here's an example of how weighting factors might be distributed:

- w1 (GDD): 0.3 w2 (Precipitation): 0.3 w3 (pH): 0.2 w4 (Nitrogen): 0.2

- This distribution suggests that GDD and precipitation have a slightly higher impact on yield risk than pH and nitrogen levels

The optimal values for the crop are given below

| Crop Name | GDD optimal | Precipitation Optimal | pH optimal | N Optimal |
|-----------|-------------|----------------------|------------|-----------|
| Soyabean  | 2400-3000   | 450-700 mm          | 6.0-6.8    | 0-0.026 µ/kg |
| Corn      | 2700-3100   | 500-800 mm          | 6.0-6.8    | 0.077-0.154 g/kg |
| Cotton    | 2200-2600   | 700-1300 mm         | 6.0-6.5    | 0.051-0.092 g/kg |
| Rice      | 2000-2500   | 1000-1500 mm        | 5.5-6.5    | 0.051-0.103 g/kg |
| Wheat     | 2000-2500   | 1000-1500 mm        | 5.5-6.5    | 0.051-0.103 g/kg |

Growing Degree Days (GDD) is:

GDD = [(Tmax + Tmin) / 2] - Tbase

Where:

Tmax = Maximum daily temperature
Tmin = Minimum daily temperature
Tbase = Base temperature (threshold for plant growth)

## **Nutrient Booster**

Nutrient biosimulants are usually recommended based on the previous year consumption of nutrient and plan for the current seasons.

### **6. Nitrogen stress**

The biosimulants are recommended for improving nutrient uptake and efficiency and based on the NUE (Nutrient Use Efficiency) (NUE).

Based on the projected yield and taking the nitrogen inputs and rainfall and soil moisture, we can predict whether we need biosimulants.

Generally, NUE for Nitrogen ranges can be categorized as follows:

High NUE: > 40 kg yield / kg N applied

Moderate NUE: 20-40 kg yield / kg N applied

Low NUE: < 20 kg yield / kg N applied

For moderate and Low NUE, we recommend Biosimulants

To compute NUE for nitrogen, this is a formula.

NUE = (Crop yield / Nitrogen applied) * (Rainfall factor) * (Soil moisture factor)

Crop Yield – Projected crop yield kg/ha

Nitrogen applied – Nitrogen applied kg/ha

1. Rainfall factor (RF): RF = 1 if rainfall is optimal RF < 1 if rainfall is below optimal (drought conditions) RF > 1 if rainfall is above optimal (potential leaching)

Example calculation: If optimal rainfall is 600 mm and actual rainfall is 500 mm: RF = 500 / 600 = 0.83

2. Soil moisture factor (SMF): SMF = 1 if soil moisture is optimal SMF < 1 if soil is too dry SMF > 1 if soil is too wet (potential denitrification)

Example calculation: If optimal soil moisture is 25% and actual soil moisture is 20%: SMF = 20 / 25 = 0.8

The Optimal values for soil moisture and precipitation are given below

| Crop Name | Soil moisture optimal | Precipitation Optimal |
|-----------|----------------------|----------------------|
| Soyabean  | 50-70%               | 450-700 mm           |
| Corn      | 50-70%               | 500-800 mm           |
| Cotton    | 50-70%               | 700-1300 mm          |
| Rice      | 80%                  | 1000-1500 mm         |
| Wheat     | 80%                  | 1000-1500 mm         |

### **7. Phosphorus stress**

The biosimulants are recommended for improving nutrient uptake and efficiency and based on the NUE (Phosphorus Use Efficiency (NUE) for Phosphorus.

NUE = (Yield / P applied) * SF  (for Phosphorous)

Where:

Example calculation: If optimal soil moisture is 25% and actual soil moisture is 20%: SMF = 20 / 25 = 0.8

The Optimal values for soil moisture and precipitation and pH are given below

| Crop Name | Soil moisture optimal | Precipitation Optimal | pH optimal |
|-----------|----------------------|----------------------|------------|
| Soyabean  | 50-70%               | 450-700 mm           | 6.0-7.0    |
| Corn      | 50-70%               | 500-800 mm           | 6.0-7.0    |
| Cotton    | 50-70%               | 700-1300 mm          | 6.0-6.5    |
| Rice      | 80%                  | 1000-1500 mm         | 5.5-6.5    |
| Wheat     | 80%                  | 1000-1500 mm         | 6.0-7.0    |
</file>

<file path="public/data/markdown/yield_booster.md">
# The Yield Booster product card

This product decision is taken before the growing season based on the historical data and upcoming season prediction.

*Foliar application*

## Value proposition

### Highest crop productivity,
### Highest return for farmers

In our portfolio we have a biostimulant for row crops able to ensure **highest productivity and return for farmers**.

This solution is able to increase plant productivity through:
- Better transport of sugars and nutrients
- Promotion of cell division
- Fatty acids biosynthesis and transport

## DIRECTIONS FOR USE

| Crop | Dose | Period of application | Crop | Dose | Period of application |
|------|------|------------------------|------|------|------------------------|
| Wheat | 2 l/ha | 1 application at flag leaf growth stage | Rice | 1-2 l/ha | 2 applications: the 1st at the beginning of booting, the 2nd at heading growth stage |
| Soybean | 1-2 l/ha | 2 applications: the 1st at Vn/R1 growth stage, the 2nd at R3/R5 growth stage | Cotton | 2 l/ha | 2 applications: the 1st before squares appear and 2nd after 3-4 weeks |
| Corn | 2 l/ha | 1 application at V4-V6 growth stage | Sunflower | 2 l/ha | 1 application at 4-6 leaf growth stage |

## Science behind

### TRANSCRIPTOMICS

**Next Generation Sequencing (NGS)** experiment on corn and soybean: plants treated with Yield Booster showed activation of genes involved in:

- **Transport of sugars and nutrients**: Zn and Fe uptake and transport, ammonium and nitrogen assimilation, phosphate homeostasis (uptake, sensing), phloem loading.
- **Promotion of cell division**: the coordination of specific hormonal processes, including the establishment of an optimal auxin/cytokinin balance.
- **Fatty acids biosynthesis/transport**: lipid transport, photosynthesis

### PHENOMICS

Experiments on corn and soybean, where Yield Booster improved:
- Digital Biovolume and height
- Plant compactness
- Green Index

## Field trials

### Key Crops Performance

Total average yield increase on all crops refers to all trials done with Yield Booster.

| Crop | Crop average yield increase (%) |
|------|--------------------------------|
| Bean | 12 |
| Cotton | 11 |
| Sunflower | 10 |
| Rice | 9 |
| Soft Wheat | 6 |
| Corn | 5 |
| Soybean | 5 |
| Oilseed Rape | 4 |
| Barley | 2 |

#### Wheat
- **+0,30 t/ha**
- ROI* 3:1

#### Rice
- **+0,66 t/ha**
- ROI* 14:1

#### Soybean
- **+0,27 t/ha**
- ROI* 9:1

#### Corn
- **+0,64 t/ha**
- ROI* 7:1

*\*Return on investment (ROI) is calculated by dividing the profit by the related investment, based on an average value in the European market.*

### Results

#### 2017 - 2022 Rice Trials Percentage Increase - World
Average Yield Increase: 7.4%

#### Yieldon response to Yield Booster Application 
(both untreated and fungicide+Yield Booster) - Delta BU/A

64 corn trials in 2022
YieldB application resulted in positive yield response in 83% of trials
With an average bu/A increase of 6.8 bu/A

*Syngenta Biologicals*
</file>

<file path="public/data/crop_optimal_data.csv">
Crop_Name,GDD_Optimal,Precipitation_Optimal,pH_Optimal,N_Optimal
soybean,2700,575,6.4,0.013
corn,2900,650,6.4,0.1155
cotton,2400,1000,6.25,0.0715
rice,2250,1250,6,0.077
wheat,2250,1250,6,0.077
</file>

<file path="public/data/mock-environment.json">
{
  "forecast": {
    "daily": [
      {
        "date": "2025-03-19",
        "temperature": {
          "max": 28.4,
          "min": 18.2,
          "avg": 23.1
        },
        "precipitation": 0,
        "humidity": 65.2,
        "windSpeed": 3.4,
        "globalRadiation": 6750
      },
      {
        "date": "2025-03-20",
        "temperature": {
          "max": 29.1,
          "min": 19.3,
          "avg": 24.2
        },
        "precipitation": 0,
        "humidity": 62.1,
        "windSpeed": 2.8,
        "globalRadiation": 7020
      },
      {
        "date": "2025-03-21",
        "temperature": {
          "max": 27.5,
          "min": 17.8,
          "avg": 22.6
        },
        "precipitation": 5.3,
        "humidity": 78.4,
        "windSpeed": 4.6,
        "globalRadiation": 4250
      },
      {
        "date": "2025-03-22",
        "temperature": {
          "max": 24.8,
          "min": 16.9,
          "avg": 20.3
        },
        "precipitation": 12.7,
        "humidity": 83.9,
        "windSpeed": 5.2,
        "globalRadiation": 3850
      },
      {
        "date": "2025-03-23",
        "temperature": {
          "max": 26.2,
          "min": 17.5,
          "avg": 21.8
        },
        "precipitation": 2.1,
        "humidity": 75.3,
        "windSpeed": 3.9,
        "globalRadiation": 5420
      },
      {
        "date": "2025-03-24",
        "temperature": {
          "max": 28.7,
          "min": 18.9,
          "avg": 23.5
        },
        "precipitation": 0,
        "humidity": 64.8,
        "windSpeed": 3.1,
        "globalRadiation": 6980
      },
      {
        "date": "2025-03-25",
        "temperature": {
          "max": 30.2,
          "min": 19.7,
          "avg": 24.8
        },
        "precipitation": 0,
        "humidity": 59.2,
        "windSpeed": 2.5,
        "globalRadiation": 7240
      }
    ],
    "hourly": [
      {
        "datetime": "2025-03-19T00:00:00",
        "temperature": 19.2,
        "humidity": 72.5,
        "windSpeed": 2.1,
        "precipitation": 0,
        "cloudCover": 15
      },
      {
        "datetime": "2025-03-19T01:00:00",
        "temperature": 18.7,
        "humidity": 74.8,
        "windSpeed": 1.8,
        "precipitation": 0,
        "cloudCover": 10
      }
    ]
  },
  "historical": {
    "temperature": {
      "avg": 24.5,
      "max": 35.2,
      "min": 15.1
    },
    "precipitation": {
      "annual": 850,
      "monthly": [45, 60, 75, 90, 120, 65, 45, 35, 70, 95, 85, 65]
    }
  },
  "soil": {
    "texture": "Clay Loam",
    "properties": {
      "bulkDensity": 1.35,
      "organicMatter": 2.8,
      "ph": 6.5,
      "waterHoldingCapacity": 0.22,
      "cationExchangeCapacity": 12.5
    }
  },
  "stress_factors": {
    "current": {
      "drought": 0.2,
      "heat": 0.1,
      "nutrient_deficiency": 0.05
    },
    "forecast": [
      {
        "date": "2025-03-20",
        "drought": 0.25,
        "heat": 0.15,
        "nutrient_deficiency": 0.05
      },
      {
        "date": "2025-03-21",
        "drought": 0.15,
        "heat": 0.1,
        "nutrient_deficiency": 0.05
      },
      {
        "date": "2025-03-22",
        "drought": 0.05,
        "heat": 0.05,
        "nutrient_deficiency": 0.05
      }
    ]
  }
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="types/farm.ts">
export interface GeoLocation {
    lat: number;
    lng: number;
}
⋮----
export interface Crop {
    id: string;
    name: string;
    type: CropType;
    acreage: number;
}
⋮----
export type CropType =
    | 'rice'
    | 'wheat'
    | 'corn'
    | 'soybean'
    | 'cotton'
    | 'vegetable'
    | 'fruit';
⋮----
export interface FarmData {
    id?: string;
    name: string;
    location: GeoLocation;
    crops: Crop[];
    totalAcreage: number;
    soilType?: string;
    waterSource?: string;
}
</file>

<file path="types/products.ts">
export type ProductCategory = 'Biocontrol' | 'Biofertilizer' | 'Biostimulant';
⋮----
export interface Product {
    id: string;
    name: string;
    category: ProductCategory;
    type: string;
    description: string;
    applicationMethod: string;
    compatibleCrops: string[];
    dosageRate: Record<string, string>;
    applicationTiming: Record<string, string>;
    effectivenessRating: number; // 1-10 scale
    roiRating: number; // Return on investment rating
    imageUrl?: string;
}
⋮----
effectivenessRating: number; // 1-10 scale
roiRating: number; // Return on investment rating
⋮----
export interface ApplicationSchedule {
    productId: string;
    day: number;
    cropType: string;
    dosage: string;
}
</file>

<file path="types/simulation.ts">
import { Crop } from './farm';
import { Product } from './products';
⋮----
export interface SimulationState {
    // Timeline
    currentDay: number;
    totalDays: number;
    isPlaying: boolean;
    playbackSpeed: number;

    // Selections
    selectedCropId: string | null;
    selectedProducts: Record<string, string[]>; // Map of cropId -> productIds

    // Results
    yieldEstimates: Record<string, CropYieldEstimate>;
    environmentalData: EnvironmentalData | null;
}
⋮----
// Timeline
⋮----
// Selections
⋮----
selectedProducts: Record<string, string[]>; // Map of cropId -> productIds
⋮----
// Results
⋮----
export interface CropYieldEstimate {
    cropId: string;
    cropName: string;
    cropType: string;
    baseYieldPerAcre: number;
    estimatedYield: number;
    totalEstimatedYield: number;
    potentialImprovement: number;
    totalPotentialImprovement: number;
    productEffect?: number;
    stressFactors: {
        temperature: number;
        water: number;
        soil: number;
        overall: number;
    };
}
⋮----
export interface EnvironmentalData {
    forecast?: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: {
        texture: string;
        properties: {
            bulkDensity: number;
            organicMatter: number;
            ph: number;
            waterHoldingCapacity: number;
            cationExchangeCapacity: number;
        };
    };
    stress_factors?: {
        current: {
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        };
        forecast: Array<{
            date: string;
            drought: number;
            heat: number;
            nutrient_deficiency: number;
        }>;
    };
}
⋮----
export interface SimulationAction {
    type: string;
    payload?: any;
}
⋮----
// Simulation event types that can be tracked
export type SimulationEvent =
    | 'CROP_PLANTED'
    | 'PRODUCT_APPLIED'
    | 'STRESS_DETECTED'
    | 'HARVEST_READY'
    | 'WEATHER_CHANGE';
⋮----
export interface SimulationEventData {
    type: SimulationEvent;
    day: number;
    cropId?: string;
    productId?: string;
    message: string;
    severity?: 'info' | 'warning' | 'success';
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";
⋮----
/* config options here */
</file>

<file path="postcss.config.mjs">

</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="app/api/environmental-data/route.ts">
import { NextRequest, NextResponse } from 'next/server';
⋮----
// Define interfaces for API responses
interface CEHubResponse {
    success: boolean;
    data: any;
    error?: string;
}
⋮----
interface WeatherData {
    forecast: {
        daily: Array<{
            date: string;
            temperature: {
                max: number;
                min: number;
                avg: number;
            };
            precipitation: number;
            humidity: number;
            windSpeed: number;
            globalRadiation: number;
        }>;
        hourly?: Array<any>;
    };
    historical?: any;
    soil?: any;
}
⋮----
/**
 * Environmental data API route handler
 * Fetches weather forecast and soil data from CE Hub API
 */
export async function GET(request: NextRequest)
⋮----
// Validate required parameters
⋮----
// Get API config based on endpoint type
⋮----
// Configure API parameters based on request type
⋮----
// FORECAST API CONFIGURATION
⋮----
// Match Postman example for Forecast API path
⋮----
// HISTORICAL API CONFIGURATION
⋮----
// For historical API, key goes in URL
⋮----
// Match Postman example for Historical API
⋮----
velocity: "km/h", // Changed from m/s to match Postman example
⋮----
type: "MultiPoint", // Changed from Point to match Postman
⋮----
domain: "ERA5T", // Matches Postman example
⋮----
// SOIL API CONFIGURATION
⋮----
// For soil API, key goes in URL
⋮----
// Match Postman example for Soil API exactly
⋮----
domain: "SOILGRIDS1000", // Critical: Correct domain from Postman
⋮----
{ code: 812, level: "5 cm" } // Specific soil code from Postman
⋮----
{ code: 806, level: "0 cm" } // Specific soil code from Postman
⋮----
{ code: 831, level: "0-20 cm" } // Additional soil property
⋮----
// Make request to CE Hub API with enhanced logging
⋮----
// Handle different response statuses appropriately
⋮----
// Handle No Content responses
⋮----
// Try to get error details for better diagnostics
⋮----
// Throw appropriate error based on status code
⋮----
// Process successful responses
⋮----
// Process the data based on the type
⋮----
// Return mock data if API request fails
⋮----
/**
 * Process the API response based on the type of data requested
 */
function processApiResponse(type: string, responseData: any)
⋮----
// First check if we have valid data to process
⋮----
// Generate mock data based on type
⋮----
// Extract and format forecast data from the response
⋮----
// If mapped data is empty, fall back to mock
⋮----
// [Similar implementation for historical data]
// ...
⋮----
// [Similar implementation for soil data]
// ...
⋮----
/**
 * Synchronous version of getMockData for use within processApiResponse
 */
function getMockDataSync(type: string): any
⋮----
// Use a default location when no coordinates are available
⋮----
/**
 * Helper to get the first data value from a dataset
 */
/**
 * Helper to get the first data value from a dataset
 */
function getFirstDataValue(dataset: any): number | null
⋮----
// Return a reasonable mock value instead of null
⋮----
// Handle the case where value might be null or not a number
⋮----
/**
 * Get the soil texture description based on the value
 */
function getSoilTextureDescription(textureValue: number | null): string
⋮----
// Soil texture classification mapping
⋮----
/**
 * Get mock data for development and testing
 */
async function getMockData(type: string, lat: string, lng: string, startDate: string, endDate: string): Promise<any>
⋮----
// Generate realistic mock data based on type and params
⋮----
/**
 * Generate mock forecast data
 */
function generateMockForecast(startDate: string, endDate: string)
⋮----
// Generate somewhat realistic weather data with some variability
const baseTemp = 25 + Math.sin(i / 3) * 5; // Oscillating temperature pattern
⋮----
precipitation: Math.random() > 0.7 ? Math.random() * 10 : 0, // 30% chance of rain
⋮----
/**
 * Generate mock historical data
 */
function generateMockHistorical(startDate: string, endDate: string)
⋮----
// Simple mock historical data
⋮----
/**
 * Generate mock soil data
 */
function generateMockSoil(lat: string, lng: string)
⋮----
// Generate mock soil data based on coordinates
// This is very simplified - real soil data would be much more complex
⋮----
// Use coordinates to deterministically generate different soil types
// This creates a simple pattern across different locations
</file>

<file path="app/api/growth-rate/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import OpenAI from 'openai';
import dotenv from 'dotenv';
import { parse } from 'csv-parse/sync';
⋮----
interface WeatherData {
    precipitation: number;
    min_temperature: number;
    max_temperature: number;
    humidity: number;
}
⋮----
interface CropGrowthRequest {
    weather: WeatherData;
    crop: string;
    product: string;
    soil_ph: number;
    soil_nitrogen: number;
}
⋮----
interface CropGrowthResponse {
    growth_rate_increase: number;
    daily_growth_percentage: number;
    yield_risk: number;
    estimated_yield: number;
    observations: string;
}
⋮----
interface CropGddData {
    crop: string;
    base_temperature: number;
    total_gdd: number;
    baseline_yield: number;
}
⋮----
interface CropOptimalData {
    crop: string;
    gdd_optimal: number;
    precipitation_optimal: number;
    ph_optimal: number;
    n_optimal: number;
}
⋮----
// Maintain OpenAI client and conversation history
class OpenAIService
⋮----
private constructor(apiKey: string)
⋮----
public static getInstance(apiKey: string): OpenAIService
⋮----
public async initialize(): Promise<void>
⋮----
private async loadCropGddData(): Promise<void>
⋮----
baseline_yield: parseFloat(record.baseline_yield) // Add this line to extract baseline yield
⋮----
private async loadCropOptimalData(): Promise<void>
⋮----
private calculateGdd(minTemp: number, maxTemp: number, baseTemp: number): number
⋮----
public async getCropGrowthRate(requestData: CropGrowthRequest): Promise<CropGrowthResponse>
⋮----
// Define weights as per the example in Syngenta's documentation
⋮----
// Calculate yield risk using the formula:
// YR = w1·(GDD - GDD_opt)² + w2·(P - P_opt)² + w3·(pH - pH_opt)² + w4·(N - N_opt)²
⋮----
private async callOpenAI(userMessage: string): Promise<string>
⋮----
/**
 * Crop growth rate API route handler
 * Uses a singleton OpenAI service to maintain conversation history
 */
export async function POST(request: NextRequest)
</file>

<file path="app/api/products/route.ts">
import { NextRequest, NextResponse } from 'next/server';
⋮----
// Import mock products data
import mockProductsData from '@/lib/data/products.json';
⋮----
export async function GET(request: NextRequest)
⋮----
// In a real implementation, we would fetch from a database or external API
// For this hackathon, we're using our mock data
⋮----
// Let's add a small delay to simulate API latency
</file>

<file path="app/simulation/components/SeasonTimelineControls.tsx">
// components/simulation/SeasonTimelineControls.tsx
⋮----
import React, { useState, useEffect } from 'react';
⋮----
interface SeasonTimelineControlsProps {
    controller: any;
    totalDays: number;
    location: any;
}
⋮----
// Define the three seasons and their day positions
⋮----
// Get current season based on day
const getCurrentSeason = (day: number) =>
⋮----
// Handle season selection
const handleSeasonSelect = (seasonKey: string) =>
⋮----
// Play/pause toggle
const togglePlayPause = () =>
⋮----
// Speed control
const handleSpeedChange = (newSpeed: number) =>
⋮----
// Update state when controller changes day
⋮----
const updateTimelineState = () =>
⋮----
// Set initial state
⋮----
// Set up interval to check controller state
⋮----
// Weather icon based on conditions
const getWeatherIcon = (weather: string) =>
⋮----
// Growth stage icon
const getGrowthStageIcon = (stage: string) =>
⋮----
// Format weather name for display
const formatWeatherName = (weather: string) =>
⋮----
{/* Header Section */}
⋮----
{/* Season Navigation */}
⋮----
{/* Crop Status */}
⋮----
{/* Weather Conditions */}
⋮----
{/* Speed Control */}
⋮----
{/* Day Slider Control */}
</file>

<file path="components/farm/CropSelector.tsx">
import React, { useState } from 'react';
import { Crop, CropType } from '@/types/farm';
import { Button } from '@/components/ui/Button';
⋮----
interface CropSelectorProps {
    crops: Crop[];
    onChange: (crops: Crop[]) => void;
    totalFarmSize: number;
    className?: string;
}
⋮----
// Crop type options with metadata
⋮----
export default function CropSelector({
    crops,
    onChange,
    totalFarmSize,
    className = '',
}: CropSelectorProps)
⋮----
// Calculate total acreage currently allocated
⋮----
// Function to add a new crop
const handleAddCrop = () =>
⋮----
// Default to first available crop type not yet selected
⋮----
acreage: Math.min(1, remainingAcreage) // Use remaining acreage or 1, whichever is smaller
⋮----
// Function to remove a crop
const handleRemoveCrop = (cropId: string) =>
⋮----
// Function to update a crop
const handleCropChange = (index: number, updatedCrop: Partial<Crop>) =>
⋮----
// Validate acreage
⋮----
// Still update the state, but with the validation error
⋮----
onChange=
</file>

<file path="components/farm/FarmReviewStep.tsx">
// components/farm/FarmReviewStep.tsx
⋮----
import React, { useState } from 'react';
import Image from 'next/image';
import dynamic from 'next/dynamic';
⋮----
// Dynamically import the MapComponent with no SSR to prevent Leaflet issues
⋮----
interface FarmReviewStepProps {
    farmLocation: { latitude: number; longitude: number; name: string };
    farmSize: number;
    farmPolygon: Array<{ latitude: number; longitude: number }>;
    cropType: string;
    onStartSimulation: () => void;
    onBack: () => void;
}
⋮----
// Helper function to get crop emoji
const getCropEmoji = (crop: string) =>
⋮----
// Format hectares for display
const formatHectares = (value: number): string =>
⋮----
// Format a polygon point for display
const formatCoordinate = (coord: number): string =>
⋮----
// Handle start simulation with proper cleanup
const handleStartSimulation = () =>
⋮----
// Unmount the map component before navigating
⋮----
// Add a small delay to ensure the map is fully unmounted
⋮----
{/* Farm Details */}
⋮----
{/* Map Visualization */}
⋮----
{/* Start Simulation Button */}
⋮----
{/* Navigation buttons */}
</file>

<file path="components/farm/LocationPicker.tsx">
import React, { useState, useEffect } from 'react';
import dynamic from 'next/dynamic';
import { GeoLocation } from '@/types/farm';
⋮----
// Import types but not actual components to avoid SSR issues
import type { MapContainer as MapContainerType } from 'react-leaflet';
⋮----
interface LocationPickerProps {
    value: GeoLocation;
    onChange: (location: GeoLocation) => void;
    className?: string;
}
⋮----
// Dynamically import the map component with SSR disabled
// This ensures Leaflet only loads in the browser, not during server rendering
⋮----
// Handler for search functionality
const handleSearch = async () =>
⋮----
// Using Nominatim for geocoding (OpenStreetMap)
⋮----
setSearchResults(data.slice(0, 5)); // Limit to 5 results
⋮----
const handleSelectResult = (result:
⋮----
{/* Search Component */}
⋮----
onChange=
⋮----
onKeyDown=
⋮----
{/* Search Results */}
⋮----
{/* Map Component - Dynamically loaded on client-side only */}
</file>

<file path="components/ui/HeroSection.tsx">
import React from 'react';
import Image from 'next/image';
import Navbar from './Navbar';
⋮----
interface HeroSectionProps {
    onGetStarted: () => void;
}
⋮----
{/* Full viewport background container */}
⋮----
{/* Gradient overlay for text readability */}
⋮----
{/* Header bar - positioned absolutely to maintain its position */}
⋮----
{/* Main content container - positioned absolutely to maintain layout */}
⋮----
{/* Get Started button */}
</file>

<file path="lib/crops/index.ts">
import { PLANT_HEIGHTS, SCALE_FACTOR, getRandomizedHeight } from './constants';
import { loadModel, getCropModelPaths } from '../services/modelLoader';
⋮----
// Fallback creation methods if models fail to load
import createCornPlant from './corn';
import createWheatPlant from './wheat';
import createSoybeanPlant from './soybean';
import createCottonPlant from './cotton';
import createRicePlant from './rice';
⋮----
// Get model paths
⋮----
// Track loading status
⋮----
/**
 * Preload all crop models - call this at app initialization
 */
export const preloadCropModels = async () =>
⋮----
/**
 * Creates a plant based on type and positions it at the specified coordinates
 * Uses 3D models when available, falls back to geometry-based models if needed
 * @param {string} type - Type of crop
 * @param {number} x - X coordinate
 * @param {number} z - Z coordinate
 * @returns {THREE.Group} - The created plant 3D object
 */
export const createPlant = async (type: string, x: number, z: number): Promise<THREE.Group> =>
⋮----
// Get base height for the plant type and apply scale factor
⋮----
// Apply natural variation to the height
⋮----
// Create a container group for the plant
⋮----
// Add random rotation for natural variation
⋮----
// Mark as a plant for timeline animations
⋮----
// Try to load the 3D model for this crop type
⋮----
// Scale model appropriately based on desired height
⋮----
// Calculate scale based on desired height and add scaling factor
// We multiply by 3 to make the models significantly larger
⋮----
// Log scaling information for debugging
⋮----
// Mark model components for growth animation
⋮----
// Store original scale for growth animations
⋮----
// Store original scale for the model
⋮----
// Add model to the plant group
⋮----
// Tag specific parts for growth animation
⋮----
// Fallback to geometry-based plant if no model path exists
⋮----
// Fallback to geometry-based models
⋮----
// Create a simple default plant
⋮----
/**
 * Helper function to get the height of a model by analyzing its bounding box
 */
function getModelHeight(model: THREE.Group): number
⋮----
/**
 * Tag specific parts of the plant model for growth animation
 * This helps identify which parts to show/hide at different growth stages
 */
function tagPlantParts(plantGroup: THREE.Group, cropType: string)
⋮----
// Traverse the model to find and tag specific parts
⋮----
// Skip non-meshes
⋮----
// Tag parts by their names in the 3D model
⋮----
// Additional crop-specific tags
⋮----
// Create a synchronous version for the simulation setup
// This will use a placeholder if the model isn't loaded yet
export const createPlantSync = (type: string, x: number, z: number): THREE.Group =>
⋮----
// Create a simple placeholder
⋮----
// Schedule async replacement with the real model
⋮----
// Remove the placeholder
⋮----
// Transfer the loaded model to this group
⋮----
// Copy relevant userData
⋮----
// Export other constants for use elsewhere
</file>

<file path="lib/environment/terrain.ts">
/**
 * Creates terrain with ground planes and boundaries
 * @param {THREE.Scene} scene - The THREE.js scene
 */
export const createTerrain = (scene) =>
⋮----
// Large ground plane (distant terrain)
⋮----
// Create farm field ground (cultivatable area)
⋮----
// Field borders (overall boundary)
⋮----
/**
 * Creates a soil mesh for a specific field based on polygon shape
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {Array} vertices - Array of vertices defining the field
 * @returns {THREE.Mesh} - The created soil mesh
 */
export const createFieldSoil = (scene, vertices) =>
⋮----
// Create a 2D shape from the vertices
⋮----
// Invert the z-coordinate to match the rotation transformation
⋮----
// Close the shape
⋮----
// Create geometry from shape
⋮----
/**
 * Creates a boundary line for a field
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {Array} vertices - Array of vertices defining the field boundary
 * @returns {THREE.Line} - The created boundary line
 */
export const createFieldBoundary = (scene, vertices) =>
⋮----
// Create points for the line
⋮----
// Close the loop
</file>

<file path="lib/simulation/index.ts">
import { createPlantSync, preloadCropModels, PLANTS_PER_HECTARE } from '../crops';
import { createFieldSoil, createFieldBoundary } from '../environment';
import {
    scalePolygonToHectares,
    triangulatePolygon,
    getRandomPointInTriangle,
    createFieldInfoSign,
    generateGridPlantPositions
} from './fieldUtils';
import { adjustCameraView } from './cameraUtils';
import { getCropModelPaths, preloadModels, setLoadingCallbacks } from '../services/modelLoader';
⋮----
// Track loading status
⋮----
/**
 * Preload all crop models for the simulation
 * @returns {Promise<void>}
 */
export const preloadSimulationModels = async (): Promise<void> =>
⋮----
// Preload all crop models
⋮----
// Set loading callbacks
⋮----
/**
 * Get current model loading progress
 * @returns {number} - Loading progress from 0 to 1
 */
export const getModelLoadingProgress = (): number =>
⋮----
/**
 * Check if all models are loaded
 * @returns {boolean} - True if all models are loaded
 */
export const areModelsLoaded = (): boolean =>
⋮----
/**
 * Creates a crop field simulation
 * @param {Object} simulation - Simulation parameters
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {THREE.PerspectiveCamera} camera - The THREE.js camera
 * @param {OrbitControls} controls - The OrbitControls instance
 * @returns {Object} - Created simulation objects
 */
export const createCropFieldSimulation = (simulation, scene, camera, controls) =>
⋮----
// Start preloading models in the background if not already loaded
⋮----
// Scale the polygon based on hectares
⋮----
// Create field boundary
⋮----
// Create soil
⋮----
// Triangulate the polygon for plant placement
⋮----
// Generate grid-based plant positions
⋮----
// Determine maximum number of plants to render based on performance considerations
// We'll use a higher limit since we're using 3D models with proper scaling
⋮----
// Calculate sample rate if we have too many plants
⋮----
// Create plants at grid positions with sampling
⋮----
// Create plant using the sync version for initial setup
⋮----
// Add random rotation for natural variation
⋮----
// Add information sign - DISABLED per user request
// const signObjects = createFieldInfoSign(scene, simulation, scaledPolygon);
// simulationObjects.push(...signObjects);
⋮----
// Adjust camera to view the entire field
⋮----
// Export other utilities
</file>

<file path="lib/simulation/plantGrowth.ts">
import { PLANT_HEIGHTS, SCALE_FACTOR } from '../crops';
⋮----
// Growth stage modifiers (0-1) for different growth phases
⋮----
SEEDLING: 0.2,      // Initial growth
VEGETATIVE: 0.6,    // Main growth phase
REPRODUCTIVE: 0.9,  // Flowering/fruiting phase
MATURE: 1.0         // Fully mature
⋮----
/**
 * Update plants in the scene based on growth stage and actual crop heights
 * Supports both geometry-based plants and 3D models
 * @param {Object} timelineDay - The current day's data
 * @param {Array} plants - Array of plant objects in the scene
 * @param {string} cropType - Type of crop
 */
export const updatePlantsForGrowthStage = (timelineDay, plants, cropType) =>
⋮----
// Get the actual base height from crop constants (in meters)
⋮----
// Scale factor applied to match the 3D scene scale
⋮----
// Update each plant
⋮----
// Skip non-plant objects
⋮----
// Skip plants that are still loading their models
⋮----
// Apply growth stage-specific scaling
⋮----
// Determine if this is a 3D model or a geometry-based plant
⋮----
// Update 3D model plant
⋮----
// Update geometry-based plant (legacy)
⋮----
/**
 * Calculate plant scale based on growth factor and stage
 */
function calculatePlantScale(growthFactor, growthStage)
⋮----
// Small plants in seedling stage (10-30% of full size)
⋮----
// Rapid growth in vegetative stage (30-70% of full size)
⋮----
// Slower growth in reproductive stage (70-90% of full size)
⋮----
// Full size in mature stage (90-100% of full size)
⋮----
// Fallback to direct percent if stage not recognized
⋮----
// Ensure scale is within reasonable bounds
⋮----
/**
 * Update a plant based on 3D model approach
 */
function updateModelPlant(plant, plantScale, growthStage, cropType)
⋮----
// If the plant has an originalScale stored, use that as a reference
⋮----
// Apply plant-wide scaling (may be refined for particular plant components)
⋮----
// Handle visibility of different plant parts based on growth stage
⋮----
// Skip non-meshes
⋮----
// Handle fruit/grain visibility based on growth stage
⋮----
// Fruits only appear in reproductive and mature stages
⋮----
// Enhance fruits in mature stage
⋮----
const fruitScale = 1.2; // Slightly larger fruits when mature
⋮----
// Handle flowers which appear in reproductive stage then become fruit
⋮----
// Flowers appear in early reproductive stage and may disappear in mature
⋮----
// Apply crop-specific visual effects
⋮----
/**
 * Apply crop-specific visual effects for 3D models
 */
function applyCropSpecificEffects(meshNode, cropType, growthStage, plantScale)
⋮----
// For corn specifically, enhance cob visibility based on growth
⋮----
// Primary cob - show only in reproductive and mature stages
⋮----
// Determine which cob this is (primary or secondary)
⋮----
// Secondary cobs only appear in mature stage with healthy plants
⋮----
// Wheat heads gradually change color as they mature
⋮----
// Transition from green to golden
⋮----
0.5 + (0.5 * greenToGold),  // R: 0.5 to 1.0
0.5 + (0.3 * greenToGold),  // G: 0.5 to 0.8
0.2                         // B: constant low value
⋮----
// Golden when mature
⋮----
// Cotton bolls gradually open as they mature
⋮----
// Bolls are green and closed in early reproductive stage
⋮----
// Start to open/whiten in late reproductive
⋮----
// Slightly increase scale to show "opening"
⋮----
// Fully white and open in mature stage
⋮----
// Expanded scale for fully open bolls
⋮----
/**
 * Update a plant based on the legacy geometry approach
 */
function updateGeometryPlant(plant, plantScale, growthStage, cropType)
⋮----
// Set scale of the plant to match the growth progress
⋮----
// Handle crop-specific visual changes based on growth stage
⋮----
// For corn specifically, show/hide cobs based on growth stage
⋮----
// Primary cob - show only in reproductive and mature stages
⋮----
// Secondary cob (if exists) - show only in mature stage
⋮----
// For soybean, show pods only in reproductive and mature stages
⋮----
// Identify pod elements in the soybean model (typically these are positioned higher up)
⋮----
// For wheat, show wheat heads only in reproductive and mature stages
⋮----
// Wheat head is typically the second child in our model
⋮----
// For cotton, show cotton bolls only in reproductive and mature stages
⋮----
// Cotton bolls are typically white sphere geometries
⋮----
// Make bolls more visible in mature stage
⋮----
// For rice, show grains only in reproductive and mature stages
⋮----
// Rice grains are typically at the top and have cone geometries
⋮----
/**
 * Determine growth stage based on growth percentage
 * @param {number} growthFactor - Growth percentage (0-1)
 * @returns {string} Growth stage
 */
export const determineGrowthStage = (growthFactor) =>
</file>

<file path="public/data/crop_gdd_data.csv">
crop,base_temperature,total_gdd,baseline_yield
soybean,10,1125,5.4
wheat,5,1825,5
corn,10,2700,12.8
cotton,16,2500,1.7
rice,10,2400,7.33
</file>

<file path="components/farm/LocationInputWithMap.tsx">
// components/farm/LocationInputWithMap.tsx
⋮----
import React, { useState, useEffect, useRef } from 'react';
import MapComponent from './MapComponent';
⋮----
interface LocationInputWithMapProps {
    onLocationChange: (latitude: number, longitude: number, locationName: string) => void;
    initialLocation: {
        latitude: number;
        longitude: number;
        name: string;
    };
    disabled?: boolean;
}
⋮----
interface GeocodeResult {
    name: string;
    country: string;
    state?: string;
    lat: number;
    lon: number;
}
⋮----
// Initialize with the provided values
⋮----
// Handle map location selection
const handleMapLocationSelect = (lat: number, lng: number) =>
⋮----
// Reverse geocode to get location name
⋮----
// Reverse geocode to get location name from coordinates
const reverseGeocode = async (lat: number, lon: number) =>
⋮----
// Use OpenStreetMap Nominatim for reverse geocoding
⋮----
'User-Agent': 'Farm Bio-Boost Simulator' // Nominatim requires a user agent
⋮----
// Create a more concise location name
⋮----
// Search for location by name
const searchLocation = async () =>
⋮----
// Use OpenStreetMap Nominatim for search
⋮----
'User-Agent': 'Farm Bio-Boost Simulator' // Nominatim requires a user agent
⋮----
// Handle location selection from search results
const selectLocation = (result: GeocodeResult) =>
⋮----
// Notify parent component
⋮----
// Handle manual entry of coordinates
const handleManualCoordinates = () =>
⋮----
{/* Map for visual selection */}
⋮----
{/* Search by place name */}
⋮----
onChange=
⋮----
{/* Search results dropdown */}
⋮----
{/* Display current location */}
</file>

<file path="lib/simulation/fieldUtils.ts">
import { HECTARE_TO_SQUARE_METERS, SCALE_FACTOR, PLANT_ROW_SPACING, PLANT_SPACING_IN_ROW, RANDOMIZATION_FACTORS } from '../crops';
⋮----
/**
 * Calculate the area of a polygon in square units
 * @param {Array} vertices - Array of vertices defining the polygon
 * @returns {number} - Area of the polygon
 */
export const calculatePolygonArea = (vertices) =>
⋮----
/**
 * Calculate the dimensions of a polygon
 * @param {Array} vertices - Array of vertices defining the polygon
 * @returns {Object} - Object containing width, height, and center of the polygon
 */
export const calculatePolygonDimensions = (vertices) =>
⋮----
/**
 * Scale polygon to match the specified hectare size
 * @param {Array} polygon - Array of vertices defining the polygon
 * @param {number} hectares - Target size in hectares
 * @returns {Array} - Scaled polygon vertices
 */
export const scalePolygonToHectares = (polygon, hectares) =>
⋮----
// Calculate centroid
⋮----
// Scale points relative to centroid - ensure field stays within boundaries
const maxDimension = 150; // Maximum size for any dimension to prevent going outside view
⋮----
0, // y-coordinate stays at 0
⋮----
// Check if any dimension exceeds our max limits
⋮----
// If either dimension is too large, apply additional scaling
⋮----
// Ensure minimum field size for visibility - no fields smaller than 40x40
⋮----
/**
 * Triangulate a polygon for plant placement
 * @param {Array} polygon - Array of vertices defining the polygon
 * @returns {Array} - Array of triangles (each triangle is an array of 3 vertices)
 */
export const triangulatePolygon = (polygon) =>
⋮----
// Simple ear-clipping triangulation (for convex polygons)
⋮----
/**
 * Generate a random point within a triangle using barycentric coordinates
 * @param {Array} triangle - Array of 3 vertices defining the triangle
 * @returns {Object} - Random point {x, z} within the triangle
 */
export const getRandomPointInTriangle = (triangle) =>
⋮----
// Create barycentric coordinates
⋮----
// Ensure the point is within the triangle
⋮----
// Calculate the position
⋮----
/**
 * Check if a point is inside the polygon
 * @param {Object} point - Point {x, z} to check
 * @param {Array} polygon - Array of vertices defining the polygon
 * @returns {boolean} - True if the point is inside the polygon
 */
export const isPointInPolygon = (point, polygon) =>
⋮----
/**
 * Generate grid-based plant positions for a field
 * @param {Array} polygon - Array of vertices defining the polygon
 * @param {string} cropType - Type of crop
 * @param {number} density - Density percentage (0-100)
 * @returns {Array} - Array of plant positions {x, z}
 */
export const generateGridPlantPositions = (polygon, cropType, density) =>
⋮----
// Get field dimensions
⋮----
// Get spacing for this crop type
⋮----
// Apply density adjustment - increase spacing when density is lower
⋮----
// Scale to Three.js coordinates
⋮----
// Calculate grid dimensions to ensure coverage of the field
// Add padding to ensure we cover the entire field
⋮----
// Calculate number of rows and columns in the grid
const numRows = Math.ceil(height / scaledRowSpacing) + 2; // Add buffer
const numCols = Math.ceil(width / scaledPlantSpacing) + 2; // Add buffer
⋮----
// Calculate the starting position (top-left of grid)
⋮----
// Create grid with straight rows from left to right
⋮----
// Calculate base position
⋮----
// Apply minimal random variation to maintain the grid pattern
// but still provide some natural variation
const randomFactor = 0.1; // Very small randomization to maintain row alignment
⋮----
// Only add the position if it's inside the polygon
⋮----
/**
 * Creates a field information sign at the centroid of the field
 * @param {THREE.Scene} scene - The THREE.js scene
 * @param {Object} simulation - Simulation parameters
 * @param {Array} scaledPolygon - Scaled polygon vertices
 * @returns {Array} - Array of created objects
 */
export const createFieldInfoSign = (scene, simulation, scaledPolygon) =>
⋮----
// Calculate centroid of the field for sign placement
⋮----
// Create sign post
⋮----
// Create sign
⋮----
// Create canvas for sign text
⋮----
// Fill background
⋮----
// Add border
⋮----
// Add text
⋮----
// Create texture from canvas
</file>

<file path="lib/weather/weatherService.tsx">
// lib/weather/weatherService.ts
⋮----
// List of standardized weather types
⋮----
export function generateCerradoWeather(
  latitude, 
  longitude, 
  startDate, 
  days
)
⋮----
// Cerrado climate characteristics:
// - Distinct wet season (October-April) and dry season (May-September)
// - Hot temperatures year-round, with slightly cooler in dry season
// - Very high humidity in wet season, very low in dry season
⋮----
// Determine season based on month in Southern Hemisphere
⋮----
// Wet season: October (9) through April (3)
// Dry season: May (4) through September (8)
⋮----
// Base temperature for Cerrado (generally hot)
// Slightly cooler in dry season, especially June-July
⋮----
// Dry season cooler months (May-August)
baseTemp = 25 + Math.random() * 3; // 25-28°C
⋮----
// Wet season and dry season transition months
baseTemp = 28 + Math.random() * 4; // 28-32°C
⋮----
// Weather determination with seasonal probability
⋮----
// Wet season: Higher probability of rain and clouds
⋮----
// Dry season: Higher probability of sun and clear skies
⋮----
else weatherType = 'cloudy'; // Very rare rain in dry season
⋮----
// Temperature adjustments based on weather
⋮----
// Add small random variation
const tempVariance = (Math.random() * 2) - 1; // -1 to +1 degrees
⋮----
// Humidity based on season and weather
⋮----
// Wet season: high humidity
baseHumidity = 75 + Math.random() * 20; // 75-95%
⋮----
// Dry season: low humidity
baseHumidity = 30 + Math.random() * 20; // 30-50%
⋮----
// Adjust humidity based on weather type
⋮----
// Calculate final humidity with bounds
⋮----
// Calculate growth factor based on Cerrado-specific conditions
// Plants in Cerrado are adapted to seasonal drought and fire cycles
⋮----
// In Cerrado, some crops do best with moderate water during wet season
// Too much rain can cause problems, while dry season requires irrigation
⋮----
weatherType === 'partly_cloudy' ? 1.0 : // optimal
⋮----
// Moisture is critical - Cerrado soils drain quickly and dry season is very dry
⋮----
(finalHumidity <= 90 ? 1 : 0.7); // Too much humidity can cause fungal issues
⋮----
// Adjust growthFactor weights for Cerrado (moisture is more important)
⋮----
// Get appropriate weather settings
⋮----
windSpeed: isWetSeason ? 2 + Math.random() * 3 : 4 + Math.random() * 5, // Stronger winds in dry season
⋮----
// Move to next day
⋮----
// Weather effects settings
⋮----
// Interface for weather data from API
export interface WeatherApiResponse {
    main: {
      temp: number;
      humidity: number;
    };
    weather: {
      id: number;
      main: string;
      description: string;
    }[];
    wind: {
      speed: number;
    };
    dt: number; // Unix timestamp
  }
⋮----
dt: number; // Unix timestamp
⋮----
// Interface for historical weather data
export interface HistoricalWeatherDay {
    date: string;
    temperature: number;
    humidity: number;
    weatherType: string;
    windSpeed: number;
  }
⋮----
// Interface for simulation weather day
export interface SimulationWeatherDay {
    date: Date;
    dayNumber: number;
    dateString: string;
    weather: string;
    temperature: number;
    humidity: number;
    growthFactor: number;
    settings: any;
  }
⋮----
// Map OpenWeatherMap condition codes to our weather types
export function mapWeatherCodeToType(code: number): string
⋮----
// Thunderstorm: 200-299
⋮----
// Drizzle and Rain: 300-599
⋮----
// Snow: 600-699 - we'll map to rainy for now
⋮----
// Atmosphere (fog, mist, etc): 700-799
⋮----
// Clear: 800
⋮----
// Clouds: 801-899
⋮----
// Few clouds (801) or scattered clouds (802) maps to partly cloudy
⋮----
// Default
⋮----
// Calculate growth factor based on weather conditions
export function calculateGrowthFactor(temperature: number, weatherType: string, humidity: number): number
⋮----
// Optimal temperature range for most crops is around 15-25°C (59-77°F)
⋮----
// Plants like sunlight but need some water too
⋮----
// Optimal humidity range is around 60-70%
⋮----
// Combine factors with different weights
⋮----
// Generate random historical weather for a location based on climate patterns
export function generateHistoricalWeather(
    latitude: number, 
    longitude: number, 
    startDate: Date, 
    days: number
): HistoricalWeatherDay[]
⋮----
// Determine hemisphere and adjust seasonal patterns
⋮----
// Get month to determine season
⋮----
// Determine season based on hemisphere
⋮----
// Adjust base temperature based on latitude (equator is hotter)
⋮----
// Seasonal adjustments
⋮----
// Weather determination - weather patterns are more consistent
// and influenced by previous day
⋮----
// New weather pattern
⋮----
// Seasonal adjustments to weather probability
⋮----
// Continue previous weather pattern
⋮----
// Some chance of change
⋮----
// Adjust temperature based on weather
⋮----
// Add some random variation
const tempVariance = (Math.random() * 4) - 2; // -2 to +2 degrees
⋮----
// Calculate humidity based on weather type and location
let baseHumidity = 60; // Default humidity
⋮----
// Adjust humidity based on weather
⋮----
// Add some random variation to humidity
const humidityVariance = (Math.random() * 10) - 5; // -5 to +5 percent
⋮----
// Generate wind speed based on weather and location
let baseWindSpeed = 2 + Math.random() * 3; // Base wind speed in m/s
⋮----
// Adjust wind speed based on weather
⋮----
// Add to weather data array
⋮----
// Move to next day
⋮----
// Convert historical weather data to simulation weather days
export function convertToSimulationWeatherDays(
    historicalData: HistoricalWeatherDay[]
): SimulationWeatherDay[]
⋮----
// Fetch current weather data from OpenWeatherMap API
export async function fetchCurrentWeather(
    latitude: number,
    longitude: number,
    apiKey: string
): Promise<WeatherApiResponse>
⋮----
// Convert API response to our weather format
export function processWeatherApiResponse(
    apiResponse: WeatherApiResponse
):
⋮----
// Get weather code from the first weather item
⋮----
export function enhancedGenerateHistoricalWeather(
    latitude, 
    longitude, 
    startDate, 
    days
)
⋮----
// Check if the location is in Mato Grosso, Brazil (approximate coordinates)
// Mato Grosso latitude range: -7 to -18
// Mato Grosso longitude range: -50 to -62
⋮----
// Use the original function for other regions
</file>

<file path="components/farm/FarmShapeStep.tsx">
// components/farm/FarmShapeStep.tsx
⋮----
import React, { useState, useEffect, useRef } from 'react';
import Image from 'next/image';
⋮----
interface FarmShapeStepProps {
    farmLocation: { latitude: number; longitude: number; name: string };
    farmSize: number;
    onComplete: (polygonPoints: Array<{ latitude: number; longitude: number }>) => void;
    onBack: () => void;
}
⋮----
// Fetch satellite image when component mounts or when location/size changes
⋮----
// Initialize canvas when image is loaded
⋮----
// We'll set up the canvas after the image is fully loaded
⋮----
const handleImageLoad = () =>
⋮----
// Store the natural dimensions of the image
⋮----
// Set canvas dimensions based on the natural image size
⋮----
// Set the canvas size to match the image exactly
// This is important for preventing scaling/zooming issues
⋮----
// Clear canvas
⋮----
// Check if image is already loaded
⋮----
// Add load event listener
⋮----
// Cleanup
⋮----
// Update canvas when dimensions change or when redrawing polygon
⋮----
// Set canvas internal dimensions to match image's natural size
⋮----
// Clear the canvas
⋮----
// Draw the polygon points and lines
⋮----
// Draw the polygon points
⋮----
// Draw lines between points
⋮----
// Close the polygon if we have more than 2 points
⋮----
// Fill the polygon with a semi-transparent color
⋮----
// Draw points
⋮----
// Label the points
⋮----
// Fetch satellite image from API
const fetchSatelliteImage = async () =>
⋮----
// First, check if we're in development mode and should use a workaround
⋮----
// API endpoint based on your Python API
⋮----
// Try the direct fetch first
⋮----
// Convert response to blob and create URL
⋮----
// If we detect a CORS error, try the workaround
⋮----
// In development, use a Next.js API route proxy
⋮----
// If proxy isn't available, fall back to a placeholder or demo image
⋮----
// Using a placeholder image for demo purposes
⋮----
// If it's not a CORS error, rethrow
⋮----
// Set the image URL
⋮----
// Reset polygon data when loading a new image
⋮----
// Provide more specific error messaging for common issues
⋮----
// Fall back to a demo image in development mode
⋮----
// Handle canvas click for adding polygon points
const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) =>
⋮----
// Calculate the scale ratio between the canvas element size and its internal dimensions
⋮----
// Get the click position in canvas coordinates
⋮----
// Start drawing mode
const startDrawing = () =>
⋮----
// Complete the polygon
const completePolygon = () =>
⋮----
// Convert canvas coordinates to geo coordinates
⋮----
// This is a simplified conversion - in a real app you'd use proper geo-transformation
⋮----
// Convert canvas x,y to normalized 0-1 coordinates
⋮----
// Simple linear transformation from image space to geo space
// This assumes the image covers a rectangular area centered on farmLocation
// with a certain km per pixel resolution (derived from hectares)
const bufferKm = Math.sqrt(farmSize * 0.01 / Math.PI) * 1.1; // Same calculation as in the API
⋮----
// Approximate degrees per km at the equator
⋮----
// Calculate lat/lon offset from center (very simplified)
⋮----
// Undo last point
const undoLastPoint = () =>
⋮----
// Reset polygon
const resetPolygon = () =>
⋮----
// Continue to next step
const handleContinue = () =>
⋮----
{/* Image and drawing canvas */}
⋮----
{/* Canvas overlay - positioned absolutely within the container */}
⋮----
{/* Farm polygon data and navigation buttons */}
⋮----
{/* Navigation buttons */}
</file>

<file path="components/farm/MapComponent.tsx">
import React, { useEffect, useRef, useState } from 'react';
⋮----
interface MapComponentProps {
    latitude: number;
    longitude: number;
    onLocationSelect?: (lat: number, lng: number) => void;
    disabled?: boolean;
    className?: string;
    hectares?: number;
    showCircle?: boolean;
}
⋮----
const MapComponent: React.FC<MapComponentProps> = ({
    latitude,
    longitude,
    onLocationSelect,
    disabled = false,
    className = '',
    hectares,
    showCircle = false
}) =>
⋮----
// Generate a unique ID for this map instance to prevent conflicts
⋮----
// Function to clean up the map instance and remove it from the DOM
const cleanupMap = () =>
⋮----
// Remove all event listeners
⋮----
// Remove the map instance
⋮----
// Clear the reference
⋮----
// Also clear these references
⋮----
// Initialize map
⋮----
// Skip if no container or window.L not ready
⋮----
// Set a unique ID for the map container
⋮----
// Load Leaflet if not already loaded
const loadLeaflet = async () =>
⋮----
// Load CSS
⋮----
// Load JS
⋮----
const initializeMap = async () =>
⋮----
// Check again if container exists (might have unmounted during loading)
⋮----
// Clean up existing map if it exists
⋮----
// Create map instance
⋮----
// Add OpenStreetMap tile layer
⋮----
// Fix Leaflet's default icon path issues
⋮----
// Create custom icon
⋮----
// Add a marker at the initial position with custom icon
⋮----
// Add circle to show farm size if requested
⋮----
// Convert hectares to meters radius (sqrt of area ÷ π)
const areaInSquareMeters = hectares * 10000; // 1 hectare = 10,000 sq meters
⋮----
// Handle map click events
⋮----
// Update circle position if it exists
⋮----
// Handle marker drag events
⋮----
// Update circle position if it exists
⋮----
// Clean up function
⋮----
}, [mapId]); // Only run on component mount/unmount
⋮----
// Update marker and view when coordinates change
⋮----
// Update circle position if it exists
⋮----
// Define Leaflet on the Window object for TypeScript
⋮----
interface Window {
        L: any;
    }
</file>

<file path="app/globals.css">
:root {
⋮----
body {
⋮----
button,
⋮----
@layer base {
⋮----
h1 {
h2 {
h3 {
⋮----
.animate-shine {
⋮----
main {
⋮----
.crop-seedling {
⋮----
.crop-growing {
⋮----
.crop-mature {
⋮----
.crop-harvesting {
⋮----
.weather-rain {
⋮----
.notification {
</file>

<file path="app/layout.tsx">
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
⋮----
import Navbar from '@/components/ui/Navbar';
⋮----
export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
})
</file>

<file path="components/farm/FarmSetupWizard.tsx">
// components/farm/FarmSetupWizard.tsx
⋮----
import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import LocationInput from '@/app/simulation/components/LocationInput';
import LocationInputWithMap from './LocationInputWithMap';
import FarmShapeStep from './FarmShapeStep';
import FarmSizeStep from './FarmSizeStep';
import FarmReviewStep from './FarmReviewStep';
⋮----
// Import additional components as needed
⋮----
enum SetupStep {
    LOCATION = 0,
    FARM_SIZE = 1,
    FARM_SHAPE = 2,
    CROP_SELECTION = 3,
    REVIEW = 4
}
⋮----
// Wizard state
⋮----
// Farm configuration state
⋮----
const [farmSize, setFarmSize] = useState<number>(350); // Set default to 350 hectares
⋮----
// Default polygon points based on the farm center and size
⋮----
// Handle location change from LocationInput component
const handleLocationChange = (latitude: number, longitude: number, locationName: string) =>
⋮----
// Handle farm size change
const handleFarmSizeChange = (size: number) =>
⋮----
// Handle farm shape completion
const handleFarmShapeComplete = (polygonPoints: Array<
⋮----
// Handle crop type selection
const handleCropSelection = (crop: string) =>
⋮----
// Navigate to next step
const nextStep = () =>
⋮----
// Navigate to previous step
const prevStep = () =>
⋮----
// Start the simulation with collected data
const startSimulation = () =>
⋮----
// In a real application, you might want to save this data to a backend
// or pass it via state management to the simulation page
⋮----
// For now, we'll pass basic parameters through the URL
⋮----
// We'll need a more sophisticated way to pass the polygon data in a real app
// This is just a placeholder
⋮----
// Navigate to simulation page
⋮----
// Determine which step to render
⋮----
onClick=
⋮----
// Progress bar calculation
⋮----
{/* Loading overlay */}
⋮----
{/* Progress bar */}
⋮----
{/* Current step content */}
</file>

<file path="lib/crops/constants.ts">
// Constants for crop-related measurements and scaling
export const HECTARE_TO_SQUARE_METERS = 1000; // 1 hectare = 10,000 square meters
export const SCALE_FACTOR = 1.0; // Scale for visualization (1 meter = 1 unit in Three.js)
⋮----
// Plant density per hectare (approximate real-world values)
⋮----
corn: 80000,      // 80,000 plants per hectare
wheat: 2500000,   // 2.5 million plants per hectare
soybean: 400000,  // 400,000 plants per hectare
cotton: 100000,   // 100,000 plants per hectare
rice: 200000      // 200,000 plants per hectare
⋮----
// Plant heights in meters (approximate real-world values)
⋮----
corn: 2.5,      // 2.5 meters at full growth
wheat: 0.8,     // 0.8 meters at full growth
soybean: 1.5,   // 1.0 meters at full growth
cotton: 1.2,    // 1.2 meters at full growth
rice: 1.0       // 1.0 meters at full growth
⋮----
// Plant row spacing in meters (typical agricultural practice)
⋮----
corn: 0.76,     // 76 cm between rows
wheat: 0.15,    // 15 cm between rows
soybean: 0.5,   // 50 cm between rows
cotton: 1.0,    // 1 meter between rows
rice: 0.3       // 30 cm between rows
⋮----
// Plant spacing within rows in meters (typical agricultural practice)
⋮----
corn: 0.16,     // 16 cm between plants in a row
wheat: 0.025,   // 2.5 cm between plants in a row
soybean: 0.05,  // 5 cm between plants in a row
cotton: 0.1,    // 10 cm between plants in a row
rice: 0.15      // 15 cm between plants in a row
⋮----
// Randomization factors for natural-looking variations
⋮----
position: 0.05,    // Random position variation (% of spacing)
rotation: 0.5,     // Random rotation (radians)
scale: 0.15        // Random scale variation (% of size)
⋮----
// Returns a slightly varied height for natural variation
export const getRandomizedHeight = (baseHeight: number): number =>
⋮----
// Return between 85% and 115% of the base height
⋮----
// Calculate grid dimensions for a given crop type and field size
export const calculateGridDimensions = (cropType: string, fieldWidthMeters: number, fieldHeightMeters: number) =>
⋮----
// Calculate number of rows and plants per row
⋮----
// Different crops require different optimization strategies in Cerrado
⋮----
optimal: 28, // Optimal temperature for corn in Cerrado is higher
tolerance: 6  // Tolerance range +/- in degrees
⋮----
optimal: 65, // Optimal humidity percentage
drought_resistant: true // Corn varieties in Cerrado are bred for drought resistance
⋮----
optimal: 27, // Optimal temperature for soybean in Cerrado
⋮----
optimal: 30, // Cotton prefers hotter conditions
⋮----
optimal: 50, // Can handle drier conditions well
⋮----
optimal: 80, // Needs more water
⋮----
optimal: 25, // Lower optimal temp, challenging in Cerrado
⋮----
drought_resistant: false // Wheat struggles more during dry season
⋮----
/**
 * Calculate growth factor for crops in Cerrado region
 * @param {string} cropType - Type of crop
 * @param {number} temperature - Current temperature
 * @param {number} humidity - Current humidity
 * @param {string} weatherType - Current weather type
 * @returns {number} - Growth factor between 0-1
 */
export function calculateCerradoGrowthFactor(cropType, temperature, humidity, weatherType)
⋮----
// Temperature factor calculation - bell curve around optimal
⋮----
// Moisture/humidity factor calculation
⋮----
// Drought resistant crops can handle lower humidity better
⋮----
// Non-drought resistant crops need more consistent moisture
⋮----
// Sunlight factor based on weather
⋮----
// Calculating final growth factor with appropriate weights
// In Cerrado, temperature and moisture are especially critical
⋮----
// Additional Cerrado-specific adjustments:
// Growth boost for crops during optimal season
// Corn and soybean thrive in wet season, cotton can handle dry season better
⋮----
growthFactor *= isWetSeason ? 1.0 : 1.0; // Cotton is adaptable
⋮----
growthFactor *= isWetSeason ? 0.9 : 1.0; // Wheat does a bit better in drier conditions
</file>

<file path="package.json">
{
  "name": "start-hack",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "axios": "^1.8.4",
    "csv-parse": "^5.6.0",
    "dotenv": "^16.4.7",
    "leaflet": "^1.9.4",
    "next": "15.2.3",
    "openai": "^4.88.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-leaflet": "5.0.0-rc.2",
    "three": "^0.174.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/axios": "^0.9.36",
    "@types/express": "^5.0.1",
    "@types/leaflet": "^1.9.16",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/three": "^0.174.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="lib/simulation/timeline.ts">
// lib/simulation/timeline.ts - Updated version with location-based weather
⋮----
import {
    generateHistoricalWeather,
    WEATHER_TYPES
} from '../weather/weatherService';
import { applyWeatherToScene, RainSystem } from '../weather';
import { PLANT_HEIGHTS } from '../crops';
⋮----
import { enhancedGenerateHistoricalWeather } from '../weather/weatherService';
import { calculateCerradoGrowthFactor } from '../crops/constants';
⋮----
// Growth stage modifiers (0-1) for different growth phases
⋮----
SEEDLING: 0.2,      // Initial growth
VEGETATIVE: 0.6,    // Main growth phase
REPRODUCTIVE: 0.9,  // Flowering/fruiting phase
MATURE: 1.0         // Fully mature
⋮----
/**
 * Creates a timeline for crop growth and weather simulation
 * @param {Object} cropData - Crop type and initial parameters
 * @param {Date} startDate - Start date of simulation
 * @param {number} days - Number of days to simulate
 * @returns {Object} Timeline data
 */
export const createCropTimeline = (cropData, startDate = new Date(), days = 90) =>
⋮----
// Check if location is specifically in Mato Grosso
⋮----
// Generate weather data based on location
⋮----
// Use enhanced weather generator that supports Cerrado
⋮----
// Fallback to generic weather data if location is not provided
⋮----
// Add Mato Grosso flag to help with UI special cases
⋮----
isMatoGrosso  // Flag to indicate we're using Cerrado climate model
⋮----
export function convertToSimulationWeatherDays(
    historicalData,
    cropType = 'corn',
    isCerrado = false
)
⋮----
// Calculate growth factor based on region and crop type
⋮----
// Use Cerrado-specific growth model
⋮----
// Use standard growth model
⋮----
// Determine growth stage based on growth progress
⋮----
growthPercent: growthFactor, // For backward compatibility
⋮----
isCerrado: isCerrado // Flag to indicate using Cerrado model
⋮----
// Fallback function to generate generic weather data
const generateGenericWeatherData = (days, startDate = new Date()) =>
⋮----
// Get month to determine season
⋮----
// Determine season
⋮----
// Base temperature
⋮----
case 'spring': baseTemp = 15; break; // ~60°F
case 'summer': baseTemp = 25; break; // ~77°F
case 'fall': baseTemp = 18; break;   // ~64°F
case 'winter': baseTemp = 5; break;  // ~41°F
⋮----
// Random weather with seasonal influence
⋮----
// Spring and fall
⋮----
// Adjust temp based on weather
⋮----
// Random variation
const tempVariance = (Math.random() * 4) - 2; // -2 to +2 degrees
⋮----
// Generate humidity based on weather
⋮----
// Add random variation to humidity
const humidityVariance = (Math.random() * 10) - 5; // -5 to +5 percent
⋮----
// Calculate growth factor based on conditions
⋮----
// Calculate final growth factor
⋮----
// Get weather settings
⋮----
// Increment date by one day
⋮----
/**
 * Update plants in the scene based on growth stage
 * @param {Object} timelineDay - The current day's data
 * @param {Array} plants - Array of plant objects in the scene
 * @param {string} cropType - Type of crop
 */
export const updatePlantsForGrowthStage = (timelineDay, plants, cropType) =>
⋮----
// Update each plant
⋮----
// Skip non-plant objects
⋮----
// Adjust plant height based on growth
⋮----
// Ensure minimum scale to avoid invisible plants
⋮----
// Set the scale to match the growth percentage
⋮----
// For corn specifically, show/hide cobs based on growth stage
⋮----
// Find cobs (usually the 3rd and possibly 4th child in the corn plant)
⋮----
// Primary cob - show in reproductive and mature stages
⋮----
// Secondary cob (if exists) - show only in mature stage
⋮----
/**
 * Determine growth stage based on growth percentage
 * @param {number} growthFactor - Growth percentage (0-1)
 * @returns {string} Growth stage
 */
export const determineGrowthStage = (growthFactor) =>
⋮----
/**
 * Initialize timeline controls for the scene
 * @param {Object} timeline - Timeline data
 * @param {THREE.Scene} scene - The scene
 * @param {Object} sceneObjects - Object containing references to scene objects
 * @param {Function} setDayInfo - Function to update UI with day information
 * @returns {Object} Timeline controller
 */
export const initializeTimelineController = (timeline, scene, sceneObjects, setDayInfo) =>
⋮----
// Initialize rain system
⋮----
// Update the scene for a specific day
const updateSceneForDay = (dayIndex) =>
⋮----
// Determine growth stage if not already set
⋮----
// Update plants
⋮----
// Update weather effects
⋮----
// Update UI
⋮----
// Set up auto-advance
const setAutoAdvance = (enabled, intervalMs = 1000) =>
⋮----
// Stop at the end
⋮----
// Start with day 0
</file>

<file path="app/page.tsx">
import React, { useState } from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/Button';
import HeroSection from '@/components/ui/HeroSection';
import FarmSetupWizard from '@/components/farm/FarmSetupWizard';
import Image from 'next/image';
⋮----
export default function HomePage()
⋮----
const handleGetStarted = () =>
⋮----
// Smooth scroll to the wizard section
⋮----
{/* Persistent Background Container */}
⋮----
{/* Gradient overlay for text readability */}
⋮----
{/* Header Bar */}
⋮----
{/* Powered by Syngenta */}
⋮----
{/* Content Container */}
⋮----
{/* Show the hero section if we're not in wizard mode */}
⋮----
{/* Show the wizard when the user clicks "Get Started" */}
</file>

<file path="app/simulation/page.tsx">
import React, { useState, useEffect, useRef } from 'react';
import { useSearchParams } from 'next/navigation';
import { setupScene } from '@/lib/simulation/sceneSetup';
import { createSkybox, createTerrain, createClouds, animateClouds } from '@/lib/environment';
import {
    createCropFieldSimulation,
    preloadSimulationModels,
    getModelLoadingProgress,
    areModelsLoaded
} from '@/lib/simulation';
import { createCropTimeline, initializeTimelineController } from '@/lib/simulation/timeline';
import { updatePlantsForGrowthStage } from '@/lib/simulation/plantGrowth';
import { convertGeoPolygonTo3D, parsePolygonFromUrl } from '@/lib/utils/coordinateUtils';
import SeasonTimelineControls from './components/SeasonTimelineControls';
import ProductsPopup from './components/ProductsPopup';
⋮----
import Image from 'next/image';
⋮----
// Get URL params
⋮----
// Reference to the 3D container
⋮----
// Refs to hold three.js objects
⋮----
// Current simulation state
⋮----
// Model loading state
⋮----
// Timeline state
⋮----
const [totalDays, setTotalDays] = useState(90); // Default 3 months
⋮----
// Location state
⋮----
// Products popup state
⋮----
// Track model loading progress
⋮----
const checkProgress = () =>
⋮----
// Continue checking until loaded
⋮----
// Start preloading models
⋮----
// Initialize the scene
⋮----
// Setup THREE.js scene
⋮----
// Store references
⋮----
// Setup lights and store references
⋮----
// Create environment
⋮----
// Create clouds
⋮----
// Animation loop
const animate = () =>
⋮----
// Animate clouds
⋮----
// Update rain if active
⋮----
// Update controls
⋮----
// Render scene
⋮----
// Start animation loop
⋮----
// Load simulation based on URL params if available
⋮----
// Parse the polygon from URL
⋮----
// Create the farm location object
⋮----
// Convert the geo polygon to 3D coordinates
⋮----
// Create the simulation parameters
⋮----
hectares: Math.min(hectares, 1000), // Cap at 1000 hectares for performance
density: hectares > 100 ? 50 : hectares > 50 ? 75 : 100, // Adjust density based on farm size
⋮----
// This will trigger the simulation effect
⋮----
// Cleanup on unmount
⋮----
// Clean up timeline controller if exists
⋮----
// Clean up Three.js resources
⋮----
// Clear existing simulation and start a new one when parameters change
⋮----
// Small delay to ensure all references are properly set up
⋮----
// Remove all existing simulation objects
⋮----
// Clean up previous timeline controller
⋮----
// Create new simulation
⋮----
// Separate plants from other objects for growth animation
⋮----
// Use isPlant flag set during creation
⋮----
// Create timeline starting March 20th
⋮----
// Initialize timeline controller with our custom plant growth logic
⋮----
updatePlantsFunction: updatePlantsForGrowthStage // Use our improved function
⋮----
// Add this handler function:
const handleProductSelect = (product) =>
⋮----
// Add the product to applied products list
⋮----
// Here you would add logic to apply the product effects to the simulation
// For example, you might update growth rates, stress resistance, etc.
⋮----
// Display a temporary success message
⋮----
// Clear the message after 3 seconds
⋮----
// If you have a timeline controller, you could update plant properties here
⋮----
// Example of how you might modify the simulation:
// timelineController.applyProductEffect(product.name, product.effectStrength);
⋮----
{/* Header Bar */}
⋮----
{/* Powered by Syngenta */}
⋮----
{/* Timeline Controls */}
⋮----
{/* Main content */}
⋮----
{/* 3D View */}
⋮----
{/* Simulate Product Button */}
⋮----
{/* Products Popup */}
⋮----
{/* Option to also display applied products */}
⋮----
{/* Model Loading Progress */}
⋮----
{/* Error message */}
⋮----
onClick=
⋮----
{/* Loading indicator */}
</file>

</files>
